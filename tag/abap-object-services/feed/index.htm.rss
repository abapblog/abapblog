<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>ABAP Object Services | ABAP Blog</title>
	<atom:link href="https://abap-blog.ru/tag/abap-object-services/feed/" rel="self" type="application/rss+xml" />
	<link>https://abap-blog.ru</link>
	<description>Все о разработке в решениях от SAP</description>
	<lastBuildDate>Tue, 02 Mar 2021 06:11:09 +0000</lastBuildDate>
	<language>ru-RU</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.1</generator>
	<item>
		<title>ABAP Object Services &#8212; Интеграция с системой блокировок</title>
		<link>https://abap-blog.ru/database-work/abap-object-services-integraciya-s-sistemoj-blokirovok/</link>
					<comments>https://abap-blog.ru/database-work/abap-object-services-integraciya-s-sistemoj-blokirovok/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 17:03:42 +0000</pubDate>
				<category><![CDATA[Работа с БД]]></category>
		<category><![CDATA[ABAP Object Services]]></category>
		<category><![CDATA[lock concept]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2209</guid>

					<description><![CDATA[<p>На сервере приложений одновременно может работать большое число пользователей, которые в свою очередь работают параллельно с одними и теми же программами, может случиться ситуация, когда они попытаются одновременно обработать один и тот же объект (например, изменить поставку, заказ на закупку и т.п.). Чтобы в системе не возникало противоречивости данных, были придуманы блокировки, более подробно о [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/database-work/abap-object-services-integraciya-s-sistemoj-blokirovok/">ABAP Object Services — Интеграция с системой блокировок</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>На сервере приложений одновременно может работать большое число пользователей, которые в свою очередь работают параллельно с одними и теми же программами, может случиться ситуация, когда они попытаются одновременно обработать один и тот же объект (например, изменить поставку, заказ на закупку и т.п.). Чтобы в системе не возникало противоречивости данных, были придуманы блокировки, более подробно о концепции блокировок читайте в <a href="http://abap-blog.ru/abap/optimizaciya_integrazia/koncepciya-blokirovok-v-sap/">предыдущей статье</a>.</p>
<p>К сожалению, в ABAP Object Services нет встроенного механизма поддержки блокировок, что может привести к ошибкам и противоречивости данных при одновременном изменении одинаковых объектов.</p>
<p>Далее в ходе статьи мы разберем один из способов интеграции с системой блокировок.</p>
<p><span id="more-2209"></span></p>
<p>Но прежде чем рассматривать механизм интеграции, необходимо отметить следующее:</p>
<ul>
<li>При использовании системы блокировок, программисты должны позаботиться о том, чтобы заблокированный объект был, как можно быстрее разблокирован.</li>
<li>За установку и снятие блокировок, прежде всего, отвечает разработчик, но снятие блокировок может происходить и автоматически, данный аспект следует учитывать при интеграции с хранимыми объектами. Так если при выставлении блокировки был указан параметр _SCOPE= 2, система может автоматически снимет все блокировки при завершении транзакции верхнего уровня через метод UNDO или при вызове ROLLBACK WORK в режиме совместимости.  Если транзакция верхнего уровня была завершена методом END, либо в режиме совместимости был вызван оператор COMMIT WORK, система снимет блокировки только в том случае, если был зарегистрирован хотя бы один модуль обновления (V1). Transaction Service регистрирует модуль обновления, если не было указано что обновления необходимо производить напрямую (direct update) и если хранимый объект был изменен (по умолчанию, касается только изменения хранимых атрибутов).  Если вы используете прямое обновление или хранимый объект не изменялся, при выставленном параметре _SCOPE = 2, блокировки снимаются при завершении SAP LUW, либо принудительно через модуль разблокирования DEQUEUE_*.</li>
</ul>
<h4>Пессимистичные и оптимистичные блокировки</h4>
<p>Существует две основные стратегии блокирования: пессимистичная и оптимистичная. Стратегия, в данном случае, определяет порядок действий, выполняемых при блокировании и разблокировании объектов, а также поведение системы при обработке объектов блокировки.</p>
<ul>
<li>Оптимистичная стратегия подразумевает проверку на блокировку непосредственно перед записью в БД, т.е. множество пользователей в один момент времени могут изменять какой-либо объект (выставлена оптимистичная блокировка), но записывать эти изменения в БД можно только после преобразования оптимистичной блокировки в эксклюзивную. При этом после преобразования, все другие оптимистичные блокировки снимаются. Основное преимущество в такой стратегии, блокировка объекта происходит в достаточно короткие временные сроки.</li>
<li>Пессимистичная стратегия подразумевает блокировку непосредственно до начала выполнения какого-либо действия над объектом, т.е. чтобы начать изменять объект выставляется блокировка и если она успешна, интерфейс из состояния чтения объекта переходит в состояние изменения. После сохранения данных объекта блокировка снимается.</li>
</ul>
<p>Для того чтобы иметь возможность редактировать объект и быть уверенными в том, что блокировка установлена в классе агенте мы реализуем следующий метод:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/lock_and_get_persistent.png"><img loading="lazy" class="alignnone size-full wp-image-2211" src="http://abap-blog.ru/wp-content/uploads/2014/06/lock_and_get_persistent.png" alt="lock_and_get_persistent" width="790" height="156" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/lock_and_get_persistent.png 790w, https://abap-blog.ru/wp-content/uploads/2014/06/lock_and_get_persistent-300x59.png 300w" sizes="(max-width: 790px) 100vw, 790px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">METHOD lock_and_get_persistent.

  DATA:
    lv_status TYPE string,
    ls_key    TYPE typ_business_key,
    lv_text   TYPE string.

  ro_persistent =  me-&gt;get_persistent(
      i_carrid = iv_carrid
      i_connid = iv_connid
      i_fldate = iv_fldate
  ).

  ls_key-carrid = ro_persistent-&gt;get_carrid( ).
  ls_key-connid = ro_persistent-&gt;get_connid( ).
  ls_key-fldate = ro_persistent-&gt;get_fldate( ).

  CHECK iv_enqueue_mode IS NOT INITIAL.

  READ TABLE gt_locks
    WITH KEY carrid = ls_key-carrid
             connid = ls_key-connid
             fldate = ls_key-fldate
      TRANSPORTING NO FIELDS.

  CHECK sy-subrc NE 0.

  CALL FUNCTION 'ENQUEUE_ESFLIGHT'
    EXPORTING
      mode_sflight   = iv_enqueue_mode
      carrid         = ls_key-carrid
      connid         = ls_key-connid
      fldate         = ls_key-fldate
      _scope         = '3'
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno INTO lv_text
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

    RAISE EXCEPTION TYPE zcx_os_object_not_blocked
      EXPORTING
        text = lv_text.
  ENDIF.

  APPEND ls_key TO gt_locks.

  " После установки блокировки, необходимо обновить хранимый объект
  TRY.
      me-&gt;if_os_factory~refresh_persistent( ro_persistent ).
    CATCH cx_os_object_not_refreshable.
  ENDTRY.

ENDMETHOD.</pre><p>В методе присутствует входной параметр iv_enqueue_mode, внутри которого будем указывать стратегию блокировки, используемую для загружаемого объекта:</p>
<ul>
<li>«Е» &#8212; пессимистичная стратегия</li>
<li>«О» &#8212; оптимистичная стратегия</li>
</ul>
<p>Внутри метода происходит повторная загрузка хранимого объекта из БД и вызов модуля установки блокировки.</p>
<p>Благодаря параметру _scope = ‘3’ мы точно будем уверены в том, что блокировка не будет снята автоматически.</p>
<p>Так же был добавлен свой класс исключения zcx_os_object_not_blocked, данный класс уведомляет нас о невозможности продолжения работы с объектом из-за ошибки при выставлении блокировки. Подробнее о классах исключений смотрите <a href="http://abap-blog.ru/abap/abap-osnovi/obrabotka-osobyx-situacij-v-abap/">тут</a>. В классе исключения определен текст внутри которого выводится переданный в параметрах исключения text:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked_text.png"><img loading="lazy" class="alignnone size-full wp-image-2212" src="http://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked_text.png" alt="zcx_os_object_not_blocked_text" width="507" height="153" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked_text.png 507w, https://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked_text-300x90.png 300w" sizes="(max-width: 507px) 100vw, 507px" /></a></p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked2.png"><img loading="lazy" class="alignnone size-full wp-image-2213" src="http://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked2.png" alt="zcx_os_object_not_blocked2" width="928" height="288" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked2.png 928w, https://abap-blog.ru/wp-content/uploads/2014/06/zcx_os_object_not_blocked2-300x93.png 300w" sizes="(max-width: 928px) 100vw, 928px" /></a></p>
<p>Все заблокированные нашей программой объекты будут храниться в атрибуте класса агента с табличным типом TYP_BUSINESS_KEY_TAB:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/gt_locks.png"><img loading="lazy" class="alignnone size-full wp-image-2214" src="http://abap-blog.ru/wp-content/uploads/2014/06/gt_locks.png" alt="gt_locks" width="847" height="23" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/gt_locks.png 847w, https://abap-blog.ru/wp-content/uploads/2014/06/gt_locks-300x8.png 300w" sizes="(max-width: 847px) 100vw, 847px" /></a></p>
<p>При повторном вызове метода для уже заблокированного объекта, модуль блокировки запускаться не будет. <strong>Кроме того надо иметь в виду, что вызывать данный метод необходимо перед редактированием хранимого объекта. </strong></p>
<p>Тестовая программа, выводящая ошибку, в случае невозможности блокирования объекта (объект уже заблокирован эксклюзивной блокировкой):</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_flight TYPE REF TO zcl_spfliht,
  go_agent  TYPE REF TO zca_spfliht,
  go_error  TYPE REF TO zcx_os_object_not_blocked,
  gv_error  TYPE string.

  go_agent = zca_spfliht=&gt;agent.

  TRY.
      go_flight = go_agent-&gt;lock_and_get_persistent(
          iv_enqueue_mode = 'E'
          iv_carrid = 'AA'
          iv_connid = 17
          iv_fldate = '20130206'
      ).
    CATCH zcx_os_object_not_blocked INTO go_error.
      gv_error = go_error-&gt;get_text( ).
      WRITE gv_error.
      EXIT.
  ENDTRY.</pre><p>Результат обработки исключения:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/TestProgram.png"><img loading="lazy" class="alignnone size-full wp-image-2215" src="http://abap-blog.ru/wp-content/uploads/2014/06/TestProgram.png" alt="TestProgram" width="443" height="58" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/TestProgram.png 443w, https://abap-blog.ru/wp-content/uploads/2014/06/TestProgram-300x39.png 300w" sizes="(max-width: 443px) 100vw, 443px" /></a></p>
<p>Следующий шаг после изменения полученного объекта определяется в зависимости от стратегии блокировки, для пессимистичной стратегии необходимо чтобы после сохранения данных объекта в БД, выставленные ранее блокировки были сняты.</p>
<p>Для этого в классе агенте создан специальный метод снятия блокировки:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/unlock_object1.png"><img loading="lazy" class="alignnone size-full wp-image-2217" src="http://abap-blog.ru/wp-content/uploads/2014/06/unlock_object1.png" alt="unlock_object" width="426" height="38" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/unlock_object1.png 426w, https://abap-blog.ru/wp-content/uploads/2014/06/unlock_object1-300x26.png 300w" sizes="(max-width: 426px) 100vw, 426px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">method UNLOCK_OBJECT.
  DATA:
    ls_key TYPE typ_business_key.

  TRY.
    ls_key-carrid = io_persistent-&gt;get_carrid( ).
    ls_key-connid = io_persistent-&gt;get_connid( ).
    ls_key-fldate = io_persistent-&gt;get_fldate( ).
  CATCH cx_os_object_not_found.
    RETURN.
  ENDTRY.

  DELETE TABLE gt_locks 
    WITH TABLE KEY carrid = ls_key-carrid 
                   connid = ls_key-connid 
                   fldate = ls_key-fldate.

  IF sy-subrc = 0.

    CALL FUNCTION 'DEQUEUE_ESFLIGHT'
      EXPORTING
        mode_sflight = 'E'
        carrid       = ls_key-carrid
        connid       = ls_key-connid
        fldate       = ls_key-fldate.

    CALL FUNCTION 'DEQUEUE_ESFLIGHT'
      EXPORTING
        mode_sflight = 'O'
        carrid       = ls_key-carrid
        connid       = ls_key-connid
        fldate       = ls_key-fldate.

  ENDIF.

endmethod.</pre><p>Так как мы не знаем, какого типа в настоящий момент установлена блокировка, модуль разблокировки вызывается дважды.</p>
<p>Для оптимистичной стратегии блокирования необходимо до момента запроса на сохранение в БД, преобразовать выставленную ранее блокировку в эксклюзивную. Создадим в классе агенте следующий метод преобразования:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/convert_lock.png"><img loading="lazy" class="alignnone size-full wp-image-2218" src="http://abap-blog.ru/wp-content/uploads/2014/06/convert_lock.png" alt="convert_lock" width="696" height="62" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/convert_lock.png 696w, https://abap-blog.ru/wp-content/uploads/2014/06/convert_lock-300x26.png 300w" sizes="(max-width: 696px) 100vw, 696px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">METHOD convert_lock.
  DATA:
    ls_key  TYPE typ_business_key,
    lv_key  TYPE eqegraarg,
    lv_text TYPE string.

  TRY.
      ls_key-carrid = io_persistent-&gt;get_carrid( ).
      ls_key-connid = io_persistent-&gt;get_connid( ).
      ls_key-fldate = io_persistent-&gt;get_fldate( ).

    CATCH cx_os_object_not_found.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno INTO lv_text
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

      RAISE EXCEPTION TYPE zcx_os_object_not_blocked
        EXPORTING
          text = lv_text.
  ENDTRY.

  READ TABLE gt_locks
    WITH TABLE KEY
      carrid = ls_key-carrid
      connid = ls_key-connid
      fldate = ls_key-fldate
    TRANSPORTING NO FIELDS.

  IF sy-subrc NE 0.
    RAISE EXCEPTION TYPE zcx_os_object_not_blocked
      EXPORTING
        text = 'Объект не блокирован, преобразование невозможно'.
  ENDIF.

  CALL FUNCTION 'ENQUEUE_ESFLIGHT'
    EXPORTING
      mode_sflight   = 'R'
      carrid         = ls_key-carrid
      connid         = ls_key-connid
      fldate         = ls_key-fldate
      _scope         = '3'
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno INTO lv_text
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

    IF sy-subrc = 1.
      " Блокировка уже преобразована, если блокировка установлена не
      " нами, сбросим внутренние блокировки
      lv_key = ls_key.
      lv_key = sy-mandt &amp;&amp; lv_key.
      IF zenqueue_tools=&gt;check_enqueue(
          im_table_name    = 'SFLIGHT'
          im_key           = lv_key
          im_mode          = 'E'
      ) = abap_false.
        DELETE TABLE gt_locks WITH TABLE KEY
            carrid = ls_key-carrid
            connid = ls_key-connid
            fldate = ls_key-fldate.
      ELSE.
        " Если блокировка была преобразована нами,
        " выйдем
        RETURN.
      ENDIF.
    ENDIF.

    RAISE EXCEPTION TYPE zcx_os_object_not_blocked
      EXPORTING
        text = lv_text.
  ENDIF.

ENDMETHOD.</pre><p>Метод определения была ли блокировка выставлена нами выглядит следующим образом:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/check_enqueue.png"><img loading="lazy" class="alignnone size-full wp-image-2232" src="http://abap-blog.ru/wp-content/uploads/2014/06/check_enqueue.png" alt="check_enqueue" width="667" height="99" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/check_enqueue.png 667w, https://abap-blog.ru/wp-content/uploads/2014/06/check_enqueue-300x44.png 300w" sizes="(max-width: 667px) 100vw, 667px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">METHOD check_enqueue.
  DATA:
    lt_enqueues TYPE STANDARD TABLE OF seqg3,
    lv_wpnum    TYPE wpinfo-wp_no.

  CALL FUNCTION 'ENQUEUE_READ'
    EXPORTING
      gname                 = im_table_name
      garg                  = im_key
    TABLES
      enq                   = lt_enqueues
    EXCEPTIONS
      communication_failure = 1
      system_failure        = 2
      OTHERS                = 3.
  IF sy-subrc &lt;&gt; 0.
    rv_ownwp_enqueue = abap_false.
    RETURN.
  ENDIF.

  CALL FUNCTION 'TH_GET_OWN_WP_NO'
    IMPORTING
      wp_no = lv_wpnum.

  READ TABLE lt_enqueues WITH KEY gtwp = lv_wpnum gmode = im_mode TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    rv_ownwp_enqueue = abap_true.
  ELSE.
    rv_ownwp_enqueue = abap_false.
  ENDIF.
ENDMETHOD.</pre><p>После успешного преобразования может быть вызван COMMIT WORK или метод транзакции END. Закончив сохранения объекта в БД, можно вызвать снятие блокировок через метод рассмотренный ранее.</p>
<p>Описанная в данной статье схема интеграции с системой блокировок является лишь одной из возможных, в качестве альтернативной можно использовать автоматическое выставление блокировок до момента загрузки хранимого объекта из БД, делается это через переопределение метода в классе агенте: MAP_LOAD_FROM_DATABASE_KEY &#8212; если бизнес ключ на основе ключевых полей таблицы, MAP_LOAD_FROM_DATABASE_GUID – если бизнес ключ на основе GUID.</p>
<p>Можно так же автоматически снимать блокировки через агента проверки консистентности (класс реализующий интерфейс IF_OS_CHECK) хранимого объекта, но подобная автоматизация возможна только для ООП транзакций, т.к. исключения выдаваемые в агентах проверки невозможно обработать в транзакциях в режиме совместимости.</p>
<p>Подробнее об альтернативной схеме интеграции с системой блокировок можете прочитать в книге: <a href="http://store.sapinsider.wispubs.com/products/Object-Services-in-ABAP.html">Object Services in ABAP</a>.</p><p>The post <a href="https://abap-blog.ru/database-work/abap-object-services-integraciya-s-sistemoj-blokirovok/">ABAP Object Services — Интеграция с системой блокировок</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/database-work/abap-object-services-integraciya-s-sistemoj-blokirovok/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>ABAP Object Services – Persistence Service – часть 2</title>
		<link>https://abap-blog.ru/database-work/abap-object-services-persistence-service-chast-2/</link>
					<comments>https://abap-blog.ru/database-work/abap-object-services-persistence-service-chast-2/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 17:21:26 +0000</pubDate>
				<category><![CDATA[Работа с БД]]></category>
		<category><![CDATA[ABAP Object Services]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2187</guid>

					<description><![CDATA[<p>Продолжаем знакомство с ABAP Object Services, в этой части будут рассмотрены темы: менеджеры инстанций и постоянства,  пользовательские проверки при манипуляции с атрибутами хранимых классов, преобразование объектов в структуры и таблицы, загрузка связанных объектов без использования ссылочных атрибутов. Менеджер инстанций и менеджер постоянства (Persistency Manager) Как мы уже знаем каждый агент класса, содержит методы для создания, [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/database-work/abap-object-services-persistence-service-chast-2/">ABAP Object Services – Persistence Service – часть 2</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Продолжаем знакомство с ABAP Object Services, в этой части будут рассмотрены темы: менеджеры инстанций и постоянства,  пользовательские проверки при манипуляции с атрибутами хранимых классов, преобразование объектов в структуры и таблицы, загрузка связанных объектов без использования ссылочных атрибутов.</p>
<p><span id="more-2187"></span></p>
<h3>Менеджер инстанций и менеджер постоянства (Persistency Manager)</h3>
<p>Как мы уже знаем каждый агент класса, содержит методы для создания, изменения, удаления хранимых объектов, получения хранимых объектов определенного статуса. Данные методы предназначены для хранимых объектов конкретного хранимого класса. Используя менеджер инстанций и менеджер постоянства, мы можем запускать аналогичные методы, не имея ссылки на агент конкретного хранимого класса.</p>
<p>Для доступа к менеджеру инстанции (классу реализующему интерфейс <strong>IF_</strong><strong>OS_</strong><strong>INSTANCE_</strong><strong>MANEGER</strong>) нужно воспользоваться статическим методом <strong>get_</strong><strong>instance_</strong><strong>manager</strong>() класса <strong>CL_</strong><strong>OS_</strong><strong>SYSTEM</strong>. Данный класс реализует те же самые методы, что и <strong>IF_</strong><strong>OS_</strong><strong>CA_</strong><strong>INSTANCE</strong>, за исключением методов для временных хранимых объектов. Кроме того данный класс позволяет получить (изменить SET_STATUS()) статус любого объекта, метод <strong>GET_</strong><strong>STATUS</strong>().</p>
<p>Пример использования менеджера инстанций:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_instance_manager TYPE REF TO IF_OS_INSTANCE_MANAGER,
  gt_all_objects      TYPE osreftab.

go_instance_manager = cl_os_system=&gt;get_instance_manager( ).
gt_all_objects = go_instance_manager-&gt;get_loaded( ).</pre><p>Менеджер постоянства позволяет инициировать объекты с помощью QUERY или таблицы с ключевыми полями, но с обязательным указанием имени класса:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  gt_flights_keys TYPE STANDARD TABLE OF scol_flight_key,
  go_pm TYPE REF TO if_os_persistency_manager,
  gs_cn TYPE SEOCLSKEY,
  gt_spflights TYPE osreftab.

go_pm = cl_os_system=&gt;get_persistency_manager( ).

" 1. Получаем ключевые поля для инициализации объектов
SELECT * FROM sflight INTO CORRESPONDING FIELDS OF TABLE gt_flights_keys.

" 2. Получаем список всех объектов
TRY.
  gs_cn-clsname = 'ZCL_SFLIGHT'.
  gt_sflights = go_pm-&gt;get_persistent_by_key_tab(
      i_class_name = gs_cn
      i_key_tab    = gt_flights_keys
  ).
  CATCH cx_os_class_not_found.
  CATCH cx_os_object_not_found.
ENDTRY.</pre><p></p>
<h3></h3>
<h3>Преобразование объектов в структуры и обратно</h3>
<p>Многие сервисы в R/3, как например ALV, не работают напрямую с объектами. Чтобы сформировать ALV, необходимо передать в качестве параметра внутреннюю таблицу. Допустим нам необходимо перенести все хранимые атрибуты объекта в произвольную структуру (имена полей и хранимых атрибутов должны совпадать), для этого напишем следующий код:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/methodheader.png"><img loading="lazy" class="alignnone size-full wp-image-2188" src="http://abap-blog.ru/wp-content/uploads/2014/06/methodheader.png" alt="methodheader" width="526" height="58" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/methodheader.png 526w, https://abap-blog.ru/wp-content/uploads/2014/06/methodheader-300x33.png 300w" sizes="(max-width: 526px) 100vw, 526px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">METHOD object_to_structure.
  DATA:
    lo_str_descr TYPE REF TO cl_abap_structdescr,
    lv_method    TYPE string.

  FIELD-SYMBOLS:
    &lt;ls_component&gt; TYPE abap_compdescr,
    &lt;lv_component&gt; TYPE any.

  TRY.
      lo_str_descr ?= cl_abap_structdescr=&gt;describe_by_data( ch_structure ).
    CATCH cx_sy_move_cast_error.
      RETURN.
  ENDTRY.

  LOOP AT lo_str_descr-&gt;components ASSIGNING &lt;ls_component&gt;.
    ASSIGN COMPONENT &lt;ls_component&gt;-name OF STRUCTURE ch_structure TO &lt;lv_component&gt;.
    CHECK sy-subrc = 0.

    lv_method = 'GET_' &amp;&amp; &lt;ls_component&gt;-name.

    TRY.
        CALL METHOD im_object-&gt;(lv_method)
          RECEIVING
            result = &lt;lv_component&gt;.
      CATCH cx_sy_dyn_call_illegal_method cx_os_object_not_found.
        CONTINUE.
    ENDTRY.
  ENDLOOP.
ENDMETHOD.</pre><p>В коде мы динамически формируем имя метода для получения хранимого атрибута, вызываем его и результат записываем в поле структуры. Получать структуру из объекта мы уже умеем, но для ALV нам нужна таблица, следующий код будет заполнять таблицу относительно таблицы ссылок:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/method_objects_to_table.png"><img loading="lazy" class="alignnone size-full wp-image-2189" src="http://abap-blog.ru/wp-content/uploads/2014/06/method_objects_to_table.png" alt="method_objects_to_table" width="513" height="62" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/method_objects_to_table.png 513w, https://abap-blog.ru/wp-content/uploads/2014/06/method_objects_to_table-300x36.png 300w" sizes="(max-width: 513px) 100vw, 513px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">METHOD objects_to_table.

  DATA:
    ls_structure    TYPE REF TO DATA,
    lo_tab_descr    TYPE REF TO cl_abap_tabledescr,
    lo_str_descr    TYPE REF TO cl_abap_structdescr,
    lo_object       TYPE REF TO object.

  FIELD-SYMBOLS: &lt;ls_line&gt; TYPE ANY.

  IF im_objects_table IS INITIAL.
    RETURN.
  ENDIF.

  CLEAR ch_table.
  lo_tab_descr ?= cl_abap_tabledescr=&gt;describe_by_data( ch_table ).

  TRY.
    lo_str_descr ?= lo_tab_descr-&gt;get_table_line_type( ).
  CATCH cx_sy_move_cast_error.
    RETURN.
  ENDTRY.

  CREATE DATA ls_structure TYPE HANDLE lo_str_descr.
  ASSIGN ls_structure-&gt;* TO &lt;ls_line&gt;.

  LOOP AT im_objects_table INTO lo_object.
    CLEAR &lt;ls_line&gt;.

    zcl_po_utils=&gt;object_to_structure(
      EXPORTING
        im_object    = lo_object
      CHANGING
        ch_structure = &lt;ls_line&gt;
    ).
    APPEND &lt;ls_line&gt; TO ch_table.
  ENDLOOP.
ENDMETHOD.</pre><p>Ну и последний метод – заполнение таблицы относительно объектов класса (статус объекта заполняется опционально):</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/agent_to_tab.png"><img loading="lazy" class="alignnone size-full wp-image-2190" src="http://abap-blog.ru/wp-content/uploads/2014/06/agent_to_tab.png" alt="agent_to_tab" width="780" height="174" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/agent_to_tab.png 780w, https://abap-blog.ru/wp-content/uploads/2014/06/agent_to_tab-300x66.png 300w" sizes="(max-width: 780px) 100vw, 780px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">METHOD agent_objects_to_table.
  DATA:
    lt_buffer       TYPE ostyp_ref_tab,
    lt_all_objects  TYPE ostyp_ref_tab.

  CHECK im_agent IS BOUND.

  IF im_loaded = abap_true.
    lt_buffer = im_agent-&gt;if_os_ca_instance~get_loaded( ).
    APPEND LINES OF lt_buffer TO lt_all_objects.
  ENDIF.

  IF im_created = abap_true.
    lt_buffer = im_agent-&gt;if_os_ca_instance~get_created( ).
    APPEND LINES OF lt_buffer TO lt_all_objects.
  ENDIF.

  IF im_deleted = abap_true.
    lt_buffer = im_agent-&gt;if_os_ca_instance~get_deleted( ).
    APPEND LINES OF lt_buffer TO lt_all_objects.
  ENDIF.

  IF im_changed = abap_true.
    lt_buffer = im_agent-&gt;if_os_ca_instance~get_changed( ).
    APPEND LINES OF lt_buffer TO lt_all_objects.
  ENDIF.

  IF im_not_loaded = abap_true.
    lt_buffer = im_agent-&gt;if_os_ca_instance~get_not_loaded( ).
    APPEND LINES OF lt_buffer TO lt_all_objects.
  ENDIF.

  IF im_transient = abap_true.
    lt_buffer = im_agent-&gt;if_os_ca_instance~get_transient( ).
    APPEND LINES OF lt_buffer TO lt_all_objects.
  ENDIF.

  IF lt_all_objects IS INITIAL.
    RETURN.
  ENDIF.

  zcl_po_utils=&gt;objects_to_table(
    EXPORTING
      im_objects_table = lt_all_objects
    CHANGING
      ch_table         = ch_table
  ).

ENDMETHOD.</pre><p>Пример отчета, выводящего данные запроса в ALV:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_query_manager  TYPE REF TO if_os_query_manager,
  go_query          TYPE REF TO if_os_query,
  gt_result         TYPE osreftab,
  gt_sflight        TYPE STANDARD TABLE OF sflight,
  go_salv_table     TYPE REF TO cl_salv_table,
  go_sflight_agent TYPE REF TO zca_sflight.

go_sflight_agent = zca_sflight=&gt;agent.
go_query_manager = cl_os_system=&gt;get_query_manager( ).

go_query = go_query_manager-&gt;create_query(
    i_filter     = 'FLDATE &lt;= ''' &amp;&amp; '20130306'''
).

go_sflight_agent-&gt;if_os_ca_persistency~get_persistent_by_query(
  EXPORTING
    i_query         = go_query
  RECEIVING
    result          = gt_result
).

zcl_po_utils=&gt;objects_to_table(
  EXPORTING
    im_objects_table = gt_result
  CHANGING
    ch_table      = gt_sflight
).

cl_salv_table=&gt;factory(
   IMPORTING
     r_salv_table   = go_salv_table
   CHANGING
     t_table        = gt_sflight
 ).

go_salv_table-&gt;display( ).</pre><p>В некоторых случаях, удобно заполнять объект на основе структуры, реализация аналогична заполнению структуры, только используется вызов метода SET:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/06/str_to_obj.png"><img loading="lazy" class="alignnone size-full wp-image-2191" src="http://abap-blog.ru/wp-content/uploads/2014/06/str_to_obj.png" alt="str_to_obj" width="527" height="60" srcset="https://abap-blog.ru/wp-content/uploads/2014/06/str_to_obj.png 527w, https://abap-blog.ru/wp-content/uploads/2014/06/str_to_obj-300x34.png 300w" sizes="(max-width: 527px) 100vw, 527px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">METHOD STRUCTURE_TO_OBJECT.
  DATA:
    lo_str_descr TYPE REF TO cl_abap_structdescr,
    lt_params    TYPE abap_parmbind_tab,
    ls_param     TYPE abap_parmbind,
    lv_method    TYPE string.

  FIELD-SYMBOLS:
    &lt;ls_component&gt; TYPE abap_compdescr,
    &lt;lv_component&gt; TYPE any.

  TRY.
      lo_str_descr ?= cl_abap_structdescr=&gt;describe_by_data( im_structure ).
    CATCH cx_sy_move_cast_error.
      RETURN.
  ENDTRY.

  LOOP AT lo_str_descr-&gt;components ASSIGNING &lt;ls_component&gt;.
    CLEAR: lt_params, ls_param.
    ASSIGN COMPONENT &lt;ls_component&gt;-name OF STRUCTURE im_structure TO &lt;lv_component&gt;.
    CHECK sy-subrc = 0.

    lv_method = 'SET_' &amp;&amp; &lt;ls_component&gt;-name.

    ls_param-name = 'I_' &amp;&amp; &lt;ls_component&gt;-name.
    ls_param-kind = cl_abap_objectdescr=&gt;exporting.
    GET REFERENCE OF &lt;lv_component&gt; INTO ls_param-value.
    INSERT ls_param INTO TABLE lt_params.

    TRY.
        CALL METHOD im_object-&gt;(lv_method)
          PARAMETER-TABLE
            lt_params.

      CATCH cx_os_object_not_found cx_sy_dyn_call_error.
        CONTINUE.
    ENDTRY.
  ENDLOOP.
ENDMETHOD.</pre><p>&nbsp;</p>
<h3>Пользовательская проверка при изменении атрибутов</h3>
<p>В ходе использования хранимых объектов и их атрибутов перед разработчиком встает задача контроля входных, выходных данных в SET_ GET_ методах. Изменять методы напрямую нельзя, т.к. при повторной генерации хранимого класса они будут перезатерты стандартным кодом.</p>
<p>Выйти из этой ситуации можно несколькими способами:</p>
<ul>
<li>Сделать атрибуты приватными, для доступа к хранимым атрибутам в таком случае придётся писать свои дополнительные методы, например: READ_ATTRNAME, WRITE_ATTRNAME. Из-за объема необходимого к написанию кода данный способ не является оптимальным.</li>
<li>Создать дочерний хранимый класс, в котором надо будет переопределить методы доступа к атрибутам и добавить необходимые проверки. Настройки сопоставления наследуются от родительского класса. Нагромождение классов, исходя только из необходимости дополнительных проверок, так же не является самым лучшим решением.</li>
<li>В качестве обертки над хранимым классом создать обычный класс с доп. проверками при доступе к хранимым атрибутам. По своей сложности сопоставим с предыдущим.</li>
<li>Ну и наконец, самым лучшим с точки зрения оптимальности, является способ использования Enhancement Framework. Дополнительная проверка в таком случае вставляется через расширение метода перед началом выполнения основного кода (неявная точка расширения), при повторной генерации класса, затирается только сгенерированная часть, проверки в расширении остаются не тронутыми.</li>
</ul>
<p>&nbsp;</p>
<h3>Загрузка вложенных объектов без хранимых атрибутов</h3>
<p>Рассмотренные ранее ссылочные атрибуты, когда один объект, через свой атрибут, ссылается на другой и система его автоматически подгружает, не могут быть использованы для связи один ко многим.  Реализовать подобную схему можно следующим образом:</p>
<ul>
<li>Внутри класса создать временный атрибут содержащий таблицу ссылок на вложенные объекты и флаг, указывающий на то, что они были загружены. В качестве примера возьмем хранимый класс «факультет» включающий в себя внутреннюю таблицу со ссылками на объекты хранимого класса «студент» &#8212; gt_students (TYPE STANDART TABLE OF REF TO zcl_student). Флаг загруженности – students_loaded.</li>
<li>Создать метод для получения внутренней таблицы со ссылками на студентов – get_students, метод должен содержать примерно следующий код (обработка исключений опущена):<br />
<pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  lo_qm         TYPE REF TO if_os_query_manager,
  lo_query      TYPE REF TO if_os_query,
  lo_ca_student TYPE REF TO zca_student,
  lo_students   TYPE osreftab,
  lo_student    TYPE REF TO zcl_student.

FIELD-SYMBOLS: &lt;lo_ref&gt; TYPE REF TO object.

IF me-&gt;students_loaded = abap_false.
  lo_qm = cl_os_system=&gt;get_query_manager( ).
  
  lo_query = lo_qm-&gt;create_query(
      i_filter     = 'PROFID = PAR1'
  ).
  
  lo_ca_student = zca_student=&gt;agent.
  lo_students = lo_ca_student-&gt;if_os_ca_persistency~get_persistent_by_query(
      i_query         = lo_query
      i_par1          = me-&gt;get_id( )
  ).
  
  LOOP AT lo_students ASSIGNING &lt;lo_ref&gt;.
    lo_student ?= &lt;lo_ref&gt;.
    APPEND lo_student TO me-&gt;gt_students.
  ENDLOOP.
  
  me-&gt;students_loaded = abap_true.
ENDIF.

rv_students = me-&gt;gt_students.</pre><br />
По аналогии можно написать метод для получения ссылки на конкретного студента из внутренней таблицы, относительно его идентификатора. Метод должен быть вызван на этапе инициализации объекта &#171;Факультет&#187;.</li>
<li>Так как объект «факультет» может быть удален из памяти PS (через метод RELEASE), надо позаботиться о том, чтобы инициализировать временные атрибуты &#8212; таблицу со ссылками на студентов и флаг. Делается это через определение метода INVALIDATE:<br />
<pre class="urvanov-syntax-highlighter-plain-tag">CLEAR me-&gt;gt_students.
me-&gt;students_loaded = abap_false.</pre>
</li>
</ul>
<p>В следующей части будут рассмотрены вопросы интеграции с системой блокировок SAP и переопределение методов доступа к данным.</p><p>The post <a href="https://abap-blog.ru/database-work/abap-object-services-persistence-service-chast-2/">ABAP Object Services – Persistence Service – часть 2</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/database-work/abap-object-services-persistence-service-chast-2/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>ABAP Object Services &#8212; Persistence Service &#8212; часть 1.</title>
		<link>https://abap-blog.ru/database-work/abap-object-services-persistence-service/</link>
					<comments>https://abap-blog.ru/database-work/abap-object-services-persistence-service/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Wed, 28 May 2014 19:03:16 +0000</pubDate>
				<category><![CDATA[Работа с БД]]></category>
		<category><![CDATA[ABAP Object Services]]></category>
		<category><![CDATA[persistence service]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=1977</guid>

					<description><![CDATA[<p>При разработке с использованием ABAP Objects разработчик неизбежно сталкивается с ситуацией, когда данные нужно либо загружать из каких-либо источников данных (БД, файлы и т.п.) в объекты, либо выгружать из объектов куда-либо. Системы, решающие задачу сопоставления информации из БД в объекты и обратно принято называть ORM системами. В объектно-ориентированном программировании объекты в программе представляют объекты из реального мира. В [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/database-work/abap-object-services-persistence-service/">ABAP Object Services — Persistence Service — часть 1.</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/orm.jpg"><img loading="lazy" class="alignleft wp-image-2003 size-full" src="http://abap-blog.ru/wp-content/uploads/2014/05/orm.jpg" alt="orm" width="362" height="438" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/orm.jpg 362w, https://abap-blog.ru/wp-content/uploads/2014/05/orm-247x300.jpg 247w" sizes="(max-width: 362px) 100vw, 362px" /></a>При разработке с использованием ABAP Objects разработчик неизбежно сталкивается с ситуацией, когда данные нужно либо загружать из каких-либо источников данных (БД, файлы и т.п.) в объекты, либо выгружать из объектов куда-либо.</p>
<p>Системы, решающие задачу сопоставления информации из БД в объекты и обратно принято называть <a href="http://ru.wikipedia.org/wiki/ORM">ORM</a> системами.</p>
<p>В объектно-ориентированном программировании объекты в программе представляют объекты из реального мира. В качестве примера можно рассмотреть адресную книгу, которая содержит список людей с нулём или более телефонов и нулём или более адресов. В терминах объектно-ориентированного программирования они будут представляться объектами класса «Человек», которые будут содержать следующий список полей: имя, список (или массив) телефонов и список адресов.</p>
<p>Суть задачи состоит в преобразовании таких объектов в форму, в которой они могут быть сохранены в файлах или базах данных, и которые легко могут быть извлечены в последующем, с сохранением свойств объектов и отношений между ними. Эти объекты называют «хранимыми» (англ. persistent).  В концепции SAP понятие «хранимый» объект заменено понятием «постоянный». В дальнейшем в статье будет использовано понятие «хранимый».</p>
<p>Работа с хранимыми объектами осуществляется с помощью встроенной в AS ABAP технологии ABAP Object Services. Данный инструмент можно разделить на три составляющие:</p>
<ul>
<li>Инструмент загрузки и сохранения объектов (Persistence Service)</li>
<li>Инструмент поиска в объектах по определенным критериям (Query Service)</li>
<li>Инструмент обработки транзакций (Transaction Service)</li>
</ul>
<p><span id="more-1977"></span></p>
<h2>Введение в Persistence Service</h2>
<p>В большинстве языков программирования объекты являются временными данными и хранятся непосредственно в памяти во время выполнения программы (в ABAP до момента, когда сборщик мусора их удалит). Обычно для сохранения или загрузки данных из объектов в БД понадобится писать специальные методы преобразования данных объекта в реляционную структуру и наоборот (например, <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">сериализовать</a>/десериализовать объект в XML и сохранить в таком виде в таблице). В качестве более простой альтернативы можно использовать Persistence Service, который представляет из себя отдельный программный слой, скрывающий от разработчика большинство деталей по обработке данных.</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/Persistence-service1.png"><img loading="lazy" class="size-full wp-image-1979 aligncenter" src="http://abap-blog.ru/wp-content/uploads/2014/05/Persistence-service1.png" alt="Persistence service" width="404" height="418" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/Persistence-service1.png 404w, https://abap-blog.ru/wp-content/uploads/2014/05/Persistence-service1-289x300.png 289w" sizes="(max-width: 404px) 100vw, 404px" /></a></p>
<p>Persistence Service позволяет связывать атрибуты хранимого объекта с полями в таблице базы данных, ракурсе или структуре. Каждая отдельная запись в таблице или ракурсе будет связана с отдельным объектом.</p>
<p>Есть несколько способов связывания хранимых объектов с данными в таблицах, ракурсах:</p>
<ul>
<li><strong>Связывание одного класса с одной записью в таблице (ракурсе)</strong>. Данный способ используется, когда все данные объекта хранятся в рамках одной записи таблицы/ракурса.</li>
<li><strong>Связывание одного класса с несколькими записями в разных таблицах (ракурсах)</strong>. Применяется, когда данные класса разбросаны по нескольким таблицам (У таблиц должен быть один бизнес ключ, либо один общий GUID – глобальный идентификатор). В реальной жизни чаще встречаются связи таблиц, где есть основная таблица, например, заголовок закупочного заказа (EKKO) и таблица с позицией (EKPO). Так как бизнес ключ у них разный, (в EKPO есть ключевое поле позиция, которого нет в EKKO) данный способ связи не подойдет.</li>
<li><strong>Связывание иерархий классов с записями в таблицах (ракурсах).</strong> Реализуется через ООП наследование. Наследование может быть двух видов: горизонтальным и вертикальным, подробное описание будет ниже.</li>
</ul>
<blockquote><p><span style="background-color: #ffffff;">Ракурсы используются в тех случаях, когда надо связать не все табличные поля с атрибутами хранимого класса.</span></p>
<p><span style="background-color: #ffffff;">Связывание со структурой из словаря используется в тех случаях, когда вы сами определяете методы для связи с объектом хранения информации (БД, файлом и т.п.) и сами заполняете данными хранимые объекты.</span></p></blockquote>
<p>Далее в статье в качестве источника данных всегда будет рассматриваться БД.</p>
<p>Чтобы создать класс для хранимых объектов, необходимо при его создании выставить специальный флаг:­­</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/persistence-flag.png"><img loading="lazy" class="alignnone size-full wp-image-1980" src="http://abap-blog.ru/wp-content/uploads/2014/05/persistence-flag.png" alt="persistence flag" width="350" height="340" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/persistence-flag.png 350w, https://abap-blog.ru/wp-content/uploads/2014/05/persistence-flag-300x291.png 300w" sizes="(max-width: 350px) 100vw, 350px" /></a></p>
<p>При создании хранимого класса, система автоматически генерирует код для манипуляции с объектами этого класса. Генерируемый код включает методы: чтения и изменения атрибутов объекта; загрузки объектов; сохранения объектов; удаление объектов и др. Если объект связан с БД, все эти методы генерируют SQL без участия программиста, в отдельных случаях программист может переопределить методы связывающие атрибуты хранимого объекта и базу данных.</p>
<p>При работе с хранимыми объектами, система позволяет создать в рамках рабочего процесса только один уникальный экземпляр для каждого хранимого объекта (не может быть создано несколько одинаковых хранимых объектов с одним и тем же ключом). Если во время работы программы потребуется получить ссылку на уже инициализированный хранимый объект, Persistence Service вернет ссылку на полученный ранее объект, без использования базы данных (получит ссылку из памяти). Таким образом, мы избегаем возможной несогласованности данных, если бы мы работали с несколькими одинаковыми объектами в рамках одного рабочего процесса и избежать лишней нагрузки на БД при получении объекта из памяти.</p>
<p>В специальном атрибуте агента класса (см. ниже), сохраняются все хранимые объекты. Объекты со статусом NOT_LOADED, хранятся только по <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%B0%D0%B1%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0">слабой ссылке</a>, что позволяет сборщику мусора в нужный ему момент их удалять (например, если не хватает памяти). Объекты с другими статусами хранятся как по слабой ссылке, так и по «сильной ссылке».</p>
<p>Так как объекты PS всегда хранятся в системной памяти, сборщик мусора не удаляет хранимые объекты, когда на них нет ссылок внутри программы. Сделано это для того, чтобы потом не загружать объект заново.  Если Вам необходимо сократить объем выделенной в приложении памяти, можно освободить неиспользуемые более хранимые объекты вручную, вызвав специальный метод. (IF_OS_FACTORY~RELEASE см. ниже).</p>
<p>Каждый хранимый объект имеет уникальный идентификатор, который отличает его от остальных объектов. Существует два типа идентификаторов:</p>
<ul>
<li><strong>Бизнес ключ</strong>, может состоять из определенных пользователем ключевых полей, всех допустимых типов кроме OS_GUID. Если вы используете бизнес ключ, вы должны связать ключевые поля из таблицы с атрибутами хранимого объекта. Если используется структура, то Вы сами решаете какое поле будет являться ключевым:<a href="http://abap-blog.ru/wp-content/uploads/2014/05/business-key.png"><img loading="lazy" class="alignnone size-full wp-image-1981" src="http://abap-blog.ru/wp-content/uploads/2014/05/business-key.png" alt="business key" width="571" height="100" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/business-key.png 571w, https://abap-blog.ru/wp-content/uploads/2014/05/business-key-300x52.png 300w" sizes="(max-width: 571px) 100vw, 571px" /></a></li>
</ul>
<ul>
<li><a href="http://ru.wikipedia.org/wiki/GUID">GUID</a> (глобальный идентификатор) генерируемый Persistence Service при создании хранимого объекта. Если вы используете GUID, в таблице, с которой связан хранимый объект, должно быть поле с типом OS_GUID. Данное поле может быть как ключевым полем таблицы, так и нет. Если вдруг, по какой-то причине, понадобится генерация GUID ручным образом, можно использовать класс: <strong>cl_</strong><strong>system_</strong><strong>uuid</strong>. При работе с объектами на основе GUID, может возникать ситуация, когда в БД сохранились записи с одним идентификатором, а класс уже получил новый GUID (после удаления и создания класса заново). После чего при попытке получить по GUID ссылку на объект будет вызываться исключение CX_OS_CLASS_NOT_FOUND (класс не найден). Для решения проблемы смотрите ноту 567253.</li>
</ul>
<p>Persistence Service позволяет работать со ссылочными атрибутами на другие хранимые объекты. К примеру, если хранимый объект имеет атрибут А со ссылкой на хранимый объект Б, система сохранит ссылку на хранимый объект Б в базе данных. А когда объект А будет загружаться из БД, объект Б по сохраненной ранее ссылке будет восстановлен. В целях производительности Persistence Service не загружает связанные таким образом объекты (объект Б) до момента их реального использования в программе («ленивая загрузка»). Это следует запомнить т.к. в случае отладки, может возникнуть вопрос, почему объект получен, но все еще пустой.</p>
<p>По типу хранения атрибуты могут быть двух видов:</p>
<ul>
<li><strong>Хранимые атрибуты</strong>. Содержимое <strong>хранимых</strong> атрибутов которые были изменены, после выполнения COMMIT WORK, сохраняется в связанной с этим атрибутом таблице, а при инициализации объекта загружается из неё. Загрузка хранимых атрибутов происходит только в момент доступа к какому-либо атрибуту через соответствующий метод. Доступ к ним возможен только через сгенерированные методы, несмотря на то, что доступ у такого атрибута будет Public.</li>
<li><strong>Временные атрибуты</strong>. Содержимое <strong>временных</strong> атрибутов не сохраняется в БД и существует только во время выполнения программы.  При первоначальной загрузке хранимого объекта из БД, эти атрибуты имеют свое первоначальное (intial) значение. Подобные атрибуты могут использоваться, например для каких либо расчётных полей.</li>
</ul>
<p>Следует запомнить, что для табличных полей должен быть явно определен тип в словаре, иначе их нельзя будет связывать с атрибутами классов. Т.е. если вы захотите использовать встроенный тип в таблице:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/table-key.png"><img loading="lazy" class="alignnone size-full wp-image-1982" src="http://abap-blog.ru/wp-content/uploads/2014/05/table-key.png" alt="table key" width="587" height="201" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/table-key.png 587w, https://abap-blog.ru/wp-content/uploads/2014/05/table-key-300x102.png 300w" sizes="(max-width: 587px) 100vw, 587px" /></a></p>
<p>Система не даст вам сделать сопоставление этого поля в атрибут класса.</p>
<h3>Сопоставление с атрибутами хранимых классов</h3>
<p>Далее на основе демонстрационной модели с полётами (пакет SAPBC_DATAMODEL) рассмотрим пример создания хранимого класса. Запускаем транзакцию <strong>SE24</strong> и создаем класс с именем ZCL_SFLIGHT:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/new-class.png"><img loading="lazy" class="alignnone size-full wp-image-1983" src="http://abap-blog.ru/wp-content/uploads/2014/05/new-class.png" alt="new class" width="350" height="340" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/new-class.png 350w, https://abap-blog.ru/wp-content/uploads/2014/05/new-class-300x291.png 300w" sizes="(max-width: 350px) 100vw, 350px" /></a><br />
Переходим к связыванию данных из таблицы SFLIGHT с атрибутами нашего класса:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect.png"><img loading="lazy" class="alignnone size-full wp-image-1984" src="http://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect.png" alt="sflight connect" width="427" height="121" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect.png 427w, https://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect-300x85.png 300w" sizes="(max-width: 427px) 100vw, 427px" /></a></p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect-2.png"><img loading="lazy" class="alignnone size-full wp-image-1985" src="http://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect-2.png" alt="sflight connect 2" width="399" height="98" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect-2.png 399w, https://abap-blog.ru/wp-content/uploads/2014/05/sflight-connect-2-300x73.png 300w" sizes="(max-width: 399px) 100vw, 399px" /></a><br />
На следующем экране необходимо связать поля из таблицы с атрибутами класса, т.к. в таблице SFLIGHT нет поля с типом OS_GUID, в качестве ключа будут использоваться ключевые поля из таблицы (бизнес ключ). Ключевые поля в классе будут доступны только для чтения. На данном этапе можно переопределить имя и описание для атрибута, видимость методов для доступа к атрибуту и необходимость создавать метод для записи атрибута (только чтение):</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/sflight-attributes.png"><img loading="lazy" class="alignnone size-full wp-image-1986" src="http://abap-blog.ru/wp-content/uploads/2014/05/sflight-attributes.png" alt="sflight attributes" width="668" height="601" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/sflight-attributes.png 668w, https://abap-blog.ru/wp-content/uploads/2014/05/sflight-attributes-300x269.png 300w" sizes="(max-width: 668px) 100vw, 668px" /></a></p>
<p>Для некоторых полей на данном диалоге можно выбрать тип присвоения (на рисунке С – Атрибут значения), все они будут рассмотрены на примерах более подробно.</p>
<p>Для каждого отображения создается запись в системных таблицах: <strong>SEOMAPATT </strong>и <strong>SEOMAPCLS</strong>. Если в ходе разработки к таблицам, связанным с хранимыми классами, добавятся поля (не ключевые), классы по-прежнему будут активны и никаких проблем с их работой не возникнет. Но если вы хотите добавить новые поля к классу, понадобится заново перейти в диалог сопоставления и связать все новые поля с атрибутами класса, после чего активировать класс.</p>
<p>Следующим шагом сохраняем наш класс и активируем его. После сохранения будут сгенерированы методы доступа к атрибутам класса и специальные классы для манипулирования хранимыми объектами нашего класса.</p>
<blockquote><p>Не рекомендуется вносить изменения в SET_ и GET_ методы, т.к. повторная активация класса связанная с изменением связывания объекта приведет к их повторной генерации и все пользовательские изменения будут затерты (для добавления в эти методы каких-либо своих проверок, можно воспользоваться специальными методиками, будут рассмотрены отдельно).</p></blockquote>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/generated-methods.png"><img loading="lazy" class="alignnone size-full wp-image-1987" src="http://abap-blog.ru/wp-content/uploads/2014/05/generated-methods.png" alt="generated methods" width="708" height="439" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/generated-methods.png 708w, https://abap-blog.ru/wp-content/uploads/2014/05/generated-methods-300x186.png 300w" sizes="(max-width: 708px) 100vw, 708px" /></a></p>
<p>Если потребуется создать временные атрибуты, их можно создать, так же, как и обычные атрибуты класса, непосредственно на закладке атрибуты.</p>
<h3>Компоненты Persistence Service</h3>
<p>Прежде чем работать с созданными классами, необходимо понять, каким образом с ними можно работать и что они из себя представляют.</p>
<p>Persistence Service это программный слой состоящий из основной части (системных классов) и части относящейся непосредственно к хранимому классу (классы генерируемые на этапе сохранения/активации). На следующем изображении показаны составные части PS:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/pscomp.gif"><img loading="lazy" class="alignnone size-full wp-image-1988" src="http://abap-blog.ru/wp-content/uploads/2014/05/pscomp.gif" alt="pscomp" width="650" height="872" /></a></p>
<h4>CL_persistent</h4>
<p>Данный класс создается Вами в строителе классов (созданный ранее ZCL_SFLIGHT). Нельзя создать объект этого класса непосредственно через оператор CREATE OBJECT, т.к. в его свойствах выставлен параметр CREATE PRIVATE или CREATE ABSTRACT.</p>
<p>Для создания класса необходимо будет воспользоваться специальными методами сгенерированного класса агента или актора (перевод SAP). Как было уже упомянуто выше в примере, система сама создает методы для доступа к атрибутам класса.</p>
<p>Каждый хранимый класс реализует интерфейс <strong>IF_OS_STATE</strong>. В данном интерфейсе можно переопределить следующие методы:</p>
<ul>
<li><strong>HANDLE_EXCEPTION</strong>. Данный метод вызывается, если произошло исключение в методах доступа к атрибутам. В данном методе можно обработать вызванное исключение, однако обычно это делает тот, кто использует методы доступа к атрибутам.</li>
<li><strong>INIT</strong>. Вызывается при создании временного или хранимого объекта сразу после того как были считаны хранимые атрибуты. В данном методе можно инициализировать временные атрибуты, назначить обработчики событий и т.п.</li>
<li><strong>INVALIDATE</strong>. Вызывается при удалении хранимого объекта, обновления его хранимых атрибутов из БД. Тут вы можете вновь инициализировать временные атрибуты, переназначить обработчики событий и т.п.</li>
</ul>
<p>Остальные методы (SET,GET) являются системными и их нельзя переопределять. Вообще, что касается переопределения, увидеть разрешено оно или нет, можно увидеть непосредственно в коде:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/donotmodify.png"><img loading="lazy" class="alignnone size-full wp-image-1990" src="http://abap-blog.ru/wp-content/uploads/2014/05/donotmodify.png" alt="donotmodify" width="586" height="332" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/donotmodify.png 586w, https://abap-blog.ru/wp-content/uploads/2014/05/donotmodify-300x169.png 300w" sizes="(max-width: 586px) 100vw, 586px" /></a></p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/modify.png"><img loading="lazy" class="alignnone size-full wp-image-1991" src="http://abap-blog.ru/wp-content/uploads/2014/05/modify.png" alt="modify" width="581" height="439" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/modify.png 581w, https://abap-blog.ru/wp-content/uploads/2014/05/modify-300x226.png 300w" sizes="(max-width: 581px) 100vw, 581px" /></a></p>
<h4>CA_persistent и CB_persistent</h4>
<p>Для каждого хранимого класса, среда создает еще два класса начинающихся с префикса CA_ (агент класса) и CB_ (базовый агент). Эти два класса относятся к части Persistence Service специфичной для конкретного хранимого класса. CA_ является наследником от CB_, который в свою очередь наследуется от класса <strong>CL_OS_CA_COMMON</strong>.</p>
<p>Класс, с префиксом CA_ является так называемым агентом (актором) класса CL_, данный класс реализует шаблон одиночки (т.е. в рамках рабочего процесса может существовать всего одна его инстанция) доступ к которому можно получить через статический атрибут agent:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/agentattribute.png"><img loading="lazy" class="alignnone size-full wp-image-1992" src="http://abap-blog.ru/wp-content/uploads/2014/05/agentattribute.png" alt="agentattribute" width="740" height="187" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/agentattribute.png 740w, https://abap-blog.ru/wp-content/uploads/2014/05/agentattribute-300x75.png 300w" sizes="(max-width: 740px) 100vw, 740px" /></a></p>
<p>Когда вы первый раз обращаетесь к этому атрибуту, в статическом конструкторе агента происходит его инициализация.</p>
<p>Агент класса используется для управления объектами хранимого класса: созданием, удалением, обновлением и т.п. Программист может переопределять некоторые отдельные методы класса агента, в частности используется для переопределения доступа к БД. Класс CB_ не предназначен для изменения. При генерации CL_ класса в качестве его «друга» определяется автоматом класс агент:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/friendship.png"><img loading="lazy" class="alignnone size-full wp-image-1993" src="http://abap-blog.ru/wp-content/uploads/2014/05/friendship.png" alt="friendship" width="389" height="145" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/friendship.png 389w, https://abap-blog.ru/wp-content/uploads/2014/05/friendship-300x111.png 300w" sizes="(max-width: 389px) 100vw, 389px" /></a></p>
<p>Класс агент реализует следующие интерфейсы: <strong>IF_OS_FACTORY</strong>, <strong>IF_OS_CA_SERVICE</strong>, <strong>IF_OS_CA_PERSISTENCY</strong> и <strong>IF_OS_CA_INSTANCE</strong>. Вы можете использовать как методы интерфейсов, так и методы класса.</p>
<p>&nbsp;</p>
<p><strong>Методы, унаследованные от класса CB_</strong></p>
<p><strong>CREATE_</strong><strong>PERSISTENT</strong>. Инициирует создания нового хранимого объекта. Интерфейс данного метода генерируется в зависимости от настроек сопоставления в хранимом классе. Если хранимый класс управляется бизнес ключом, в интерфейсе будут соответствующие поля. Для указанного выше примера ZCL_SFLIGHT:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/sflight_keys.png"><img loading="lazy" class="alignnone size-full wp-image-1994" src="http://abap-blog.ru/wp-content/uploads/2014/05/sflight_keys.png" alt="sflight_keys" width="551" height="195" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/sflight_keys.png 551w, https://abap-blog.ru/wp-content/uploads/2014/05/sflight_keys-300x106.png 300w" sizes="(max-width: 551px) 100vw, 551px" /></a></p>
<p>Если управление происходит через GUID, никаких дополнительных полей вы тут не увидите (т.к. GUID система генерирует самостоятельно). Когда Persistence Service инициализирует объект, система <strong>НЕ</strong> проверяет наличие объекта с теми же ключами в БД, ошибок происходить не будет до тех пор, пока вы не захотите сохранить объект, вызвав COMMIT WORK. Соответственно следует помнить, что перед созданием объекта, надо убедиться в том, что он отсутствует в БД, сделать это можно с помощью метода <strong>GET_PERSISTENT</strong>. Пример создания объекта:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_sflight TYPE REF TO zcl_sflight,
  go_sflight_agent TYPE REF TO zca_sflight.

go_sflight_agent = zca_sflight=&gt;agent.

TRY.
  " Пытаемся получить объект из БД
  go_sflight = go_sflight_agent-&gt;get_persistent(
      i_carrid = 'AA'
      i_connid = '0017'
      i_fldate = '20140501'
  ).

  CATCH cx_os_object_not_found.
    " Объект не найден, создаем новый
    TRY.
      go_sflight = go_sflight_agent-&gt;create_persistent(
          i_carrid = 'AA'
          i_connid = '0017'
          i_fldate = '20140501'
      ).
      CATCH cx_os_object_existing.
        EXIT.
    ENDTRY.

ENDTRY.

go_sflight-&gt;set_price( '100' ).</pre><p>Если в памяти PS уже есть объект с таким же ключом, система вызовет исключение &#8212; <strong>CX_OS_OBJECT_EXISTING</strong>.</p>
<p><strong>GET_</strong><strong>PERSISTENT</strong>. Загружает хранимый объект и создает экземпляр хранимого класса внутри программы. Интерфейс так же зависит от способа сопоставления в хранимом классе (может либо принимать на вход бизнес ключ, либо ничего, если используется GUID). Как уже было упомянуто выше, если объект ранее в программе уже был создан, Persistence Service вернет ссылку на него, при этом, не загружая его заново из базы данных.</p>
<p><strong>DELETE_</strong><strong>PERSISTENT</strong>. Удаляет хранимый объект, для удаления его данных из БД, необходимо вызвать COMMIT WORK. Интерфейс так же зависит от способа сопоставления в хранимом классе (может либо принимать на вход бизнес ключ, либо ничего, если используется GUID). Пример:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_sflight TYPE REF TO zcl_sflight,
  go_sflight_agent TYPE REF TO zca_sflight.

go_sflight_agent = zca_sflight=&gt;agent.

TRY.
  go_sflight_agent-&gt;delete_persistent(
    EXPORTING
      i_carrid = 'AA'
      i_connid = '0017'
      i_fldate = '20140501'
  ).
CATCH cx_os_object_not_found.
  EXIT.
ENDTRY.</pre><p><strong>CREATE_</strong><strong>TRANSIENT</strong>. Создает временный объект хранимого класса. Интерфейс аналогичен интерфейсу <strong>CREATE_ </strong><strong>PERSISTENT</strong>. Временные объекты не связаны с каким-либо источником данных и используются только внутри программы.  Не существует способа автоматического преобразования временного объекта в постоянный объект. Чтобы сделать подобное нужно сначала сохранить данные временного объекта в каком-либо буфере, затем удалить временный объект из памяти PS, после чего создать хранимый объект и загрузить в него данные из буфера.</p>
<p><strong>GET_TRANSIENT</strong>. Получает временный объект хранимого класса. Интерфейс аналогичен интерфейсу <strong>GET_ PERSISTENT</strong>. Объект должен быть создан с помощью метода <strong>CREATE_TRANSIENT</strong>.</p>
<p>&nbsp;</p>
<p><strong>Методы интерфейса IF_OS_FACTORY</strong></p>
<p><strong>IF_OS_FACTORY~CREATE_PERSISTENT</strong>. Создает хранимый объект. Используется для хранимых объектов, идентифицируемых через GUID, его генерация происходит в данном методе.</p>
<p><strong>IF_OS_FACTORY~CREATE_PERSISTENT_BY_KEY</strong>. Создает хранимый объект. Используется если объект хранимого класса идентифицируется через бизнес ключ. В качестве входящего параметра i_key должна передаваться либо структура (составной ключ), либо строка. Структура должна быть с полями в определённом порядке (по алфавиту), чтобы узнать, что от вас ожидает система, можно открыть класс CB_ и посмотреть определение типа TYP_BUSINESS_KEY:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/keys.png"><img loading="lazy" class="alignnone size-full wp-image-1995" src="http://abap-blog.ru/wp-content/uploads/2014/05/keys.png" alt="keys" width="460" height="244" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/keys.png 460w, https://abap-blog.ru/wp-content/uploads/2014/05/keys-300x159.png 300w" sizes="(max-width: 460px) 100vw, 460px" /></a></p>
<p><strong>IF_OS_FACTORY~REFRESH_PERSISTENT</strong>. Метод используется для обновления хранимого объекта (считывания данных происходит заново).  В качестве входного параметра I_OBJECT необходимо передать ссылку на хранимый объект. Данные будут считаны не сразу, а только в момент работы с каким-либо хранимым атрибутом. При обновлении хранимый объект может получить либо статус OSCON_OSTATUS_LOADED при успешной загрузке, либо OSCON_OSTATUS_NOT_LOADED. Сразу после вызова метода, до момента считывания, статус объекта меняется на OSCON_OSTATUS_NOT_LOADED. Вызывать данный метод можно только для объектов со статусами: OSCON_OSTATUS_NOT_LOADED, OSCON_OSTATUS_LOADED,  для объектов со статусами: CHANGED, NEW и DELETE вызовет исключение. Чтобы обновить измененные или удаленные объекты можно воспользоваться методом UNDO для транзакции (см. описание Transaction Service).    Приведу два дополнительных метода для обновления всех объектов относительно агента и для всех активных для текущей программы агентов:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/refresh_by_agent.png"><img loading="lazy" class="alignnone size-full wp-image-1996" src="http://abap-blog.ru/wp-content/uploads/2014/05/refresh_by_agent.png" alt="refresh_by_agent" width="523" height="44" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/refresh_by_agent.png 523w, https://abap-blog.ru/wp-content/uploads/2014/05/refresh_by_agent-300x25.png 300w" sizes="(max-width: 523px) 100vw, 523px" /></a></p><pre class="urvanov-syntax-highlighter-plain-tag">method REFRESH_OBJECTS_BY_AGENT.
  DATA:
    lt_objects TYPE ostyp_ref_tab,
    lo_state_object TYPE REF TO if_os_state,
    lo_object  TYPE REF TO object.

  lt_objects = im_agent-&gt;if_os_ca_instance~get_loaded( ).

  LOOP AT lt_objects INTO lo_object.
    TRY.
      lo_state_object ?= lo_object.
    CATCH cx_sy_move_cast_error.
      CONTINUE.
    ENDTRY.

    TRY.
      im_agent-&gt;if_os_factory~refresh_persistent( lo_state_object ).
    CATCH cx_os_object_not_refreshable.
      CONTINUE.
    ENDTRY.
  ENDLOOP.
endmethod.</pre><p>Обновление относительно всех активных агентов:</p><pre class="urvanov-syntax-highlighter-plain-tag">method REFRESH_ALL_OBJECTS.
  DATA:
    lo_agent        TYPE REF TO cl_os_ca_common,
    ls_agent_info   TYPE ostyp_ca_info.

  LOOP AT cl_os_system=&gt;active_class_agent INTO ls_agent_info.
    TRY.
      lo_agent ?= ls_agent_info-class_agent_ref.
    CATCH cx_sy_move_cast_error.
      CONTINUE.
    ENDTRY.

    zcl_po_utils=&gt;refresh_objects_by_agent( lo_agent ).
  ENDLOOP.

endmethod.</pre><p><strong>IF_OS_FACTORY~DELETE_PERSISTENT</strong>.Удаление хранимого объекта. В качестве входного параметра ожидает ссылку на хранимый объект.</p>
<p><strong>IF_OS_FACTORY~CREATE_TRANSIENT. </strong>Если хранимый объект не идентифицируется через бизнес ключ, для создания временного объекта хранимого класса (не связанного с источником данных) можно использовать данный метод.</p>
<p><strong>IF_OS_FACTORY~CREATE_TRANSIENT_BY_KEY. </strong>Создает временный объект хранимого класса. Используется, если хранимый объект идентифицируется через бизнес ключ. В качестве входящего параметра i_key должна передаваться либо структура (составной ключ), либо строка.</p>
<p><strong>IF_OS_FACTORY~RELEASE. </strong>Удаляет хранимый объект из памяти Persistent Service. Может использоваться для объектов со статусами: OSCON_OSTATUS_LOADED и OSCON_OSTATUS_NOT_LOADED. При повторной инициализации хранимого объекта, он будет загружен из БД заново.</p>
<p>&nbsp;</p>
<p><strong>Методы интерфейса IF_OS_CA_PERSISTENCY</strong></p>
<p><strong>IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_OID. </strong>Загружает хранимый объект и создает экземпляр хранимого класса внутри программы. Данный метод используется, когда хранимый объект не идентифицируется по бизнес ключу. Входной параметр ID объекта с типом OS_GUID:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_passkey TYPE REF TO zcl_passkey,
  go_passkey_agent TYPE REF TO zca_passkey,
  gv_guid TYPE os_guid VALUE '53730C660E6600D5E10080000A0000A9',
  gv_pass TYPE char10.

go_passkey_agent = zca_passkey=&gt;agent.
go_passkey ?= go_passkey_agent-&gt;if_os_ca_persistency~get_persistent_by_oid( gv_guid ).</pre><p><strong>IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY</strong><strong>. </strong>Загружает хранимый объект и создает экземпляр хранимого класса внутри программы. Данный метод используется, когда хранимый объект идентифицируется по бизнес ключу. В качестве входящего параметра i_key должна передаваться либо структура (составной ключ), либо строка.</p>
<p><strong>IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_OID_TAB. </strong>Аналогичен методу GET_PERSISTENT_BY_OID, за исключением того что в данном методе объекты можно загрузить массово. Использование метода возможно, только если в генераторе стоит галочка:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/mass_access.png"><img loading="lazy" class="alignnone size-full wp-image-1997" src="http://abap-blog.ru/wp-content/uploads/2014/05/mass_access.png" alt="mass_access" width="637" height="208" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/mass_access.png 637w, https://abap-blog.ru/wp-content/uploads/2014/05/mass_access-300x97.png 300w" sizes="(max-width: 637px) 100vw, 637px" /></a></p>
<p><strong>IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY_TAB. </strong>Аналогичен методу IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY, за исключением того что в данном методе объекты загружаются массово. Использовать можно так же только если стоит вышеуказанная галочка. Данный метод вызывает исключение, если в памяти есть объект с тем же ключом и статусом: OSCON_OSTATUS_TRANSIENT  и OSCON_OSTATUS_DELETED.Если какой-либо объект по указанным ключам не будет найден, исключение не будет вызвано (будет возвращена пустая ссылка). Пример массовой инициализации объектов:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_sflight TYPE REF TO zcl_sflight,
  go_sflight_agent TYPE REF TO zca_sflight,
  gt_flights_keys TYPE STANDARD TABLE OF scol_flight_key,
  gt_sflights TYPE osreftab.

go_sflight_agent = zca_sflight=&gt;agent.

" 1. Получаем ключевые поля для инициализации объектов
SELECT * FROM sflight INTO CORRESPONDING FIELDS OF TABLE gt_flights_keys.

" 2. Получаем таблицу с объектами
TRY.
  gt_sflights = go_sflight_agent-&gt;if_os_ca_persistency~get_persistent_by_key_tab( gt_flights_keys ).
  CATCH cx_os_object_not_found.
ENDTRY.</pre><p><strong>IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_QUERY. </strong>Данный метод используется для массового выбора объектов из базы данных по указанному в параметрах метода запросу. Запрос представлен в виде класса реализующего интерфейс <strong>IF_OS_QUERY</strong>. Данная методика относится к Query Service и будет рассматриваться далее. Объект запроса создается через метод CREATE_QUERY в классе, реализующем интерфейс <strong>IF_OS_QUERY_MANAGER</strong>.  Значения для сравнения в запросе передаются через таблицу I_PARAMETER_TAB, если для сравнения используется не более трех атрибутов, и они являются атрибутами элементарного типа, тогда можно использовать параметры I_PAR1-3. Вы можете использовать параметры I_SUBCLASSES и I_UPTO для того чтобы загружать подклассы и ограничить максимальное число возвращаемых объектов. Использовать можно, только если стоит галочка:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/query-methods.png"><img loading="lazy" class="alignnone size-full wp-image-1998" src="http://abap-blog.ru/wp-content/uploads/2014/05/query-methods.png" alt="query methods" width="637" height="208" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/query-methods.png 637w, https://abap-blog.ru/wp-content/uploads/2014/05/query-methods-300x97.png 300w" sizes="(max-width: 637px) 100vw, 637px" /></a></p>
<p>&nbsp;</p>
<p><strong>Методы интерфейса IF_OS_CA_INSTANCE</strong></p>
<p><strong>IF_OS_CA_INSTANCE~GET_STATUS. </strong>Получение статуса хранимого объекта относительно переданной ссылочной переменной.<br />
<strong>IF_OS_CA_INSTANCE~GET_NOT_LOADED. </strong>Получение всех объектов (относительно класса агента) которые имеют статус OSCON_OSTATUS_NOT_LOADED (0).<br />
<strong>IF_OS_CA_INSTANCE~GET_CREATED. </strong>Получение всех объектов (относительно класса агента) которые имеют статус OSCON_OSTATUS_NEW (1).<br />
<strong>IF_OS_CA_INSTANCE~GET_LOADED. </strong>Получение всех объектов (относительно класса агента) которые имеют статус OSCON_OSTATUS_LOADED (2).<br />
<strong>IF_OS_CA_INSTANCE~GET_CHANGED. </strong>Получение всех объектов (относительно класса агента) которые имеют статус OSCON_OSTATUS_CHANGED (3).<br />
<strong>IF_OS_CA_INSTANCE~GET_DELETED. </strong>Получение всех объектов (относительно класса агента) которые имеют статус OSCON_OSTATUS_DELETED (4).<br />
<strong>IF_OS_CA_INSTANCE~TRANSIENT. </strong>Получение всех объектов (относительно класса агента) которые имеют статус OSCON_OSTATUS_TRANSIENT (10).</p>
<p>&nbsp;</p>
<p><strong>Методы интерфейса IF_OS_CA_SERVICE</strong></p>
<p><strong>GET_</strong><strong>OID_</strong><strong>BY_</strong><strong>REF. </strong>Если для идентификации используется GUID, данный метод позволяет по ссылке на объект его получить.<br />
<strong>GET_REF_BY_OID. </strong>Если для идентификации используется GUID, данный метод позволяет получить по GUIDссылку на объект.</p>
<p>Одним из важнейших атрибутов агента класса является атрибут –<strong> OBJECT_INFO</strong>:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/object_info.png"><img loading="lazy" class="alignnone size-full wp-image-1999" src="http://abap-blog.ru/wp-content/uploads/2014/05/object_info.png" alt="object_info" width="550" height="97" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/object_info.png 550w, https://abap-blog.ru/wp-content/uploads/2014/05/object_info-300x52.png 300w" sizes="(max-width: 550px) 100vw, 550px" /></a></p>
<p>Внутри этой внутренней таблицы находится информация обо всех управляемых этим агентом объектах. Основные поля таблицы:</p>
<ul>
<li><strong>OBJECT_ID</strong>. Идентификатор объекта, используемый для каждого класса ABAP.</li>
<li><strong>OBJECT_IREF</strong>. Ссылка на объект ABAP</li>
<li><strong>PM_STATUS</strong>. Статус объекта</li>
<li><strong>PM_DBSTATUS</strong>. Статус хранимого объекта, относительно БД. OSCON_DBSTATUS_UNKNOWN (0) – нет информации о том, есть ли объект в БД. OSCON_DBSTATUS_EXISTING (1) – объект существует в БД. OSCON_DBSTATUS_NOT_EXISTING (2) – объект не существует в БД.</li>
</ul>
<p>&nbsp;</p>
<h3>Статусы хранимых объектов</h3>
<p>Статус хранимого объекта позволяет определить, например, был ли объект сохранен, изменен или удален, перенесены ли эти изменения в БД и т.п. Статус отвечает за то, какие в данный момент времени можно вызывать методы, а какие приведут к ошибкам. Существует семь различных статусов. Для получения информации о статусе хранимого объекта, можно использовать метод <strong>GET_</strong><strong>STATUS </strong>интерфейса  <strong>IF_OS_CA_INSTANCE</strong>, который реализован в агенте класса.</p>
<p>Имеющиеся статусы (группа типов OSCON):</p>
<table>
<tbody>
<tr>
<td><strong>Константа</strong></td>
<td><strong>Значение</strong></td>
<td><strong>Обозначение</strong></td>
</tr>
<tr>
<td><strong>OSCON_OSTATUS_NOT_LOADED</strong></td>
<td>0</td>
<td>Объект создан, но данные из БД не считаны. Может возникать в случае связанных объектов (один является вложенным атрибутом другого), пример рассматривается ниже.</td>
</tr>
<tr>
<td><strong>OSCON_OSTATUS_NEW</strong></td>
<td>1</td>
<td>Создан новый хранимый объект</td>
</tr>
<tr>
<td><strong>OSCON_OSTATUS_LOADED</strong></td>
<td>2</td>
<td>Хранимый объект успешно загружен</td>
</tr>
<tr>
<td><strong>OSCON_OSTATUS_CHANGED</strong></td>
<td>3</td>
<td>Хранимый объект изменен</td>
</tr>
<tr>
<td><strong>OSCON_OSTATUS_DELETED</strong></td>
<td>4</td>
<td>Хранимый объект удален</td>
</tr>
<tr>
<td><strong>OSCON_OSTATUS_TRANSIENT</strong></td>
<td>10</td>
<td>Объект хранимого класса является временным, т.е. не связан с БД.</td>
</tr>
<tr>
<td><strong>OSCON_OSTATUS_LOADING</strong></td>
<td>12</td>
<td>Объект загружается. Данный статус может быть у объекта только в методе INITинтерфейса IF_OS_STATE.</td>
</tr>
</tbody>
</table>
<p>Ниже представлена таблица методов и возможного вызова COMMIT WORK при различных статусах хранимых объектов, и к чему они приведут, т.е. вызову исключения (exc) или новому статусу:</p>
<table>
<tbody>
<tr>
<td><span style="color: #000080;"><strong>Статус до вызова</strong></span></td>
<td><strong>&#8212;</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>10</strong></td>
</tr>
<tr>
<td><strong>CREATE_PERSISTENT</strong></td>
<td>1</td>
<td>3</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>3</td>
<td>exc</td>
</tr>
<tr>
<td><strong>DELETE_PERSISTENT</strong></td>
<td>&#8212;</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>exc</td>
</tr>
<tr>
<td><strong>GET_PERSISTENT</strong></td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>exc</td>
<td>exc</td>
</tr>
<tr>
<td><strong>GET_attribute</strong></td>
<td>exc</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>3</td>
<td>exc</td>
<td>10</td>
</tr>
<tr>
<td><strong>SET_attribute</strong></td>
<td>exc</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>3</td>
<td>exc</td>
<td>10</td>
</tr>
<tr>
<td><strong>REFRESH_PERSISTENT</strong></td>
<td>exc</td>
<td>0</td>
<td>exc</td>
<td>0</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
</tr>
<tr>
<td><strong>RELEASE</strong></td>
<td>exc</td>
<td>&#8212;</td>
<td>exc</td>
<td>&#8212;</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
</tr>
<tr>
<td><strong>CREATE_TRANSIENT</strong></td>
<td>10</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
</tr>
<tr>
<td><strong>GET_TRANSIENT</strong></td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>exc</td>
<td>10</td>
</tr>
<tr>
<td><strong>COMMIT WORK</strong></td>
<td>&#8212;</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>&#8212;</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>Далее диаграмма изменения статуса хранимого объекта, который еще не был создан в БД, при работе с ним:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/no_in_db.gif"><img loading="lazy" class="alignnone size-full wp-image-2025" src="http://abap-blog.ru/wp-content/uploads/2014/05/no_in_db.gif" alt="no_in_db" width="626" height="516" /></a></p>
<p>Диаграмма изменения статуса хранимого объекта, который был загружен из БД, при работе с ним:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/in_db.gif"><img loading="lazy" class="alignnone size-full wp-image-2026" src="http://abap-blog.ru/wp-content/uploads/2014/05/in_db.gif" alt="in_db" width="633" height="466" /></a></p>
<p>Как будет рассмотрено ниже в примерах, Persistence Service при загрузке объекта, атрибут которого является ссылкой на другой хранимый объект, не загружает ссылочный объект сразу, а делает это только при его использовании. До момента использования такой объект имеет статус – NOT_LOADED.</p>
<p>При удалении хранимого объекта, он помечается в памяти как удаленный, в БД удаление происходит только при подтверждении транзакции.</p>
<p>После пометки объекта как удалённый, вы можете создать новый объект с тем же идентификатором, при этом его статус изменится на changed.</p>
<p>Возможна ситуация, когда при изменении временных атрибутов хранимых объектов статус объекта изменится на <strong>OSCON_OSTATUS_CHANGED</strong>.  Таким образом, Persistence Service будет сохранять объект в БД, даже если не изменялись хранимые атрибуты, по умолчанию данное поведение отключено (Начиная с ASABAP 7.0 EhP2):</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/no_transient_status.png"><img loading="lazy" class="alignnone size-full wp-image-2027" src="http://abap-blog.ru/wp-content/uploads/2014/05/no_transient_status.png" alt="no_transient_status" width="694" height="374" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/no_transient_status.png 694w, https://abap-blog.ru/wp-content/uploads/2014/05/no_transient_status-300x161.png 300w" sizes="(max-width: 694px) 100vw, 694px" /></a></p>
<p>Ранее подобное поведение нельзя было отключить, что могло приводить к значительным нагрузкам на БД при изменении большого числа объектов.</p>
<p>&nbsp;</p>
<h3>Ссылочные атрибуты</h3>
<p>Объекты зачастую внутри себя содержат ссылки на другие объекты, например: «Студент» &#8212; «Пропуск», «Покупатель» &#8212; «Продавец» и т.п.</p>
<p>Persistence Service позволяет в качестве атрибута хранимого класса использовать ссылку на объект другого хранимого класса. Но для того чтобы иметь возможность сохранить подобный класс в базе данных, необходимо чтобы соблюдались некоторые условия:</p>
<ul>
<li>Чтобы Persistence Service мог найти связанный (вложенный) класс, в таблице, где он хранится, должно существовать поле с типом OS_GUID (если другого ключа нет, должно быть ключевым).</li>
<li>В таблице, которая содержит данные вложенного объекта, должны быть два поля с типом OS_GUID, первое (ссылка на объект) поле будет идентификатором вложенного объекта, а второе (Ид. класса) идентификатором класса вложенного объекта (на одну и ту же таблицу может быть много классов).</li>
</ul>
<p>При связывании атрибута содержащего хранимый объект, необходимо связать два поля с типом OS_GUID с данным атрибутом (при связывании для обоих полей OS_GUID имя атрибута должно быть одинаковым).</p>
<p>Рассмотрим пример. Таблица студентов:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/students.png"><img loading="lazy" class="alignnone size-full wp-image-2009" src="http://abap-blog.ru/wp-content/uploads/2014/05/students.png" alt="students" width="644" height="267" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/students.png 644w, https://abap-blog.ru/wp-content/uploads/2014/05/students-300x124.png 300w" sizes="(max-width: 644px) 100vw, 644px" /></a></p>
<p>Поле PASS_INSTANCE будет хранить ссылку на идентификатор объекта. Поле PASS_CLASS будет идентификатором класса. Поле ID будет содержать ключ студента.</p>
<p>Таблица с кодами пропуска:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/pass.png"><img loading="lazy" class="alignnone size-full wp-image-2010" src="http://abap-blog.ru/wp-content/uploads/2014/05/pass.png" alt="pass" width="653" height="219" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/pass.png 653w, https://abap-blog.ru/wp-content/uploads/2014/05/pass-300x100.png 300w" sizes="(max-width: 653px) 100vw, 653px" /></a></p>
<p>Так как в нашем примере объект пропуск не может существовать без объекта студент, отдельного ключевого поля для идентификации пропуска нам не нужно. Считывать пропуска всегда будем через объект студента.</p>
<p>Создаем класс ZCL_PASSKEY и связываем с таблицей ZPASSKEY.</p>
<p>Далее создаем класс ZCL_STUDENT, связываем с таблицей ZSTUDENTS. Поле PASS_INSTANCE объявляем, как поле со ссылкой на объект:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/link_students.png"><img loading="lazy" class="alignnone size-full wp-image-2011" src="http://abap-blog.ru/wp-content/uploads/2014/05/link_students.png" alt="link_students" width="586" height="172" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/link_students.png 586w, https://abap-blog.ru/wp-content/uploads/2014/05/link_students-300x88.png 300w" sizes="(max-width: 586px) 100vw, 586px" /></a></p>
<p>Для поля PASS_CLASSставим тип Ид. Класса и присваиваем с тем же именем:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/class_students.png"><img loading="lazy" class="alignnone size-full wp-image-2012" src="http://abap-blog.ru/wp-content/uploads/2014/05/class_students.png" alt="class_students" width="558" height="145" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/class_students.png 558w, https://abap-blog.ru/wp-content/uploads/2014/05/class_students-300x77.png 300w" sizes="(max-width: 558px) 100vw, 558px" /></a></p>
<p>В итоге получаем следующую связь:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/class_links.png"><img loading="lazy" class="alignnone size-full wp-image-2013" src="http://abap-blog.ru/wp-content/uploads/2014/05/class_links.png" alt="class_links" width="648" height="130" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/class_links.png 648w, https://abap-blog.ru/wp-content/uploads/2014/05/class_links-300x60.png 300w" sizes="(max-width: 648px) 100vw, 648px" /></a></p>
<p>Сохраняем класс и активируем.</p>
<p>Создадим программу создающую объект пропуска и студента и связывающую их вместе (обратите внимание, что для краткости в примерах опущена обработка исключений. Все исключения в Object Services являются ООП исключениями, как их обрабатывать смотрите в <a href="http://abap-blog.ru/abap/abap-osnovi/obrabotka-osobyx-situacij-v-abap/">этой</a> статье.):</p><pre class="urvanov-syntax-highlighter-plain-tag">DELETE FROM ZSTUDENTS.
DELETE FROM ZPASSKEY.

COMMIT WORK.

DATA:
  go_student TYPE REF TO zcl_student,
  go_student_agent TYPE REF TO zca_student,
  go_passkey TYPE REF TO zcl_passkey,
  go_passket_agent TYPE REF TO zca_passkey.

go_student_agent = zca_student=&gt;agent.
go_passket_agent = zca_passkey=&gt;agent.

go_student ?= go_student_agent-&gt;create_persistent( i_id = '1' ).
go_passkey ?= go_passket_agent-&gt;create_persistent( ).

go_passkey-&gt;set_passkey( '$$FFFF123' ).
go_student-&gt;set_name( 'MIKE' ).
go_student-&gt;set_passkey( go_passkey ).

COMMIT WORK.</pre><p>Содержимое таблицы ZPASSKEY:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/pass_tab.png"><img loading="lazy" class="alignnone size-full wp-image-2014" src="http://abap-blog.ru/wp-content/uploads/2014/05/pass_tab.png" alt="pass_tab" width="370" height="101" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/pass_tab.png 370w, https://abap-blog.ru/wp-content/uploads/2014/05/pass_tab-300x81.png 300w" sizes="(max-width: 370px) 100vw, 370px" /></a></p>
<p>Содержимое таблицы ZSTUDENTS:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/stud_tab.png"><img loading="lazy" class="alignnone size-full wp-image-2015" src="http://abap-blog.ru/wp-content/uploads/2014/05/stud_tab.png" alt="stud_tab" width="682" height="116" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/stud_tab.png 682w, https://abap-blog.ru/wp-content/uploads/2014/05/stud_tab-300x51.png 300w" sizes="(max-width: 682px) 100vw, 682px" /></a></p>
<p>Считывание происходит следующим образом:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA:
  go_student TYPE REF TO zcl_student,
  go_student_agent TYPE REF TO zca_student,
  go_passkey TYPE REF TO zcl_passkey,
  gv_pass TYPE char10.

go_student_agent = zca_student=&gt;agent.
go_student ?= go_student_agent-&gt;get_persistent( i_id = 1 ).
go_passkey = go_student-&gt;get_passkey( ).

gv_pass = go_passkey-&gt;get_passkey( ).
WRITE gv_pass.</pre><p>При удалении хранимого объекта «студент» из БД, «пропуск» не будет автоматически удаляться, если это необходимо, то вызвать удаление придётся вручную.</p>
<p>Реализовать вложенные хранимые объекты можно и вручную, без необходимости использования специальных полей типа OS_GUID в таблицах, но это потребует дополнительной разработки, например при инициализации хранимого объекта ZCL_STUDENT нужно будет переопределить метод INIT, в котором во временный атрибут PASSKEY положить хранимый объект класса ZCL_PASSKEY.</p>
<p>В данном примере связь между хранимыми классами осуществляется через атрибут, к сожалению, нет стандартной возможности связать с одним хранимым классом группу хранимых классов, чтобы эта группа загружалась автоматически (Например, объект заказа и объекты позиции). Подобное поведение можно реализовать только вручную.</p>
<p>&nbsp;</p>
<h3>Наследование</h3>
<p>Наследование — механизм языка, позволяющий описать новый класс на основе уже существующего (родительского, базового) класса. Класс-потомок может добавить собственные методы и свойства, а также пользоваться родительскими методами и свойствами. Позволяет строить иерархии классов.</p>
<p>Persistent Service позволяет использовать механизм наследования для хранимых классов. При наследовании наследуется и то, каким образом родительский класс был связан с объектами в БД (наследование сопоставления). При этом в дочернем классе нельзя переопределить настройки сопоставления родительского класса.</p>
<p>Существует два способа при наследовании настроек сопоставления:</p>
<p><strong>Вертикальное наследование</strong>. На верхнем уровне иерархии находится не абстрактный класс. В наследуемых классах можно определить новые атрибуты из других таблиц, структур или ракурсов, но при этом ключевые поля должны совпадать с ключевыми полями, объявленными в родительском классе. Обычно схема выглядит следующим образом:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/vertical_inheritence1.png"><img loading="lazy" class="alignnone size-full wp-image-2034" src="http://abap-blog.ru/wp-content/uploads/2014/05/vertical_inheritence1.png" alt="vertical_inheritence" width="774" height="446" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/vertical_inheritence1.png 774w, https://abap-blog.ru/wp-content/uploads/2014/05/vertical_inheritence1-300x172.png 300w" sizes="(max-width: 774px) 100vw, 774px" /></a></p>
<p>Класс cl_e_ticket наследуется от класса cl_ticket. Оба хранимых класса связаны с разными таблицами, но ключевые поля в этих таблицах одинаковые.</p>
<p>Существует особый случай вертикального сопоставления, когда атрибуты, объявленные в дочернем классе, ссылаются на ту же таблицу, ракурс или структуру что и атрибуты в родительском классе. Для того чтобы установить к какому именно классу относится запись в таблице, структуре или ракурсе, необходимо чтобы в них было специальное поле с типом OS_GUID. При сопоставлении табличного поля, атрибут в классе будет иметь тип идентификатор типа:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/type_ident.png"><img loading="lazy" class="alignnone size-full wp-image-2017" src="http://abap-blog.ru/wp-content/uploads/2014/05/type_ident.png" alt="type_ident" width="268" height="149" /></a></p>
<p><strong>Горизонтальное наследование</strong>. Если родительский класс является абстрактным, вы можете объявлять хранимые атрибуты без необходимости их сопоставления.  Настройка сопоставления атрибутов необходима только в дочерних (не абстрактных) классах, при этом они могут быть связаны с совершенно разными таблицами.</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2014/05/hor_inh1.png"><img loading="lazy" class="alignnone size-full wp-image-2035" src="http://abap-blog.ru/wp-content/uploads/2014/05/hor_inh1.png" alt="hor_inh" width="775" height="444" srcset="https://abap-blog.ru/wp-content/uploads/2014/05/hor_inh1.png 775w, https://abap-blog.ru/wp-content/uploads/2014/05/hor_inh1-300x171.png 300w" sizes="(max-width: 775px) 100vw, 775px" /></a></p>
<p>Как видно из рисунка могут быть не только разные таблицы, но и разные ключевые поля для наследуемых объектов.</p>
<blockquote><p>Если при создании класса наследника, возникает проблема в том, что интерфейс IF_OS_STATE не может быть реализован дважды, просто перейдите на закладку интерфейсы и удалите лишнюю запись.</p></blockquote>
<p>В следующей части будут рассмотрены темы: Преобразование хранимых объектов в структуры (таблицы) и обратно,  менеджер инстанций и менеджер постоянства, пользовательские проверки в методах изменения/получения атрибутов, интеграция с системой блокировок SAP, переопределение методов доступа к данным, Transaction Service и Query Service.</p><p>The post <a href="https://abap-blog.ru/database-work/abap-object-services-persistence-service/">ABAP Object Services — Persistence Service — часть 1.</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/database-work/abap-object-services-persistence-service/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
	</channel>
</rss>
