<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>шаблоны проектирования | ABAP Blog</title>
	<atom:link href="https://abap-blog.ru/tag/shablony-proektirovaniya/feed/" rel="self" type="application/rss+xml" />
	<link>https://abap-blog.ru</link>
	<description>Все о разработке в решениях от SAP</description>
	<lastBuildDate>Tue, 02 Mar 2021 06:14:48 +0000</lastBuildDate>
	<language>ru-RU</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.1</generator>
	<item>
		<title>Паттерны проектирования в ABAP примерах</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 08 May 2016 06:00:36 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<category><![CDATA[паттерны проектирования]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2729</guid>

					<description><![CDATA[<p>Ранее в блоге уже упоминались паттерны проектирования (GoF), однако их рассмотрение было несколько скомканным и не полным, в данной статье они будут рассмотрены более подробно. Изучая паттерны, не стоит считать их неким священным Граалем, способным решить все задачи, они лишь инструмент, который нужно еще и грамотно применить. Главное, что нужно оценивать это то, какую проблему [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/">Паттерны проектирования в ABAP примерах</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Ранее в блоге уже упоминались паттерны проектирования (GoF), однако их рассмотрение было несколько скомканным и не полным, в данной статье они будут рассмотрены более подробно.</p>
<p><span id="more-2729"></span></p>
<p>Изучая паттерны, не стоит считать их неким священным Граалем, способным решить все задачи, они лишь инструмент, который нужно еще и грамотно применить. Главное, что нужно оценивать это то, какую проблему решает тот или иной паттерн и для чего он создан. Бездумное применение паттернов лишь внесёт дополнительную сложность в Ваше решение.</p>
<p>Большинство паттернов имеют свою каноническую реализацию, а есть и упрощённые/усложнённые варианты. В данной статье не будут рассматриваться все реализации, более подробную информацию Вы сможете найти в соответствующей литературе и курсах, ссылки на которые будут в конце статьи.</p>
<p>&nbsp;</p>
<h4>Порождающие паттерны (Creational patterns)</h4>
<p>&nbsp;</p>
<p>За конструирование объектов в ООП языках обычно отвечает конструктор и клиент, вызывающий конструктор нужного ему класса. Однако бывают случаи, когда заранее тип объекта не известен или использование конструктора напрямую является неудобным или невозможным. Порождающие паттерны помогают решить типовые проблемы создания объектов.</p>
<p>К порождающим паттернам относятся:</p>
<ul>
<li><a href="http://abap-blog.ru/oop/abstraktnaya-fabrika/">Абстрактная фабрика</a> (Abstract factory)</li>
<li><a href="http://abap-blog.ru/oop/fabrichnyj-metod/">Фабричный метод</a> (Factory method)</li>
<li><a href="http://abap-blog.ru/oop/stroitel/">Строитель</a> (Builder)</li>
<li><a href="http://abap-blog.ru/oop/prototip/">Прототип</a> (Prototype)</li>
<li><a href="http://abap-blog.ru/oop/odinochka/">Одиночка</a> (Singleton)</li>
</ul>
<h4>Поведенческие паттерны (Behavioral patterns)</h4>
<p>&nbsp;</p>
<p>Поведенческие шаблоны проектирования определяют общие закономерности связей между объектами, реализующими их. Следование этим шаблонам уменьшает связность системы и облегчает коммуникацию между объектами, что увеличивает гибкость программного продукта.</p>
<p>К поведенческим паттернам относятся:</p>
<ul>
<li><a href="http://abap-blog.ru/oop/strategiya/">Стратегия </a>(Strategy)</li>
<li><a href="http://abap-blog.ru/oop/shablonnyj-metod-template-method/">Шаблонный метод </a>(Template method)</li>
<li><a href="http://abap-blog.ru/oop/posrednik-mediator/">Посредник </a>(Mediator)</li>
<li><a href="http://abap-blog.ru/oop/komanda-command-2/">Команда </a>(Command)</li>
<li><a href="http://abap-blog.ru/oop/cepochka-otvetstvennosti-chain-of-responsibility/">Цепочка обязанностей </a>(Chain of Responsibility)</li>
<li><a href="http://abap-blog.ru/oop/interpretator-interpreter/">Интерпретатор </a>(Interpreter)</li>
<li><a href="http://abap-blog.ru/oop/iterator-iterator/">Итератор </a>(Iterator)</li>
<li><a href="http://abap-blog.ru/oop/xranitel-memento/">Хранитель </a>(Memento)</li>
<li><a href="http://abap-blog.ru/oop/nablyudatel-observer/">Наблюдатель </a>(Observer)</li>
<li><a href="http://abap-blog.ru/oop/sostoyanie-state/">Состояние </a>(State)</li>
<li><a href="http://abap-blog.ru/oop/posetitel-visitor/">Посетитель </a>(Visitor)</li>
<li>&#8230;</li>
</ul>
<p>&nbsp;</p>
<h4>Структурные паттерны (Structural patterns)</h4>
<p>&nbsp;</p>
<p>Структурные паттерны рассматривают вопросы о компоновке системы на основе классов и объектов. При этом могут использоваться следующие механизмы:</p>
<ul>
<li>Наследование, когда базовый класс определяет интерфейс, а подклассы &#8212; реализацию. Структуры на основе наследования получаются статичными.</li>
<li>Композиция, когда структуры строятся путем объединения объектов некоторых классов. Композиция позволяет получать структуры, которые можно изменять во время выполнения.</li>
</ul>
<p>К структурным паттернам относятся:</p>
<ul>
<li><a href="http://abap-blog.ru/oop/adapter-adapter/">Адаптер </a>(Adapter)</li>
<li><a href="http://abap-blog.ru/oop/most-bridge/">Мост </a>(Bridge)</li>
<li><a href="http://abap-blog.ru/oop/komponovshhik-composite/">Компоновщик </a>(Composite)</li>
<li><a href="http://abap-blog.ru/oop/dekorator-decorator-wrapper/">Декоратор </a>(Decorator)</li>
<li><a href="http://abap-blog.ru/oop/fasad-facade/">Фасад </a>(Facade)</li>
<li><a href="http://abap-blog.ru/oop/prisposoblenec/">Приспособленец </a>(Flyweight)</li>
<li><a href="http://abap-blog.ru/oop/zamestitel-proxy/">Заместитель </a>(Proxy)</li>
<li>&#8230;</li>
</ul>
<p>&nbsp;</p>
<h4>Источники</h4>
<p>&nbsp;</p>
<ol>
<li>Youtube канал <a href="https://www.youtube.com/channel/UCVbz7l0COUdLupcY4YtYH0w">Сергея Немчинского</a>.</li>
<li>Видео курс Александра Шевчука на  <a href="http://itvdn.com/ru/patterns">ITVDN</a>.</li>
<li><a href="http://www.ozon.ru/context/detail/id/31789305/">Паттерны проектирования на платформе .NET</a> от Сергея Теплякова. Пожалуй лучшая книга по теме.</li>
<li>Видео курс Design Patterns Library на <a href="https://www.pluralsight.com/courses/patterns-library">Pluralsight</a>.</li>
<li><a href="https://habrahabr.ru/post/136766/">Статья </a>о паттернах в ООП метафорах.</li>
<li><a href="http://www.ozon.ru/context/detail/id/2457392/">Приемы объектно-ориентированного проектирования. Паттерны проектирования</a>.</li>
<li>Э. Фриман. <a href="http://www.ozon.ru/context/detail/id/31079082/">Паттерны проектирования.</a></li>
<li>Wiki. <a href="https://ru.m.wikipedia.org/wiki/Шаблон_проектирования">Шаблоны проектирования</a>.</li>
</ol><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/">Паттерны проектирования в ABAP примерах</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Шаблон прототип</title>
		<link>https://abap-blog.ru/osnovy-abap/shablon-prototip/</link>
					<comments>https://abap-blog.ru/osnovy-abap/shablon-prototip/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Wed, 15 Feb 2012 17:38:10 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[шаблон прототип]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=506</guid>

					<description><![CDATA[<p>Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Проще говоря, это паттерн создания объекта через клонирование другого объекта вместо создания через конструктор. Используйте этот шаблон проектирования, когда система не должна зависеть от того, как в ней создаются, компонуются и представляются продукты: инстанцируемые классы определяются во время выполнения, например [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-prototip/">Шаблон прототип</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа.</p>
<p>Проще говоря, это паттерн создания объекта через клонирование другого объекта вместо создания через конструктор.</p>
<p><span id="more-506"></span></p>
<p>Используйте этот шаблон проектирования, когда система не должна зависеть от того, как в ней создаются, компонуются и представляются продукты:</p>
<ul>
<li>инстанцируемые классы определяются во время выполнения, например с помощью динамической загрузки;</li>
<li>для того чтобы избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;</li>
<li>экземпляры класса могут находиться в одном из нескольких различных состояний. Может оказаться удобнее установить соответствующее число прототипов и клонировать их, а не инстанцировать каждый раз класс вручную в подходящем состоянии.</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">PROGRAM zlr_prototype.

CLASS lcl_report_data DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS: clone ABSTRACT
      RETURNING VALUE(ro_object) TYPE REF TO lcl_report_data.
    METHODS: select_data ABSTRACT.
ENDCLASS.                    

CLASS lcl_detail_report_data DEFINITION INHERITING FROM lcl_report_data.
  PUBLIC SECTION.
    METHODS: clone REDEFINITION.
    METHODS: select_data REDEFINITION.
    DATA: t_data TYPE STANDARD TABLE OF t100.
ENDCLASS.                  

CLASS lcl_detail_report_data IMPLEMENTATION.
  METHOD select_data.
    SELECT * FROM t100
      INTO TABLE t_data
      UP TO 20 ROWS
      WHERE sprsl = sy-langu.
  ENDMETHOD.                    "select_Data
  METHOD clone.
    " Метод создает еще одну инстанцию объекта, 
    " копируя все внутренние переменные
    DATA: lo_object TYPE REF TO lcl_detail_report_data.
    CREATE OBJECT lo_object.
    lo_object-&gt;t_data = me-&gt;t_data.
    ro_object = lo_object.
  ENDMETHOD.                  
ENDCLASS.                   

CLASS lcl_main DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: run.
ENDCLASS.                   

CLASS lcl_main IMPLEMENTATION.
  METHOD run.
    DATA: lo_report TYPE REF TO lcl_report_data.
    CREATE OBJECT lo_report TYPE lcl_detail_report_data.
    lo_report-&gt;select_data( ).
    DATA: lo_rep_2 TYPE REF TO lcl_report_data.
    " Вместо инициации создания объекта и получения данных клонируем объект
    lo_rep_2 = lo_report-&gt;clone( ).
  ENDMETHOD.                 
ENDCLASS.                    

START-OF-SELECTION.
  lcl_main=&gt;run( ).</pre><p></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-prototip/">Шаблон прототип</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/shablon-prototip/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Шаблон прокси</title>
		<link>https://abap-blog.ru/osnovy-abap/shablon-proksi/</link>
					<comments>https://abap-blog.ru/osnovy-abap/shablon-proksi/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sat, 04 Feb 2012 06:35:37 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[abap objects]]></category>
		<category><![CDATA[шаблон прокси]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=393</guid>

					<description><![CDATA[<p>Шаблон Proxy (определяет объект-заместитель англ. surrogate иначе -заменитель англ. placeholder) — шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера). В реальной жизни можно привести следующий пример: сотрудникам одного из подразделений фирмы регулярно требуется получать информацию о том, какого числа бухгалтерия планирует выплатить зарплату. С одной стороны каждый из них может индивидуально и регулярно ездить в бухгалтерию [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-proksi/">Шаблон прокси</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><strong>Шаблон Proxy</strong> (определяет объект-заместитель англ. <em>surrogate</em> иначе -заменитель англ. <em>placeholder</em>) — шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).</p>
<p><span id="more-393"></span></p>
<p>В реальной жизни можно привести следующий пример: сотрудникам одного из подразделений фирмы регулярно требуется получать информацию о том, какого числа бухгалтерия планирует выплатить зарплату. С одной стороны каждый из них может индивидуально и регулярно ездить в бухгалтерию для выяснения этого вопроса (полагаю такая ситуация не редка во многих организациях). С другой стороны, при приближении планируемой даты подразделение может выбрать одного человека, который будет выяснять эту информацию у бухгалтерии, а в последствии уже все в подразделении могут выяснить эту информацию у него (что значительно быстрее). Вот именно этот человек и будет реализованным «прокси» паттерном, который будет предоставлять специальный механизм доступа к информации из бухгалтерии.</p>
<h3>Проблема</h3>
<p>Необходимо управлять доступом к объекту так, чтобы создавать громоздкие объекты «по требованию».</p>
<h3>Решение</h3>
<p>Создать суррогат громоздкого объекта. «Заместитель» хранит ссылку, которая позволяет заместителю обратиться к реальному субъекту (объект класса «Заместитель» может обращаться к объекту класса «Субъект», если интерфейсы «Реального Субъекта» и «Субъекта» одинаковы). Поскольку интерфейс «Реального Субъекта» идентичен интерфейсу «Субъекта», так, что «Заместителя» можно подставить вместо «Реального Субъекта», контролирует доступ к «Реальному Субъекту», может отвечать за создание или удаление «Реального Субъекта». «Субъект» определяет общий для «Реального Субъекта» и «Заместителя» интерфейс, так, что «Заместитель» может быть использован везде, где ожидается «Реальный Субъект». При необходимости запросы могут быть переадресованы «Заместителем» «Реальному Субъекту».</p>
<p><a title="Диаграмма классов шаблона проектирования Proxy" href="http://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Proxy_patt.gif"><img loading="lazy" src="http://upload.wikimedia.org/wikipedia/ru/0/08/Proxy_patt.gif" alt="Диаграмма классов шаблона проектирования Proxy" width="379" height="252" /></a></p>
<p>Шаблон proxy бывает нескольких видов, а именно:</p>
<ul>
<li><strong>Удаленный заместитель</strong> (англ. <em>remote proxies</em>) : обеспечивает связь с «Субъектом», который находится в другом адресном пространстве или на удалённой машине. Так же может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному «Субъекту»,</li>
<li><strong>Виртуальный заместитель</strong> (англ. <em>virtual proxies</em>): обеспечивает создание реального «Субъекта» только тогда, когда он действительно понадобится. Так же может кэшировать часть информации о реальном «Субъекте», чтобы отложить его создание,</li>
<li><strong>Копировать-при-записи</strong>: обеспечивает копирование «субъекта» при выполнении клиентом определённых действий (частный случай «виртуального прокси»).</li>
<li><strong>Защищающий заместитель</strong> (англ. <em>protection proxies</em>): может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права.</li>
<li><strong>Кэширующий прокси</strong>: обеспечивает временное хранение результатов расчёта до отдачи их множественным клиентам, которые могут разделить эти результаты.</li>
<li><strong>Экранирующий прокси</strong>: защищает «Субъект» от опасных клиентов (или наоборот).</li>
<li><strong>Синхронизирующий прокси</strong>: производит синхронизированный контроль доступа к «Субъекту» в асинхронной многопоточной среде.</li>
<li><strong>Smart reference proxy</strong>: производит дополнительные действия, когда на «Субъект» создается ссылка, например, рассчитывает количество активных ссылок на «Субъект».</li>
</ul>
<h2>Преимущества и недостатки от применения</h2>
<p>Преимущества:</p>
<ul>
<li> удаленный заместитель;</li>
<li> виртуальный заместитель может выполнять оптимизацию;</li>
<li> защищающий заместитель;</li>
<li>&#171;умная&#187; ссылка;</li>
</ul>
<dl>
<dt>Недостатки</dt>
</dl>
<ul>
<li>резкое увеличение времени отклика.</li>
</ul>
<h2>Сфера применения</h2>
<p>Шаблон Proxy может применяться в случаях работы с сетевым соединением, с огромным объектом в памяти (или на диске) или с любым другим ресурсом, который сложно или тяжело копировать. Хорошо известный пример применения — объект, подсчитывающий число ссылок.</p>
<p>Пример реализации на ABAP:</p><pre class="urvanov-syntax-highlighter-plain-tag">" Определяет общий для реального объекта и прокси объекта интерфейс
INTERFACE lif_math.
   METHODS:
      ADD IMPORTING X TYPE F
                    y TYPE F
          RETURNING VALUE(Z) TYPE F,
      sub IMPORTING X TYPE F
                    y TYPE F
          RETURNING VALUE(Z) TYPE F,
      mul IMPORTING X TYPE F
                    y TYPE F
          RETURNING VALUE(Z) TYPE F,
      DIV IMPORTING X TYPE F
                    y TYPE F
          RETURNING VALUE(Z) TYPE F.
ENDINTERFACE.

" Определение реального объекта
CLASS math DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_math.
    ALIASES:
      mul FOR lif_math~mul,
      sub FOR lif_math~sub,
      ADD FOR lif_math~ADD,
      DIV FOR lif_math~DIV.
ENDCLASS.

CLASS math IMPLEMENTATION.
  METHOD lif_math~ADD.
    Z = X + y.
  ENDMETHOD.
  METHOD lif_math~sub.
    Z = X - y.
  ENDMETHOD.
  METHOD lif_math~mul.
    Z = X * y.
  ENDMETHOD.
  METHOD lif_math~DIV.
    Z = X / y.
  ENDMETHOD.
ENDCLASS.

" Прокси (заместитель), хранит ссылку которая позволяет 
" обратиться к реальному субъекту, Так как оба класса 
" имеют один интерфейс, прокси может всегда быть использован 
" вместо реального субъекта.
CLASS proxy DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_math.
    METHODS:
      CONSTRUCTOR.
  PRIVATE SECTION.
    DATA: go_math TYPE REF TO math.
ENDCLASS.

CLASS proxy IMPLEMENTATION.
  METHOD CONSTRUCTOR.
    CREATE OBJECT go_math.
  ENDMETHOD.
  " Быстрые операции не требуют обращения к реальному субъекту
  METHOD lif_math~ADD.
    Z = X + y.
  ENDMETHOD.
  METHOD lif_math~sub.
    Z = X - y.
  ENDMETHOD.
  " Медленные операции требуют обращения к субъекту
  METHOD lif_math~mul.
    Z = go_math-&gt;mul( X = X y = y ).
  ENDMETHOD.
  METHOD lif_math~DIV.
    Z = go_math-&gt;div( X = X y = y ).
  ENDMETHOD.
ENDCLASS.</pre><p></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-proksi/">Шаблон прокси</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/shablon-proksi/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Паттерны ООП в метафорах</title>
		<link>https://abap-blog.ru/osnovy-abap/patterny-oop-v-metaforax/</link>
					<comments>https://abap-blog.ru/osnovy-abap/patterny-oop-v-metaforax/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 22 Jan 2012 13:33:07 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=311</guid>

					<description><![CDATA[<p>Большинство литературы посвященной паттернам в ООП (объектно-ориентированном программировании), как правило, объясняются на примерах с самим кодом. И это правильный подход, так как паттерны ООП уже по-умолчанию предназначаются для людей, которые знают что такое программирование и суть ООП. Однако порой требуется заинтересовать этой темой людей, которые в этом совершенно ничего не понимают, например «не-программистов» или же [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/patterny-oop-v-metaforax/">Паттерны ООП в метафорах</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Большинство литературы посвященной паттернам в ООП (объектно-ориентированном программировании), как правило, объясняются на примерах с самим кодом. И это правильный подход, так как паттерны ООП уже по-умолчанию предназначаются для людей, которые знают что такое программирование и суть ООП. Однако порой требуется заинтересовать этой темой людей, которые в этом совершенно ничего не понимают, например «не-программистов» или же просто начинающих «компьютерщиков». Именно с этой целью и был подготовлен данный материал, который призван объяснить человеку любого уровня знаний, что такое паттерн ООП и, возможно, привлечет в ряды программистов новых «адептов», ведь программирование это на самом деле очень интересно.<br />
Статья предназначена исключительно для новичков, так что «старожилы» ничего нового для себя не узнают. В основном статья описывает известные паттерны из книги «Приемы объектно-ориентированного программирования. Шаблоны проектирования.», но более популярным и простым языком.</p>
<p><span id="more-311"></span></p>
<h5>Что же такое вообще паттерн в ООП?</h5>
<p>Паттерн (от англ. Pattern) — образец, шаблон.<br />
Представьте, что вы хотите сделать новый автомобиль, но вы никогда этим не занимались. Сколько колес и почему вы спроектируете для него? Сейчас вы уже скорее всего скажете что 4, однако почему не 3, 5, 10, 20? Потому-что практикой использования уже было выяснено, что обычные автомобили лучше всего делать на 4-х колесах — это шаблон проектирования сформированный временем. Именно такому же подходу и служат паттерны в ООП и вы не столкнетесь с ними в разработке до тех пор, пока вам не потребуется «сделать автомобиль». Однако иногда случается так, что вы создаете «трицикл», и только потом, набив несколько шишек с его устойчивость и неудачным вписыванием в колею на дороге, узнаете что существует паттерн «автомобиль», который значительно упростил бы вам жизнь, знай вы про него ранее.</p>
<p><em>Примечание:</em><br />
Паттерны не привязаны к какому-либо конкретному языку программирования. Это просто подход к проектированию чего-либо. Если смотреть глубже, то многие паттерны ООП были созданы на основе реальных жизненный ситуаций в проектировании вполне себе осязаемых объектов нашего мира. Именно на таких метафорах и описаниях и будет построено дальнейшее изложение.</p>
<h4>Порождающие паттерны</h4>
<p>Паттерны которые создают новые объекты, или позволяют получить доступ к уже существующим. То есть те шаблоны, по которым можно создать новый автомобиль и как это лучше сделать.</p>
<h5>Singleton (одиночка)</h5>
<p>Один из самых известных и, пожалуй, самых спорных паттернов.<br />
Представьте, что в городе требуется организовать связь между жителями. С одной стороны мы можем связать всех жителей между собой протянув между ними кабели телефонных линий, но полагаю вы понимаете насколько такая система неверна. Например, как затратно будет добавить еще одного жителя в связи (протянуть по еще одной линии к каждому жителю). Чтобы этого избежать, мы создаем телефонную станцию, которая и будет нашим «одиночкой». Она одна, всегда, и если кому-то потребуется связаться с кем-то, то он может это сделать через данную телефонную станцию, потому что все обращаются только к ней. Соответственно для добавления нового жителя нужно будет изменить только записи на самой телефонной станции. Один раз создав телефонную станцию все могут пользоваться ей и только ей одной, в свою очередь эта станция помнит всё что с ней происходило с момента ее создания и каждый может воспользоваться этой информацией, даже если он только приехал в город.<br />
Основной смысл «одиночки» в том, чтобы когда вы говорите «Мне нужна телефонная станция», вам бы говорили «Она уже построена там-то», а не «Давай ее сделаем заново». «Одиночка» всегда один.</p>
<p><em>Примечание:</em><br />
Несмотря на удобство применения данного паттерна, он является одним из самых спорных при разработке и рекомендуется его применять только если нет никакого другого способа решения, потому как это создает значительные сложности при тестировании кода, однако это уже отдельная тема.</p>
<h5>Registry (реестр, журнал записей)</h5>
<p>Как следует из названия, данный паттерн предназначен для хранения записей которые в него помещают и соответственно возвращения этих записей (по имени) если они потребуются. В примере с телефонной станцией, она является реестром по отношению к телефонным номерам жителей.</p>
<p>Паттерны «одиночка» и «реестр» постоянно встречаются нам в повседневной жизни. Например бухгалтерия в фирме является «одиночкой», потому как она всегда одна и помнит что с ней происходило с момента ее начала работы. Фирма не создает каждый раз новую бухгалтерию когда ей требуется выдать зарплату. В свою очередь бухгалтерия является и «реестром», потому как в ней есть записи о каждом работнике фирмы.</p>
<p><em>Примечание:</em><br />
«Реестр» не редко является «одиночкой», однако это не всегда должно быть именно так. Например мы можем заводить в бухгалтерии несколько журналов, в одном работники от «А» до «М», в другом от «Н» до «Я». Каждый такой журнал будет «реестром», но не «одиночкой», потому как журналов уже 2. Хотя не редко «реестр» служит именно для хранения «одиночек».<br />
Сам паттерн «реестр» не являтся «порождающим паттерном» в полном смысле этого термина, однако его удобно рассматривать именно во взаимосвязи с ними.</p>
<h5>Multiton (пул «одиночек»)</h5>
<p>Как понятно из названия паттерна, это по своей сути «реестр» содержащий несколько «одиночек», каждый из которых имеет своё «имя» по которому к нему можно получить доступ.</p>
<h5>Object pool (пул объектов)</h5>
<p>По аналогии с «пулом одиночек» данный паттерн также позволяет хранить уже готовые объекты, однако они не обязаны быть «одиночками».</p>
<h5>Factory (фабрика)</h5>
<p>Суть паттерна практически полностью описывается его названием. Когда вам требуется получать какие-то объекты, например пакеты сока, вам совершенно не нужно знать как их делают на фабрике. Вы просто говорите «сделайте мне пакет апельсинового сока», а «фабрика» возвращает вам требуемый пакет. Как? Всё это решает сама фабрика, например «копирует» уже существующий эталон. Основное предназначение «фабрики» в том, чтобы можно было при необходимости изменять процесс «появления» пакета сока, а самому потребителю ничего об этом не нужно было сообщать, чтобы он запрашивал его как и прежде.<br />
Как правило, одна фабрика занимается «производством» только одного рода «продуктов». Не рекомендуется «фабрику соков» создавать с учетом производства автомобильных покрышек. Как и в жизни, паттерн «фабрика» часто создается «одиночкой».</p>
<h5>Builder (строитель)</h5>
<p>Данный паттерн очень тесно переплетается с паттерном «фабрики». Основное различие заключается в том, что «строитель» внутри себя, как правило, содержит все сложные операции по созданию объекта (пакета сока). Вы говорите «хочу сока», а строитель запускает уже целую цепочку различных операций (создание пакета, печать на нем изображений, заправка в него сока, учет того сколько пакетов было создано и т.п.). Если вам потребуется другой сок, например ананасовый, вы точно также говорите только то, что вам нужно, а «строитель» уже позаботится обо всем остальном (какие-то процессы повторит, какие-то сделает заново и т.п.). В свою очередь процессы в «строителе» можно легко менять (например изменить рисунок на упаковке), однако потребителю сока этого знать не требуется, он также будет легко получать требуемый ему пакет сока по тому же запросу.</p>
<p><em>Примечание:</em><br />
Чтобы лучше понять разницу между фабрикой и строителем, можно использовать следующую метафору.<br />
«Фабрика» — это автомат по продаже напитков, в нем уже есть всё готовое (или «осталось разогреть»), а вы только говорите что вам нужно (нажимаете кнопку). «Строитель» — это завод, который производит эти напитки и содержит в себе все сложные операции и может собирать сложные объекты из более простых (упаковка, этикетка, вода, ароматизаторы и т.п.) в зависимости от запроса.</p>
<h5>Prototype (прототип)</h5>
<p>Данный паттерн чем-то напоминает «фабрику», он также служит для создания объектов, однако с немного другим подходом. Представьте что у вас есть пустой пакет (из под сока), а вам нужен полный с апельсиновым соком. Вы «говорите» пакету «Хочу пакет апельсинового сока», он в свою очередь создает свою копию и заполняет ее соком, который вы попросили. Немного «сказочный пример», но в программировании часто так и бывает. В данном случае пустой пакет и является «прототипом», и в зависимости от того что вам требуется, он создает на своей основе требуемые вами объекты (пакеты сока).<br />
Клонирование не обязательно должно производится на самом «пакете», это может быть и какой-то другой «объект», главное лишь что данный «прототип» позволяет получать его экземпляры.</p>
<h5>Factory method (фабричный метод)</h5>
<p>Данный паттерн довольно сложно объяснить в метафорах, но всё же попробую.<br />
Ключевой сложностью объяснения данного паттерна является то, что это «метод», поэтому метафора метода будет использовано как действие, то есть например слово «Хочу!». Соответственно, паттерн описывает то, как должно выполнятся это «Хочу!».<br />
Допустим ваша фабрика производит пакеты с разными соками. Теоретически мы можем на каждый вид сока делать свою производственную линию, но это не эффективно. Удобнее сделать одну линию по производству пакетов-основ, а разделение ввести только на этапе заливки сока, который мы можем определять просто по названию сока. Однако откуда взять название?<br />
Для этого мы создаем основной отдел по производству пакетов-основ и предупреждаем все под-отделы, что они должны производить нужный пакет с соком про простому «Хочу!» (т.е. каждый под-отдел должен реализовать паттерн «фабричный метод»). Поэтому каждый под-отдел заведует только своим типом сока и реагирует на слово «Хочу!».<br />
Таким образом если нам потребуется пакет апельсинового сока, то мы просто скажем отделу по производству апельсинового сока «Хочу!», а он в свою очередь скажет основному отделу по созданию пакетов сока, «Сделай ка свой обычный пакет и вот сок, который туда нужно залить».</p>
<p><em>Примечание:</em><br />
Как вы могли уже заметить, «фабричный метод» является как бы основой для «фабрики», «строителя» и «прототипа». В разработке часто именно так и получается, сперва реализуют фабричный метод, а по мере усложнения кода выбирают во что именно его преобразовать, в какой из перечисленных паттернов. При использовании «фабричного метода» каждый объект как бы сам является «фабрикой».</p>
<h5>Lazy initialization (отложенная инициализация)</h5>
<p>Иногда требуется что-то иметь под рукой, на всякий случай, но не всегда хочется прилагать каждый раз усилия, чтобы это каждый раз получать/создавать. Для таких случаев используется паттерн «отложенная инициализация». Допустим вы работаете в бухгалтерии и для каждого сотрудника вы должны подготавливать «отчет о выплатах». Вы можете в начале каждого месяца делать этот отчет на всех сотрудников, но некоторые отчеты могут не понадобиться, и тогда скорее всего вы примените «отложенную инициализацию», то есть вы будете подготавливать этот отчет только тогда, когда он будет запрошен начальством (вышестоящим объектом), однако начальство по сути в каждый момент времени может сказать что у него этот отчет уже есть, однако готов он уже или нет, оно не знает и знать не должно. Как вы уже поняли, данный паттерн служит для оптимизации ресурсов.</p>
<h4>Структурирующие паттерны</h4>
<p>Данные паттерны помогают внести порядок и научить разные объекты более правильно взаимодействовать друг с другом.</p>
<h5>Adapter или wrapper (адаптер, обертка)</h5>
<p>Данный паттерн полностью соответствует своему названию. Чтобы заставить работать «советскую» вилку через евро-розетку требуется переходник. Именно это и делает «адаптер», служит промежуточным объектом между двумя другими, которые не могут работать напрямую друг с другом.</p>
<h5>Bridge (мост)</h5>
<p>Представим ситуацию, когда вам требуется работать на разных автомобилях, однако садясь в новый автомобиль вам уже желательно знать как им управлять. Таким образом вы сталкиваетесь с паттерном «мост». С одной стороны вы имеете множество различных автомобилей (разные модели и марки), но среди все них есть общая абстракция (интерфейс) ввиде руля, педалей, коробки передач и так далее. Таким образом мы задаем как-бы правила изготовления автомобилей по которым мы можем создавать любые их виды, но за счет сохранения общих правил взаимодействия с ними, мы можем одинаково управлять каждым из них. «Мостом» в данном случае является пара двух «объектов»: конкретного автомобиля и правил взаимодействия с этим (и любым другим) автомобилем.</p>
<h5>Composite (компоновщик)</h5>
<p>Довольно интересный паттерн суть которого заключается в минимизации различий в управлении как группами объектов так и индивидуальными объектами. Для примера можно рассмотреть управление солдатами в строю. Существует строевой устав, который определяет как управлять строем и согласно этого устава абсолютно не важно кому отдается приказ (например «шагом марш») одному солдату или целому взводу. Соответственно в устав (если его в чистом виде считать паттерном «компоновщик») нельзя включить команду, которую может исполнить только один солдат, но не может исполнить группа, или наоборот.</p>
<h5>Decorator (декоратор, оформитель)</h5>
<p>Как понятно из названия, данный паттерн чаще всего используется для расширения исходного объекта до требуемого вида. Например мы условно можем считать декоратором человека с кистью и красной краской. Таким образом, какой бы объект (или определенный тип объектов) мы не передали в руки декоратору, на выходе мы будем получать красные объекты.</p>
<h5>Facade (фасад)</h5>
<p>Паттерн «фасад» используется для того, чтобы делать сложные вещи простыми. Возьмем для примера автомобиль. Представьте, если бы управление автомобилем происходило немного по-другому: нажать одну кнопку чтобы подать питание с аккумулятора, другую чтобы подать питание на инжектор, третью чтобы включить генератор, четвертую чтобы зажечь ламочку на панели и так далее. Всё это было бы очень сложно. Для этого такие сложные наборы действий заменяются более простыми и комплексные как «повернуть ключ зажигания». В данном случае поворот ключа зажигания и будет тем самым «фасадом» для всего обилия внутренних действий автомобиля.</p>
<h5>Front controller (единая точка входа)</h5>
<p>Если проводить аналогии с реальными миром, то «единая точка входа» это то, через что вы сейчас читаете данную статью (например броузер). Она служит «единой точкой входа» для всего интернет пространства. То есть вы используете один интерфейс (броузер) для получения доступа к разным объектам большой системы (сайтам в интернете). Данный паттерн в целом сильно похож на «фасад».</p>
<h5>Flyweight (приспособленец)</h5>
<p>Самым лучшим примером (который я смог найти в реальной жизни) для метафорического сравнения паттерна «приспособленец» является театральная постановка. Представьте что нам требуется поставить пьесу. Однако по сценарию в этой пьесе задействованы несколько десятков людей, которые по своей сути выполняют одинаковые действия, например участвуют в массовках различных сцен в разные промежутки времени, но между ними всё же есть какие-то различия (например костюмы). Нам бы стоило огромных денег нанимать для каждой роли отдельного актера, поэтому мы используем паттерн «приспособленец». Мы создадим все нужные нам костюмы, но для каждой массовки будем переодевать небольшую группу актеров в требуемые для этой сцены костюмы. В результате мы имеем возможность ценой малых ресурсов создавать видимость управления большим количеством объектов.</p>
<h5>Proxy или surrogate (прокси, заместитель, суррогат)</h5>
<p>Данный паттерн позволяет создавать какие-либо специальные механизмы доступа к объекту, что чаще всего направлено именно на улучшение производительности отдельных частей программы. В реальной жизни можно привести следующий пример: сотрудникам одного из подразделений фирмы регулярно требуется получать информацию о том, какого числа бухгалтерия планирует выплатить зарплату. С одной стороны каждый из них может индивидуально и регулярно ездить в бухгалтерию для выяснения этого вопроса (полагаю такая ситуация не редка во многих организациях). С другой стороны, при приближении планируемой даты подразделение может выбрать одного человека, который будет выяснять эту информацию у бухгалтерии, а в последствии уже все в подразделении могут выяснить эту информацию у него (что значительно быстрее). Вот именно этот человек и будет реализованным «прокси» паттерном, который будет предоставлять специальный механизм доступа к информации из бухгалтерии.</p>
<h4>Паттерны поведения</h4>
<p>Эта группа паттернов позволяет структурировать подходы к обработке поведения и взаимодействия объектов. Проще говоря, как должны проходить процессы в которых существует несколько вариантов протекания событий.</p>
<h5>Chain of responsibility (цепочка обязанностей)</h5>
<p>Самым простым примером цепочки обязанностей можно считать получение какого-либо официального документа. Например вам требуются водительские права. Для этого нужно оплатить и пройти обучение, пойти с сертификатом в гос. орган, пройти регистрацию, сдать экзамен и т.д. Однако вы можете реализовать паттерн «цепочка обязанностей» и через него сказать «Хочу права, вот деньги и фото». Мы лишь говорим что нужно сделать, а все требуемые операции с нужными объектами уже выполняет сам паттерн (человек, которого вы подрядили на эту работу). Соответственно паттерн уже сам должен отвечать за всё, что он должен выполнить с кем при этом взаимодействовать, вас же будет интересовать только результат.</p>
<h5>Command или action (команда, действие)</h5>
<p>Паттерн «команда» очень похож в реальной жизни на кнопки выключателей света в наших квартирах и домах. Каждый выключатель по своей сути делает одно простое действие — разъединяет или соединяет два провода, однако что стоит за этими проводами выключателю не известно. Что подключат, то и произойдет. Точно также действует и паттерн «команда». Он лишь определяет общие правила для объектов (устройств), в виде соединения двух проводов для выполнения команды, а что именно будет выполнено уже определяет само устройство (объект).<br />
Таким образом мы можем включать одним выключателем как свет в комнате, так и пылесос.</p>
<h5>Interpreter (интерпретатор)</h5>
<p>Сравнить данный паттерн можно с тем, как вы закладываете часто используемые действия в сокращенный набор слов, чтобы сам «интерпретатор» потом превратил этот набор в более комплексные осмысленные действия. По сути каждый человек постоянно является «интерпретатором». Хотите провести жизненный эксперимент? Если из дома выходит кто-то из вашей семьи (муж, жена, ребенок), скажите ему простой набор слов «Литр молока, половинку белого, 200 грамм творога». По сути вы ничего особенного не сказали, лишь перечислили набор продуктов, однако велик шанс того, что «интерпретатор» транслирует это в команду «зайди по дороге в продуктовый магазин и купи следующее … и принеси это домой». Паттерн «интерпретатор» призван сократить часто исполняемые действия в более короткое их описание.</p>
<h5>Iterator (итератор, указатель)</h5>
<p>Все помнят школьное «на первый второй рассчитайся!»? Вот именно в этот момент шеренга вашего класса и являлась реализацией паттерна «итератор», хотя в программировании это конечно более функциональное понятие, но суть примерно та же. «Итератор» предоставляет правила доступа к списку каких-либо объектов независимо от того, что это за объекты. То есть не важно какой именно класс построен и из каких учеников, должны быть общие правила подсчета и обращения как каждому ученику по списку, вроде «13-ый, выйти из строя». Не редко паттерн «итератор» используется для доступа к «реестру». Ссылки, которые вы видите на многих сайтах для переходов по страницам, вроде «следующая», «предыдущая», «в начало» и т.п. по своей сути также являются доступом «итератору» который отвечает за страницы сайта.</p>
<h5>Mediator (посредник)</h5>
<p>Вспомним пример из паттерна «одиночка». Так вот телефонная станция в том примере по сути также являлась паттерном «посредник», то есть обеспечивала взаимодействие группы объектов без необходимости обеспечения связи каждого объекта друг с другом.<br />
Однако дополнительной ответственность этого «паттерна» является также управление этой группой через «посредника». То есть если мы возьмем пример с армейским строем, то медиатором будет командир отделения, то есть нам нет необходимости взаимодействовать с каждым солдатом в отдельности, достаточно отдавать приказания лишь командиру отделения, а он уже сам решит какие действия должны быть выполнены внутри его отделения.</p>
<h5>Memento (хранитель)</h5>
<p>Никогда не просили друга с сотовым телефоном на время запомнить (записать себе) тот номер, что диктуют вам по телефону, потому что вы не можете его запомнить сами (телефон занят)? В этот момент ваш друг реализовывал паттерн «хранитель». Он служит для тех случаев, когда какому-либо объекту требуется сохранить своё состояние (состояние знания номера) в другом объекте (вашем друге), и при необходимости его потом восстановить (спросить у друга номера и тем самым восстановить состояние когда вы его знали). Также уместен аналог с тем, как в играх работает сохранение. Файл «сейва» как раз и будет тем самым паттерном «хранитель».</p>
<h5>Observer или Listener (наблюдатель, слушатель)</h5>
<p>Очень распространенный паттерн в реальной жизни. Например если вы подписались на какую-либо email (или смс) рассылку, то ваш email (или номер сотового телефона) начинает реализовывать паттерн «наблюдатель». Как только вы подписываетесь на событие (например новая статья или сообщение), всем кто подписан на это событие (наблюдателям) будет выслано уведомление, а они уже в свою очередь могут выбрать как на это сообщение реагировать.</p>
<h5>Blackboard (доска объявлений)</h5>
<p>Данный паттерн служит для обеспечения взаимодействия между большим количеством объектов. Он является расширением паттерна «наблюдатель» и позволяет централизованно обслуживать как «наблюдателей», так и «создателей событий». В аналогии подпиской на email уведомления, это будет сам сайт подписки, который обслуживает множество подписчиков и тех, кто для них создает информацию (сообщения).</p>
<h5>Servant (слуга)</h5>
<p>Как следует из названия, данный паттерн служит для предоставления группе объектов какого-либо общего функционала. Например телефонная станция является для жителей города паттерном «слуга» если речь заходит о том, как узнать точное время (набрать номер 100).</p>
<h5>State (состояние)</h5>
<p>В реальной жизни каждый человек может прибывать в разных состояниях. Точно также порой требуется чтобы объекты в программе вели себя по разному в зависимости от каких-либо их внутренних состояний. По аналогии с реальной жизнью можно например привести следующий пример:<br />
Если вы устали то на фразу «Сходи в магазин» вы будете выдавать «Не пойду», если вам нужно сходить в магазин (за пивом?), то на «Сходи в магазин» вы будете выдавать «Уже бегу!». Человек (объект) один и тот же, а поведение разное. Именно для этих целей и используют паттерн «состояние».</p>
<h5>Strategy (стратегия)</h5>
<p>Используется для выбора различных путей получения результата. Вспомним пример с получением прав. Человек, который будет реализовывать паттерн «стратегия» будет действовать следующим образом: вы говорите ему «Хочу права, денег мало» в ответ вы получите права через длительное время и с большой тратой ресурсов. Если вы скажите ему «Хочу права, денег много», то вы получите права очень быстро. Что именно делал этот человек вы понятия не имеете, но вы задаете начальные условия, а как себя вести уже решает он сам (сам выбирает стратегию).<br />
Соответственно внутри «стратегии» хранятся различные способы поведения, и чтобы выбрать, ему нужны определенные параметры, в данном случае это объем денежных средств. Как устроена сама «стратегия» и какие алгоритмы внутри нее вам собственно знать и требуется.</p>
<h5>Specification (спецификация, определение)</h5>
<p>Паттерн спецификации позволяет описывать подходит ли данный объект нам на основе каких-либо критериев. Например мы имеем несколько контейнеров для погрузки на судно. Однако чтобы определить грузить контейнер или нет на определенное судно, нам нужно выбрать метод как это определять. Реализация такого метода и является паттерном «спецификация». В самом простом случае для каждого контейнера мы можем определить в паттерне «спецификация» совпадает ли страна назначения корабля со страной назначения контейнера. Соответственно мы один раз вводим правило «сравнить две страны назначения» и применяем его ко всем контейнерам для проверки.</p>
<h5>Subsumption (категоризация)</h5>
<p>Данный паттерн является прямым последователем паттерна «спецификация». Он позволяет распределять объекты по категориям на основе каких-либо условий. Соответственно по аналогии с примером кораблей и контейнеров, это категоризация по тому, какие контейнеры в какие страны направляются.</p>
<h5>Visitor (посетитель)</h5>
<p>Данный паттерн можно сравнить с прохождением обследования в больнице. Однако «посетителем» в терминах паттернов здесь будут сами врачи. Чтобы было понятнее: у нас есть больной которого требуется обследовать и полечить, но так как за разные обследования отвечают разные врачи, то мы просто присылаем к больному врачей в качестве «посетителей». Правило взаимодействия для больного очень простое «пригласите врача (посетителя) чтобы он сделал свою работу», а врач («посетитель») приходит, обследует и делает всё необходимое. Таким образом следуя простым правилам можно использовать врачей для разных больных по одним и тем же алгоритмам. Как уже было сказано, паттерном «посетитель» в данном случае является врач, который может одинаково обслуживать разные объекты (больных) если его позовут.</p>
<h5>Single-serving visitor (одноразовый посетитель)</h5>
<p>Является частным случаем использования паттерна «посетитель». Если в случае с обычным «посетителем» у нас есть врач которого мы можем отправить к разным больным (и при желании по несколько раз), то в данном паттерне можно привести аналогию, что мы нанимаем врача, отправляем его к одному больному и после обследования сразу увольняем.</p>
<h5>Hierarchical visitor (иерархический посетитель)</h5>
<p>Тот же самый паттерн «посетитель», однако в данном случае он отправляется к не одному больному, а в целую больницу и обходит там всех больных.</p>
<h4>Заключение</h4>
<p>Вот собственно и все основные паттерны которые я хотел описать в данной статье. Как вы видите, все они имеют очень много общего с реальной жизнью и позволяют делать код насколько же простым для чтения и понимания, как и то, что мы видим в реальной жизни. Программирование — это не «инопланетный язык» (а сами программисты вполне себе земные существа), это просто другая форма взаимодействия и описания мира существующего.<br />
О том же как непосредственно применять данные паттерны на практике написано большое количество статей и книг в интернете, их очень легко найти. Однако надеюсь сведения, приведенные в данной статье позволят вам быстро сориентироваться, если вдруг «на горизонте кода» появится знакомый паттерн.</p>
<p>Надеюсь вы нашли данный материал полезным для себя и благодарю за внимание.</p>
<p><a href="http://habrahabr.ru/blogs/programming/136766">Оригинал статьи</a>. Одна из лучших <a href="http://rutracker.org/forum/viewtopic.php?t=3694471">книг</a> по теме. Замечательная <a href="http://www.cours.polymtl.ca/inf3700/divers/nonSoftwareExample/patexamples.html">статья</a> с картинками.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/patterny-oop-v-metaforax/">Паттерны ООП в метафорах</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/patterny-oop-v-metaforax/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Шаблон компоновщик</title>
		<link>https://abap-blog.ru/osnovy-abap/shablon-komponovshhik/</link>
					<comments>https://abap-blog.ru/osnovy-abap/shablon-komponovshhik/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sat, 21 Jan 2012 20:00:14 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[abap objects]]></category>
		<category><![CDATA[Composite pattern]]></category>
		<category><![CDATA[Компоновщик]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=249</guid>

					<description><![CDATA[<p>Компоновщик (англ. Composite pattern) — шаблон проектирования, относится к структурным паттернам, объединяет объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Цель Шаблон определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-komponovshhik/">Шаблон компоновщик</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><strong>Компоновщик</strong> (англ. <em>Composite pattern</em>) — шаблон проектирования, относится к структурным паттернам, объединяет объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково.</p>
<p><span id="more-249"></span></p>
<h2>Цель</h2>
<p>Шаблон определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.</p>
<p>Простейшая реализация компоновщика далее в примере:</p><pre class="urvanov-syntax-highlighter-plain-tag">REPORT z_composite.

" Абстрактный класс
CLASS lcl_text DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS: ADD ABSTRACT IMPORTING io_text TYPE REF TO lcl_text,
             remove ABSTRACT IMPORTING io_text TYPE REF TO lcl_text,
             display ABSTRACT.
ENDCLASS.

" Символ не может содержать внутри себя другие символы
CLASS lcl_symbol DEFINITION INHERITING FROM lcl_text.
  PUBLIC SECTION.
    METHODS: CONSTRUCTOR IMPORTING iv_symbol TYPE char1.
    METHODS: ADD REDEFINITION,
             remove REDEFINITION,
             display REDEFINITION.
  PRIVATE SECTION.
    DATA: gv_symbol TYPE char1.
ENDCLASS.
*
CLASS lcl_symbol IMPLEMENTATION.
  METHOD CONSTRUCTOR.
    super-&gt;constructor( ).
    gv_symbol = iv_symbol.
  ENDMETHOD.                    "constructor
  METHOD ADD. " Класс не является компоновщиком, реализация методов отсутствует.
  ENDMETHOD.
  METHOD remove.
  ENDMETHOD.
  METHOD display.
    WRITE gv_symbol.
  ENDMETHOD.                    "display
ENDCLASS.                    "lcl_symbol IMPLEMENTATION

" Класс компоновщик включает в себя символы, определяет метод для их вывода
CLASS lcl_word DEFINITION INHERITING FROM lcl_text.
  PUBLIC SECTION.
    METHODS: ADD REDEFINITION,
             remove REDEFINITION,
             display REDEFINITION.
  PRIVATE SECTION.
    DATA: lt_messages TYPE STANDARD TABLE OF REF TO lcl_text.
ENDCLASS.                    "lcl_text DEFINITION
*
CLASS lcl_word IMPLEMENTATION.
  METHOD ADD.
    APPEND io_text TO lt_messages.
  ENDMETHOD.                    "ADD
  METHOD remove.
    DELETE lt_messages WHERE TABLE_LINE EQ io_text.
  ENDMETHOD.                    "remove
  METHOD display.
    DATA: lo_message TYPE REF TO lcl_text.
    WRITE: / ' '.
    LOOP AT lt_messages INTO lo_message.
      lo_message-&gt;display( ).
    ENDLOOP.
ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA:
    lo_word   TYPE REF TO lcl_text,
    lo_symbol TYPE REF TO lcl_text.

  CREATE OBJECT lo_word TYPE lcl_word.
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'H'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'E'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'L'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'L'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'O'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = ' '.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'W'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'O'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'R'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'L'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = 'D'.
  lo_word-&gt;add( lo_symbol ).
  CREATE OBJECT lo_symbol TYPE lcl_symbol EXPORTING iv_symbol = '!'.
  lo_word-&gt;add( lo_symbol ).

  lo_word-&gt;display( ).</pre><p></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-komponovshhik/">Шаблон компоновщик</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/shablon-komponovshhik/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Шаблон адаптер</title>
		<link>https://abap-blog.ru/osnovy-abap/adapter/</link>
					<comments>https://abap-blog.ru/osnovy-abap/adapter/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Wed, 18 Jan 2012 11:53:37 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[adapter]]></category>
		<category><![CDATA[шаблон адаптер]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=247</guid>

					<description><![CDATA[<p>Адаптер, Adapter или Wrapper/Обёртка — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс. Задача Система поддерживает требуемые данные и поведение, но имеет неподходящий интерфейс. Чаще всего шаблон Адаптер применяется, если необходимо создать класс, производный от вновь определяемого или уже существующего абстрактного класса. Способ решения Адаптер предусматривает создание класса-оболочки с требуемым интерфейсом. Следствия Шаблон Адаптер позволяет [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/adapter/">Шаблон адаптер</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><strong>Адаптер</strong>, <strong>Adapter</strong> или Wrapper/Обёртка — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.</p>
<p><span id="more-247"></span></p>
<h3>Задача</h3>
<p>Система поддерживает требуемые данные и поведение, но имеет неподходящий интерфейс. Чаще всего шаблон Адаптер применяется, если необходимо создать класс, производный от вновь определяемого или уже существующего абстрактного класса.</p>
<h3>Способ решения</h3>
<p>Адаптер предусматривает создание класса-оболочки с требуемым интерфейсом.</p>
<h3>Следствия</h3>
<p>Шаблон Адаптер позволяет включать уже существующие объекты в новые объектные структуры, независимо от различий в их интерфейсах.</p>
<h3>Реализация</h3>
<p>Включение уже существующего класса в другой класс. Интерфейс включающего класса приводится в соответствие с новыми требованиями, а вызовы его методов преобразуются в вызовы методов включённого класса.</p>
<p>Пример реализации на языке ABAP:</p><pre class="urvanov-syntax-highlighter-plain-tag">REPORT ZNP_DP_ADAPTER.

* Интерфейс который необходимо поддерживать в конечном классе
INTERFACE lif_output.
  METHODS: generate_output.
ENDINTERFACE.                    

* Класс элементарного вывода через WRITE поддерживающий нужный интерфейс
CLASS simple_op DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_output.
ENDCLASS.                

CLASS simple_op IMPLEMENTATION.
  METHOD lif_output~generate_output.
    WRITE: / 'Простой вывод с помощью write'.
  ENDMETHOD.
ENDCLASS.                   

* Класс вывода через создание дерева, не поддерживает нужный интерфейс
CLASS tree_output DEFINITION.
  PUBLIC SECTION.
    METHODS: generate_tree.
ENDCLASS.
*
CLASS tree_output IMPLEMENTATION.
  METHOD generate_tree.
    WRITE: / 'Генерация дерева.'.
  ENDMETHOD.
ENDCLASS.          

* Сам класс - адаптер, реализующий нужный интерфейс и являющийся 
* оболочкой над классом выводящим дерево..
CLASS new_complex_op DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_output.
ENDCLASS.               

CLASS new_complex_op IMPLEMENTATION.
  METHOD lif_output~generate_output.
    DATA: o_tree_op TYPE REF TO tree_output.
    CREATE OBJECT o_tree_op.
    o_tree_op-&gt;generate_tree( ).
  ENDMETHOD.
ENDCLASS.                    

START-OF-SELECTION.
* Ссылочная переменная на подходящий интерфейс
  DATA: o_op TYPE REF TO lif_output.
* Создаем объект с типом поддерживающим интерфейс
  CREATE OBJECT o_op TYPE simple_op.
  o_op-&gt;generate_output( ).
* Создаем объект с типом поддерживающим интерфейс и являющимся адаптером
* к классу выводящего вывод в виде дерева.
  CREATE OBJECT o_op TYPE new_complex_op.
  o_op-&gt;generate_output( ).</pre><p>Оригинальный пример находится <a href="http://help-abap.zevolving.com/2012/01/abap-objects-design-patterns-%E2%80%93-adapter/">тут</a>.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/adapter/">Шаблон адаптер</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/adapter/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Шаблон одиночка</title>
		<link>https://abap-blog.ru/osnovy-abap/shablon-odinochka/</link>
					<comments>https://abap-blog.ru/osnovy-abap/shablon-odinochka/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Mon, 16 Jan 2012 10:15:01 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[abap objects]]></category>
		<category><![CDATA[singleton]]></category>
		<category><![CDATA[шаблон одиночка]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=240</guid>

					<description><![CDATA[<p>Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. Существенно то, что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной более широкая функциональность. Например, к описанным компонентам класса можно обращаться через интерфейс, если такая возможность поддерживается языком. Плюсы контролируемый доступ к единственному экземпляру; уменьшение числа имён; допускает уточнение [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-odinochka/">Шаблон одиночка</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. Существенно то, что можно пользоваться именно <em>экземпляром </em>класса, так как при этом во многих случаях становится доступной более широкая функциональность. Например, к описанным компонентам класса можно обращаться через интерфейс, если такая возможность поддерживается языком.</p>
<p><span id="more-240"></span></p>
<h2>Плюсы</h2>
<ul>
<li>контролируемый доступ к единственному экземпляру;</li>
<li>уменьшение числа имён;</li>
<li>допускает уточнение операций и представления;</li>
<li>допускает переменное число экземпляров;</li>
<li>бо?льшая гибкость, чем у операций класса.</li>
</ul>
<h2>Минусы</h2>
<ul>
<li>Глобальные объекты могут быть вредны для объектного программирования, в некоторых случаях приводя к созданию немасштабируемого проекта.</li>
<li>Усложняет написание модульных тестов и следованию TDD</li>
</ul>
<h2>Применение</h2>
<ul>
<li>должен быть ровно один экземпляр некоторого класса, легко доступный всем клиентам;</li>
<li>единственный экземпляр должен расширяться путем порождения подклассов, и клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода.</li>
</ul>
<p>Пример реализации на ABAP:</p><pre class="urvanov-syntax-highlighter-plain-tag">REPORT  ztest_singleton_pattern.
*
*----------------------------------------------------------------------*
* CLASS lcl_application DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_application DEFINITION CREATE PRIVATE.*
  PUBLIC SECTION.
* Cтатический метод возвращающий ссылку на объект одиночку
    CLASS-METHODS:
      get_apps_instance
        RETURNING
          VALUE(ro_apps) TYPE REF TO lcl_application.*
    METHODS:
      set_v_name
        IMPORTING
          iv_name TYPE char30,
      get_v_name
        RETURNING
          VALUE(rv_name) TYPE char30.*
  PRIVATE SECTION.
* Статическая переменная будет хранить экземпляр класса одиночки
    CLASS-DATA: lo_apps TYPE REF TO lcl_application.
    DATA: v_name TYPE char30.
ENDCLASS.                    "lcl_application DEFINITION
*
*
*----------------------------------------------------------------------*
* CLASS lcl_application IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_application IMPLEMENTATION.
*
* Метод возвращает экземпляр объекта одиночки
  METHOD get_apps_instance.
    IF lo_apps IS INITIAL.
* Создание объекта
      CREATE OBJECT lo_apps.
    ENDIF.
    ro_apps = lo_apps.
  ENDMETHOD.                    "get_apps_instance
*
  METHOD set_v_name.
    me-&gt;v_name = iv_name.
  ENDMETHOD.                    "set_v_name
*
  METHOD get_v_name.
    rv_name = me-&gt;v_name.
  ENDMETHOD.                    "get_v_name
*
ENDCLASS.                    "lcl_application IMPLEMENTATION
*
*
START-OF-SELECTION.
*
*.Создаем 1-й экземпляр объекта
  DATA: lo_application TYPE REF TO lcl_application.
  DATA: lv_result TYPE char30.
*
  WRITE: / 'Приложение 1: '.
* CREATE OBJECT запрещен т.к. создание объекта объявлено как CREATE PRIVATE
  lo_application = lcl_application=&gt;get_apps_instance( ).
* Установим имя объекту 
  lo_application-&gt;set_v_name( 'This is first Object' ).
  lv_result = lo_application-&gt;get_v_name( ).
  WRITE: / lv_result.
  CLEAR lv_result.
*
*.Создадим вторую ссылку на объект
  DATA: lo_2nd_apps TYPE REF TO lcl_application.
  SKIP 2.
  WRITE: / 'Второе приложение : '.
* Вызывая метод получаем ранее созданный объект
  lo_2nd_apps = lcl_application=&gt;get_apps_instance( ).
  lv_result = lo_2nd_apps-&gt;get_v_name( ).
  WRITE: / lv_result.
  CLEAR lv_result.</pre><p>Оригинальный пример был взят <a href="http://help-abap.zevolving.com/2008/09/abap-object-design-patterns-singleton/">отсюда.</a></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-odinochka/">Шаблон одиночка</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/shablon-odinochka/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Шаблон фасад</title>
		<link>https://abap-blog.ru/osnovy-abap/shablon-fasad/</link>
					<comments>https://abap-blog.ru/osnovy-abap/shablon-fasad/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Mon, 16 Jan 2012 10:05:07 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[abap objects]]></category>
		<category><![CDATA[Facade]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=237</guid>

					<description><![CDATA[<p>Шаблон Facade (Фасад) — Шаблон проектирования, позволяющий скрыть сложность системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы. Проблема Как обеспечить унифицированный интерфейс с набором разрозненных реализаций или интерфейсов, например, с подсистемой, если нежелательно высокое связывание с этой подсистемой или реализация подсистемы может измениться? Решение Определить одну точку взаимодействия с подсистемой — фасадный [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-fasad/">Шаблон фасад</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><strong>Шаблон Facade (Фасад)</strong> — Шаблон проектирования, позволяющий скрыть сложность системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.</p>
<p><span id="more-237"></span></p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2012/01/Facade1.gif"><img loading="lazy" class="alignnone size-full wp-image-238" title="Facade[1]" src="http://abap-blog.ru/wp-content/uploads/2012/01/Facade1.gif" alt="" width="380" height="272" srcset="https://abap-blog.ru/wp-content/uploads/2012/01/Facade1.gif 380w, https://abap-blog.ru/wp-content/uploads/2012/01/Facade1-300x214.gif 300w" sizes="(max-width: 380px) 100vw, 380px" /></a></p>
<h3>Проблема</h3>
<p>Как обеспечить унифицированный интерфейс с набором разрозненных реализаций или интерфейсов, например, с подсистемой, если нежелательно высокое связывание с этой подсистемой или реализация подсистемы может измениться?</p>
<h3>Решение</h3>
<p>Определить одну точку взаимодействия с подсистемой — фасадный объект, обеспечивающий общий интерфейс с подсистемой и возложить на него обязанность по взаимодействию с её компонентами. Фасад — это внешний объект, обеспечивающий единственную точку входа для служб подсистемы. Реализация других компонентов подсистемы закрыта и не видна внешним компонентам. Фасадный объект обеспечивает реализацию паттерна <a title="Устойчивый к изменениям (страница отсутствует)" href="http://ru.wikipedia.org/w/index.php?title=%D0%A3%D1%81%D1%82%D0%BE%D0%B9%D1%87%D0%B8%D0%B2%D1%8B%D0%B9_%D0%BA_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC&amp;action=edit&amp;redlink=1">Устойчивый к изменениям</a> (Protected Variations) с точки зрения защиты от изменений в реализации подсистемы.</p><pre class="urvanov-syntax-highlighter-plain-tag">REPORT  z_np_dp_facade.
*
CLASS lcl_data DEFINITION.
  PUBLIC SECTION.
    METHODS: CONSTRUCTOR.
ENDCLASS.                    "lcl_Data DEFINITION
*
INTERFACE lif_write.
  METHODS: write_data.
ENDINTERFACE.                    "lif_write DEFINITION
*
CLASS lcl_write_alv DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_write.
ENDCLASS.                    "lcl_write_alv DEFINITION
*
CLASS lcl_write_log DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_write.
ENDCLASS.                    "lcl_write_log DEFINITION
*
CLASS lcl_facade DEFINITION.
  PUBLIC SECTION.
    METHODS: process_report IMPORTING iv_write_type TYPE char1.
ENDCLASS.                    "lcl_facade DEFINITION
*
CLASS lcl_data IMPLEMENTATION.
  METHOD CONSTRUCTOR.
    WRITE: / 'Получение данных'.
  ENDMETHOD.                    "constructor
ENDCLASS.                    "lcl_Data IMPLEMENTATION
*
CLASS lcl_write_alv IMPLEMENTATION.
  METHOD lif_write~write_data.
    WRITE: / 'Вывод данных в ALV'.
  ENDMETHOD.                    "lif_write~write_Data
ENDCLASS.                    "lcl_write_alv IMPLEMENTATION
*
CLASS lcl_write_log IMPLEMENTATION.
  METHOD lif_write~write_data.
    WRITE: / 'Вывод данных в журнал'.
  ENDMETHOD.                    "lif_write~write_Data
ENDCLASS.                    "lcl_write_log IMPLEMENTATION
*
CLASS lcl_facade IMPLEMENTATION.
  METHOD process_report.
    DATA: lo_data TYPE REF TO lcl_data.
    CREATE OBJECT lo_data.
    DATA: lo_write TYPE REF TO lif_write.
    IF iv_write_type = 'A'.
      CREATE OBJECT lo_write TYPE lcl_write_alv.
    ELSE.
      CREATE OBJECT lo_write TYPE lcl_write_log.
    ENDIF.
    lo_write-&gt;write_data( ).
  ENDMETHOD.                    "process_report
ENDCLASS.                    "lcl_facade IMPLEMENTATION
START-OF-SELECTION.
  DATA: lo_facade TYPE REF TO lcl_facade.
  CREATE OBJECT lo_facade.
  lo_facade-&gt;process_report( iv_write_type = 'A' ).</pre><p>Пример реализации был взят <a href="http://help-abap.zevolving.com/2012/01/abap-objects-design-patterns-facade/">отсюда</a>.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-fasad/">Шаблон фасад</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/shablon-fasad/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Шаблон декоратор</title>
		<link>https://abap-blog.ru/osnovy-abap/shablon-dekorator/</link>
					<comments>https://abap-blog.ru/osnovy-abap/shablon-dekorator/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Mon, 09 Jan 2012 07:22:48 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[декоратор]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=160</guid>

					<description><![CDATA[<p>Декоратор, Decorator — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности. Задача Объект, который предполагается использовать, выполняет основные функции (Класс lcl_alv). Однако может потребоваться добавить к нему некоторую дополнительную функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта. В примере ниже функциональность будет [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-dekorator/">Шаблон декоратор</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><strong>Декоратор</strong>, <strong>Decorator</strong> — структурный <a title="Шаблон проектирования" href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">шаблон проектирования</a>, предназначенный для динамического подключения дополнительного поведения к <a title="Объект (программирование)" href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">объекту</a>. Шаблон Декоратор предоставляет гибкую альтернативу практике создания <a title="Класс (программирование)" href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">подклассов</a> с целью расширения функциональности.</p>
<p><span id="more-160"></span></p>
<p><strong>Задача</strong></p>
<p>Объект, который предполагается использовать, выполняет основные функции (Класс <strong>lcl_alv</strong>). Однако может потребоваться добавить к нему некоторую дополнительную функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта. В примере ниже функциональность будет вызываться после основной (класс <strong>op_pdf</strong>).</p>
<p>Декоратор предназначен для динамического добавления объекту новой функциональности. Является гибкой альтернативой механизму наследования, в том числе и множественного.</p>
<p>Данный шаблон используется если необходимо:</p>
<ul>
<li>динамически и прозрачно для клиента изменять функциональность объекта;</li>
<li>(или) реализовать небольшую функциональность, которая в дальнейшем может быть исключена;</li>
<li>(или) уменьшить число классов, получающихся в результате использования наследования;</li>
<li>(или) добавить функциональность классу, от которого невозможно наследоваться;</li>
<li>(или) реализовать аналог множественного наследования, в языках его не поддерживающих.</li>
</ul>
<p><strong>Реализация ABAP:</strong></p><pre class="urvanov-syntax-highlighter-plain-tag">REPORT znp_dp_decorator.

* Абстрактный класс вывода данных
CLASS OUTPUT DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS:
      process_output ABSTRACT.
ENDCLASS.

* Базовый класс вывода, выводит в ALV формате..
CLASS lcl_alv DEFINITION INHERITING FROM OUTPUT.
  PUBLIC SECTION.
    METHODS: process_output REDEFINITION.
ENDCLASS.                    "op_alv DEFINITION

*
CLASS lcl_alv IMPLEMENTATION.
  METHOD process_output.
    WRITE: /(10) SPACE, 'Base class: generating ALV'.
  ENDMETHOD.                    "process_output
ENDCLASS.

* Класс для управления последовательностью вызовов
CLASS opdecorator DEFINITION INHERITING FROM OUTPUT.
  PUBLIC SECTION.
    METHODS:
      CONSTRUCTOR
        IMPORTING io_decorator TYPE REF TO OUTPUT OPTIONAL,
      process_output REDEFINITION.
  PRIVATE SECTION.
    DATA: o_decorator TYPE REF TO OUTPUT.
ENDCLASS.

CLASS opdecorator IMPLEMENTATION.
  METHOD CONSTRUCTOR.
    super-&gt;constructor( ).
    IF io_decorator IS SUPPLIED.
      me-&gt;o_decorator = io_decorator.
    ENDIF.
  ENDMETHOD.
  METHOD process_output.
    CHECK o_decorator IS BOUND.
    o_decorator-&gt;process_output( ).
  ENDMETHOD.
ENDCLASS.

* Класс-декоратор вывода в формате pdf
CLASS op_pdf DEFINITION INHERITING FROM opdecorator.
  PUBLIC SECTION.
    METHODS: process_output REDEFINITION.
ENDCLASS.

*
CLASS op_pdf IMPLEMENTATION.
  METHOD process_output.
    super-&gt;process_output( ). " Сперва вызываем предыдущий вывод.
    WRITE: /(10) SPACE, 'Generating PDF'.
  ENDMETHOD.
ENDCLASS.

* Основной класс отчёта
CLASS mainapp DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      run IMPORTING
        iv_pdf   TYPE flag.
ENDCLASS.                    "mainapp DEFINITION

*
CLASS mainapp IMPLEMENTATION.
  METHOD run.
    DATA: lo_decorator TYPE REF TO OUTPUT,
          lo_pre TYPE REF TO OUTPUT.          " Helper Variable

* Создаем объект стандартного вывода в ALV
    CREATE OBJECT lo_decorator TYPE lcl_alv.
    lo_pre = lo_decorator.  " Запоминаем созданный объект, чтобы вставить в цепочку

* Создаем класс-декоратор для вывода в PDF
    IF iv_pdf IS NOT INITIAL.
      CREATE OBJECT lo_decorator TYPE op_pdf EXPORTING io_decorator = lo_pre.
      lo_pre = lo_decorator.
    ENDIF.

* Цепочка вызовов будет выглядеть так: alv output -&gt; pdf output
    lo_decorator-&gt;process_output( ).
  ENDMETHOD.                    "run
ENDCLASS.                    "mainapp IMPLEMENTATION

PARAMETERS: p_pdf AS CHECKBOX.

START-OF-SELECTION.
  mainapp=&gt;run( iv_pdf = p_pdf ).</pre><p></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/shablon-dekorator/">Шаблон декоратор</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/shablon-dekorator/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
