<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>работа с файлами | ABAP Blog</title>
	<atom:link href="https://abap-blog.ru/tag/rabota-s-fajlami/feed/" rel="self" type="application/rss+xml" />
	<link>https://abap-blog.ru</link>
	<description>Все о разработке в решениях от SAP</description>
	<lastBuildDate>Sat, 02 Oct 2021 17:39:09 +0000</lastBuildDate>
	<language>ru-RU</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.1</generator>
	<item>
		<title>Файловый интерфейс &#8212; операции с файлами</title>
		<link>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/</link>
					<comments>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Mon, 09 Dec 2013 07:26:57 +0000</pubDate>
				<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[работа с файлами]]></category>
		<category><![CDATA[файл]]></category>
		<category><![CDATA[файловый интерфейс]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=1660</guid>

					<description><![CDATA[<p>Файловый интерфейс и юникод Поскольку содержимое файлов отражает структуру данных, обрабатываемую в памяти, файловый интерфейс в юникодных системах должен позволять следующее: Должна быть возможность обмена данными между юникодными и не юникодными системами (т.к. отображение данных в памяти отличается); Должна быть возможность обмена данными между различными юникодными системами; Должна быть возможность обмена данными между разными не юникодными системами, [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/">Файловый интерфейс — операции с файлами</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/file-transfers-_114260033.s300x300.jpg"><img loading="lazy" class="size-full wp-image-1661 alignleft" style="margin: 10px 30px 10px 10px;" src="http://abap-blog.ru/wp-content/uploads/2013/12/file-transfers-_114260033.s300x300.jpg" alt="file-transfers-_114260033.s300x300" width="300" height="232" /></a><strong>Файловый интерфейс и юникод</strong></p>
<p>Поскольку содержимое файлов отражает структуру данных, обрабатываемую в памяти, файловый интерфейс в юникодных системах должен позволять следующее:</p>
<ol>
<li>Должна быть возможность обмена данными между юникодными и не юникодными системами (т.к. отображение данных в памяти отличается);</li>
<li>Должна быть возможность обмена данными между различными юникодными системами;</li>
<li>Должна быть возможность обмена данными между разными не юникодными системами, в которых используются различные кодировки.</li>
</ol>
<p><span id="more-1660"></span></p>
<p>Данные требования накладывают определенные ограничения, так в юникодных системах требуется обязательное указание кодовой страницы, перед работой через интерфейс, кроме того:</p>
<ul>
<li>Файл должен быть явным образом открыт (OPEN DATASET), перед операцией чтения или записи. Кроме того файл, который был уже открыт ранее, не может быть открыт снова (до тех пор, пока не будет закрыт). В не юникодных системах открытие файла происходит неявным образом при обращении к нему (например, при чтении), соответственно не требуется явного открытия перед началом работы. Кроме того, выражение для открытия файла может быть запущено неоднократно, несмотря на то, что открыть файл в программе можно только после его закрытия, либо в первый раз. Повторное открытие в не юникодных системах просто пропускается.</li>
<li>Тип доступа (INPUT,OUTPUT..) и режим обработки файла (TEXT, BINARY) должны быть явно определены, когда файл открывается. В не юникодных системах, если ничего не будет задано, файл откроется с неявно заданными параметрами по умолчанию.</li>
<li>Если файл открыт для чтения, возможно только чтение. В не юникодных системах кроме чтения, возможна так же и запись.</li>
<li>Если файл открыт как текстовый (дополнение TEXT), только символьные переменные могут быть считаны или записаны в него. В не юникодных системах допускается считывание и запись из байтовых или числовых переменных.</li>
</ul>
<p><b>Рекомендуется придерживаться правил определенных в юникодных системах, даже если вы работаете в не юникодной системе.</b></p>
<p>Для поддержки работы с юникодом, был создан специальный системный класс CL_ABAP_FILE_UTILITIES. Некоторые его методы:</p>
<ul>
<li>CHECK_FOR_BOM – проверить наличие в файле метки <a href="http://ru.wikipedia.org/wiki/Byte_order_mark">BOM</a>.</li>
<li>CHECK_UTF8 – хранится ли файл в UTF-8. MAX_KB – определяет размер KB при сканировании.</li>
<li>CREATE_UTF8_FILE_WITH_BOM – создание файла в UTF-8 с меткой.</li>
<li>CHECK_XSTRING_UTF8 – проверить последовательность на наличие UTF-8 кодировки.</li>
<li>CHECK_STRING_7BIT_ASCII – проверяет, содержит ли строка только ASCII символы.</li>
</ul>
<p>&nbsp;</p>
<h2>Операторы файлового интерфейса</h2>
<p>Как было уже упомянуто ранее, файловый интерфейс в ABAP реализован с помощью набора операторов и их параметров:</p>
<ul>
<li>OPEN DATASET</li>
<li>TRANSFER</li>
<li>READ DATASET</li>
<li>GET DATASET</li>
<li>SET DATASET</li>
<li>TRUNCATE DATASET</li>
<li>CLOSE DATASET</li>
<li>DELETE DATASET</li>
</ul>
<p>&nbsp;</p>
<h3>OPEN DATASET</h3>
<p>Синтаксис:</p>
<p><strong>OPEN DATASET dset FOR access IN mode [position] [os_additions] [error_handling].</strong></p>
<p>Данный оператор открывает файл, указанный в dset, для доступа указанного в access и режиме хранения mode. Dset – символьная переменная, в которой будет правильное, с точки зрения ОС, физическое имя файла. Файл нельзя открывать более одного раза, без закрытия, иначе система вызовет исключение (для юникодных систем).</p>
<p>Дополнения position, os_additions, error_handling  указывают, с какой позиции начинать обработку файла, дополнения зависимые от ОС сервера приложений и поведение, связанное с обработкой ошибочных ситуаций.</p>
<p>Особенности:</p>
<ul>
<li>Количество файлов одновременно обрабатываемых не может превышать 100, для одной сессии.</li>
<li>При открытии набора срабатывают автоматические проверки полномочий (рассмотрены выше).</li>
<li>Если имя файла приходит откуда-то извне, необходимо его проверить, чтобы не подвергать систему риску, связанному с обходом <a href="http://help.sap.com/abapdocu_740/en/abendyn_file_scrty.htm">доступа к директориям</a>:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">CALL FUNCTION 'FILE_VALIDATE_NAME'

  EXPORTING
    logical_filename           = 'EXAMPLE_FILE'
  CHANGING
    physical_filename          = file
  EXCEPTIONS
    logical_filename_not_found = 1
    validation_failed          = 2
    OTHERS                     = 3.
IF sy-subrc = 0.
  OPEN DATASET file FOR OUTPUT IN BINARY MODE.
ELSE.
  cl_demo_output=&gt;display( |Error return code { sy-subrc }| ).
ENDIF.</pre><p>В приведенном ниже примере демонстрируется программа, в которой существует возможность обхода полномочий, так как нет проверки (уязвимость проявляет себя, когда в качестве части пути указываются «../» или «..\»):</p><pre class="urvanov-syntax-highlighter-plain-tag">PARAMETERS: pv_fname TYPE c LENGTH 64 LOWER CASE DEFAULT 'test.txt',
            pv_text  TYPE string LOWER CASE DEFAULT 'Содержимое файла'.
DATA        lv_full_name TYPE string.

AT SELECTION-SCREEN.
  IF pv_fname = ''.
    MESSAGE 'Необходимо указать имя файла' TYPE 'E'.
  ENDIF.
  lv_full_name = '/tmp/' &amp;&amp; pv_fname. "Assume enduser inputs only a relative file name.

START-OF-SELECTION.
  OPEN DATASET lv_full_name FOR OUTPUT IN TEXT MODE ENCODING UTF-8 .
  IF sy-subrc &lt;&gt; 0.
    MESSAGE 'Не могу открыть файл' &amp;&amp; lv_full_name TYPE 'E'.
  ELSE.
    TRANSFER pv_text TO lv_full_name.
    CLOSE DATASET lv_full_name.
    WRITE :/ 'Содержимое сохранено в:', lv_full_name.
  ENDIF.</pre><p>Возвращаемые значения поля ошибки, после вызова оператора:</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">sy-subrc</td>
<td valign="top">Значение</td>
</tr>
<tr>
<td valign="top">0</td>
<td valign="top">Файл был открыт.</td>
</tr>
<tr>
<td valign="top">8</td>
<td valign="top">ОС не смогла открыть файл.</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_OPEN</b></p>
<p>Причины: Файл уже открыт.</p>
<p>Ошибка времени выполнения: DATASET_REOPEN</p>
<p><b>CX_SY_CODEPAGE_CONVERTER_INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)</p>
<p>Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_SY_CONVERSION_CODEPAGE</b></p>
<p>Причина: Преобразование невозможно.</p>
<p>Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу</p>
<p>Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p>Причина: Нет доступа к открытию канала,  OPEN DATASET с дополнением FILTER.</p>
<p>Ошибка времени выполнения: OPEN_PIPE_NO_AUTHORITY</p>
<p><b>CX_SY_PIPES_NOT_SUPPORTED</b></p>
<p>Причина: ОС не поддерживает именованные каналы.</p>
<p>Ошибка времени выполнения: DATASET_NO_PIPE</p>
<p><b>CX_SY_TOO_MANY_FILES</b></p>
<p>Причина: Достигнуто максимальное число открытых файлов.</p>
<p>Ошибка времени выполнения: DATASET_TOO_MANY_FILES</p>
<p>&nbsp;</p>
<p><b><i>Не обрабатываемые исключения</i></b></p>
<p>Причина: Именованный канал уже открыт.</p>
<p>Ошибка времени выполнения: DATASET_PIPE_POSITION</p>
<p>&nbsp;</p>
<h4>Дополнение access</h4>
<p><strong>  &#8230; INPUT</strong></p>
<p><strong>| OUTPUT</strong><br />
<strong> | APPENDING</strong><br />
<strong> | UPDATE &#8230; .</strong></p>
<p>Дополнение указывает тип доступа, т.е. каким образом открывается файл: на чтение, запись, добавление или изменение. В юникодных системах указание данного дополнения является обязательным.</p>
<ul>
<li> <b>INPUT</b> – открывает файл для чтения. По умолчанию указатель внутри файла выставляется на начало файла (при работе с файлами важно понимать, что обычно они обрабатываются не целиком, а частями. Для того чтобы определить необходимое начало и конец, обрабатываемой части файла служит файловый указатель.). Если указанный файл не существует, поле sy-subrc будет равно 8. В юникодных программах запрещено вести запись в открытый для чтения файл, для не юникодных программ это ограничение не действует, однако для совместимости необходимо его соблюдать.</li>
<li><b>OUTPUT</b> – открытие файла для записи. Если файл существовал ранее, его содержимое удаляется. Если файл не существует, он создается. Чтение так же разрешено.</li>
<li><b>APPENDING</b> – открытие файла для добавления. Если файл уже существовал, он откроется,  указатель будет перемещен в конец файла. Если файл не существовал, он создается. Попытка чтения файла оператором READ DATASET будет прервана, sy-subrc возвратит 4.</li>
<li><b>UPDATE</b> – открытие файла для обновления существующего содержимого. По умолчанию указатель будет выставлен в начало файла. Если указанный файл не существует, sy-subrc возвратит значение равное 8.</li>
</ul>
<p>&nbsp;</p>
<h4>Дополнение mode</h4>
<p>Данное дополнение указывает на то, работаем ли мы с текстовым файлом или с бинарным. Атрибут LEGACY используется в том случае, когда мы хотим обеспечить совместимость с не юникодными системами.</p>
<p>Синтаксис:</p>
<p><strong>&#8230; {BINARY MODE}</strong></p>
<p><strong> | {TEXT MODE encoding [linefeed] }</strong><br />
<strong> | {LEGACY BINARY MODE [endian] [CODE PAGE cp]}</strong><br />
<strong> | {LEGACY TEXT MODE [endian] [CODE PAGE cp] [linefeed]} &#8230; .</strong></p>
<ul>
<li> <b>BINARY MODE</b>  &#8212; открывает файл как бинарный файл. При записи или чтении, бинарное представление переменных переносится в файл (из файла) в неизменном состоянии.</li>
<li><b>TEXT </b><b>MODE </b>– открывает файл как текстовый. Дополнение Encoding указывает на формат символьного представления (см. ниже). Когда происходит запись в файл, содержимое переменных преобразовывается в соответствии с форматом определенным в Encoding, после чего переносится в файл. Если переменная является символьной (clike) или плоской структурой, пробелы на концах обрезаются. Если используется строковый тип, пробелы не обрезаются. При записи данных, по умолчанию вставляется зависимый от платформы символ конца строки.</li>
</ul>
<p>Считывание происходит до символа конца строки, затем указанные символы преобразуются в соответствии с форматом определенным в Encoding, в текущий формат для сервера и записываются в переменную. Обработка символов конца строки зависит от дополнения linefeed.  Для юникодных программ, в данном режиме, при передаче или считывании из файла, могут быть использованы только символьные типы, кроме того необходимо обязательное указание дополнения encoding. В не юникодных программах дополнение encoding не обязательно. При перемещении указателя, при работе с текстовым файлом происходит перемещение на указанное количество символов, а не байт.</p>
<ul>
<li><b>LEGACY</b> – разница с простым открытием в том, что в данном случае можно задать кодовую страницу, через атрибут CODE PAGE и порядок байт, в атрибуте endian.  В режиме LEGACY TEXT MODE пробелы в символьных (clike) переменных или плоских структурах обрезаются.</li>
</ul>
<p>&nbsp;</p>
<h4><span style="font-size: 1em;">Дополнение linefeed</span></h4>
<p>Дополнение linefeed имеет следующий синтаксис:</p>
<p><strong>&#8230; WITH { NATIVE </strong></p>
<p><strong>| SMART<br />
| UNIX<br />
| WINDOWS } LINEFEED &#8230; .</strong></p>
<p>При использовании данного дополнения, профильный параметр abap/NTfmode (тр. RZ11) игнорируется. Нельзя использовать данное дополнение с дополнением TYPE, если его значение «NT» или «UNIX».</p>
<p>Если данное дополнение не используется, правила определения символа конца строки зависят от текущего сервера приложений и платформы, на которой он запущен:</p>
<ul>
<li>Для UNIX систем (Unix, OS/390, и IBM i5/OS) это «LF».</li>
<li>Для Windows – «CRLF». Кроме того для Windows систем может быть использован параметр abap/NTfmode, который определяет какой символ конца строки использовать для новых файлов. Если его значение «b» &#8212; используется маркер «LF». Если его значение «t» или пустое – используется маркер «CRLF». Данный параметр может быть переопределен в дополнении TYPE и значением для его «NT» или «UNIX». Если существующий файл был открыт без дополнения TYPE, происходит поиск маркера, если маркер был найден, он и будет использоваться для всего файла. Если маркер не был найден, будет использоваться профильный параметр  abap/NTfmode.</li>
</ul>
<p>Если дополнение было указано при открытии файла, оно может быть перезаписано, через оператор SET DATASET.</p>
<p>SAP рекомендует указывать дополнение linefeed, т.к. если его не указать логика определения указателя конца строки будет зависеть от множества факторов: ОС сервера приложений, профильный параметр, существующий символ в имеющемся файле.</p>
<p>Значения, указываемые в дополнении:</p>
<ul>
<li><b>NATIVE</b> – в зависимости от ОС на сервере приложений (см. выше)</li>
<li><b>SMART</b> – данное дополнение зависит от типа доступа к файлу:
<ul>
<li>Если файл открыт на чтение (FOR INPUT), оба маркера будут обрабатываться. При открытии EBCDIC файла так же обрабатывается маркер «NL» (new line).</li>
<li>Если файл открыт для дополнения или для обновления (APPENDING, UPDATE) происходит поиск маркера, который уже был использован в файле. Найденный маркер далее используется для записи. Если маркер не будет найден, будет использован маркер для ОС сервера приложений (как с дополнением NATIVE).</li>
<li>Если файл открывается для записи (OUTPUT), маркер определяется в зависимости от ОС сервера приложений (как с дополнением NATIVE).</li>
<li><b>UNIX</b> – используется «LF» маркер</li>
<li><b>WINDOWS</b> – используется «CRLF» маркер</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h4>Дополнение CODEPAGE</h4>
<p>Синтаксис:</p>
<p><strong>&#8230;  CODE PAGE cp &#8230;</strong></p>
<p>Указывает кодовую страницу, в которой представлены данные файла. Когда данные переносятся из файла в ABAP, происходит автоматическая конвертация в кодовую страницу, использующуюся на сервере приложений (если они не идентичны). При записи происходит аналогичная конвертация в указанную в дополнении кодировку.</p>
<p>В юникодных системах происходит преобразование символов из указанной кодовой страницы в юникодные символы, в соответствии с текущим форматом на сервере приложений.</p>
<p>В качестве параметра <b>cp</b> необходимо использовать переменную со значением из столбца CPCODEPAGE в таблице TCP00.</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/codepages.png"><img loading="lazy" class="alignnone size-full wp-image-1662" src="http://abap-blog.ru/wp-content/uploads/2013/12/codepages.png" alt="codepages" width="796" height="66" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/codepages.png 796w, https://abap-blog.ru/wp-content/uploads/2013/12/codepages-300x24.png 300w" sizes="(max-width: 796px) 100vw, 796px" /></a></p>
<h4></h4>
<h4>Дополнение ENCODING</h4>
<p>Синтаксис:</p>
<p><b>&#8230; </b><b>ENCODING</b><b> { </b><b>DEFAULT</b><b> </b><b><br />
</b><b>            </b><b> | {</b><b>UTF</b><b>-8 [</b><b>SKIPPING</b><b>|</b><b>WITH</b><b> </b><b>BYTE</b><b>&#8212;</b><b>ORDER</b><b> </b><b>MARK</b><b>]}</b><b> </b><b><br />
</b><b>            </b><b> | </b><b>NON</b><b>&#8212;</b><b>UNICODE</b><b> } &#8230; .</b></p>
<p>Определяет формат, используемый для текстовых файлов.  Данное дополнение обязательно для юникодных систем, в не юникодных может быть опущено (по умолчанию примет значение NON-UNICODE).</p>
<p>SAP рекомендует всегда использовать UTF-8 при работе с текстовыми файлами. Так как кодовые страницы не всегда можно идентифицировать относительно содержимого файла.</p>
<p>Может принимать следующие значения:</p>
<ul>
<li><b>DEFAULT</b> – в юникодных системах тоже самое что и UTF-8, для не юникодных систем NON-UNICODE.</li>
<li><b>UTF-8</b> [SKIPPING|WITH BYTE-ORDER MARK] – файл обрабатывается в соответствии с кодировкой <a href="http://ru.wikipedia.org/wiki/UTF-8">UTF-8</a>. С помощью дополнения указывается, необходимо ли обрабатывать символ порядка байт (<a href="http://ru.wikipedia.org/wiki/Byte_order_mark">BOM</a>):
<ul>
<li>SKIPING BYTE-ORDER MARK – используется только если файл открывается для чтения или изменения, если в файле присутствует данный символ указатель переводится на позицию после него, без дополнения файл обрабатывается как обычно.</li>
<li>WITH BYTE-ORDER MARK – используется для файлов открытых на запись (OUTPUT), если дополнение указано символ вставляется автоматически в начало файла, если не указано символ не будет вставлен.</li>
<li><b>NON-</b><b>UNICODE</b> – для не юникодных систем, данные переносятся в файл (из файла) без дополнительной конвертации. В юникодной системе, происходит преобразование в соответствии с настроенным присвоением, таблица TCP0C.</li>
</ul>
</li>
</ul>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/cpconvert.png"><img loading="lazy" class="alignnone size-full wp-image-1663" src="http://abap-blog.ru/wp-content/uploads/2013/12/cpconvert.png" alt="cpconvert" width="520" height="37" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/cpconvert.png 520w, https://abap-blog.ru/wp-content/uploads/2013/12/cpconvert-300x21.png 300w" sizes="(max-width: 520px) 100vw, 520px" /></a></p>
<p>Дополнение BYTE-ORDER MARK не может использоваться одновременно с дополнением position (см. ниже).</p>
<p>Рекомендации SAP:</p>
<ul>
<li>При открытии UTF-8 файлов на чтение желательно всегда пропускать символ порядка байт, использовать SKIPING дополнение.</li>
<li>При записи в UTF-8 файл, желательно всегда записывать метку с дополнением WITH BYTE-ORDER MARK.</li>
<li>С помощью класса CL_ABAP_FILE_UTILITIES и его метода  CREATE_UTF8_FILE_WITH_BOM, можно создать UTF-8 файл с меткой BOM. С помощью метода CHECK_UTF8 можно определить есть ли метка в указанном файле.</li>
</ul>
<p>UTF-16 файлы могут быть открыты только как бинарные файлы.</p>
<h4></h4>
<h4>Дополнение endian</h4>
<p>Синтаксис:</p>
<p><b>&#8230; {BIG|LITTLE} ENDIAN &#8230;</b></p>
<p>Дополнение указывает <a href="http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2">порядок байтов</a> при записи числовых переменных ABAP (i, decfloat16, decfloat34, f, или s).</p>
<p>&nbsp;</p>
<h4>Дополнение position</h4>
<p>Синтаксис:</p>
<p><b>&#8230; </b><b>AT</b><b> </b><b>POSITION</b><b> </b><b>pos</b><b> &#8230; .</b></p>
<p>Переводит указатель файла на указанное в переменной POS число байт. Если в качестве позиции передать -1, указатель будет переведен в конец файла.</p>
<p>Следует знать следующие особенности:</p>
<ul>
<li>Если файл открыт на чтение и значение в pos больше размера файла, указатель становится неопределенным и чтение в таком  случае будет невозможно, до тех пор, пока указатель не будет переведен в пределы размера файла. Если файл обрабатывается в не юникодной системе и происходит запись в него, все последующие от конца файла байты до указателя будут заполнены 16-ричным представлением 0, а запись начнется со следующего байта.</li>
<li>Если файл открыт для записи, все символы с начала файла, до указанной позиции заполняются 16-ричным представлением 0 и запись происходит со следующего байта.</li>
<li>Если файл открывается для добавления (APPENDING), данное дополнение игнорируется, указатель выставляется в конец файла.</li>
<li>Если файл открывается для изменения и позиция указана больше размера файла в байтах, все байты с конца файла по указанную позицию заполняются 16-ричным представлением 0 и запись происходит со следующего байта после указанной позиции.</li>
</ul>
<p>Дополнение не может быть использовано одновременно с дополнениями FILTER и BYTE-ORDER MARK.</p>
<p>&nbsp;</p>
<h4>Дополнения os_additions</h4>
<p>Синтаксис:</p>
<p><b>&#8230; [</b><b>TYPE</b><b> </b><b>attr</b><b>]</b><br />
<b>    </b><b>[</b><b>FILTER</b><b> </b><b>opcom</b><b>] &#8230; .</b></p>
<p>Данные дополнения указывают на специфические для ОС параметры при обработке файлов.</p>
<ul>
<li>Дополнение TYPE attr – зависит от ОС, используемой на сервере приложений. Если ОС не MS Windows, символьное значение, определенное в attr, содержит зависимые от ОС параметры для файла, который должен обрабатываться. Для MS Windows в этот параметр, при работе с текстовыми файлами или текстовыми файлами в режиме совместимости, может быть передан идентификатор символа конца строки: «NT» для CRLF «UNIX» для LF, но только в том случае, если не указано дополнение linefeed. Все остальные значения в данном параметре будут проигнорированы для MS Windows.</li>
</ul>
<p>Пример использования дополнения в ОС IBM i5/OS:</p><pre class="urvanov-syntax-highlighter-plain-tag">OPEN DATASET 'test.dat' 
  TYPE 'lrecl=80, blksize=8000, recfm=FB' 
  FOR OUTPUT IN TEXT MODE 
             ENCODING DEFAULT 
             WITH SMART LINEFEED.</pre><p></p>
<ul>
<li>Дополнение FILTER opcom – данное дополнение поддерживается для ОС (Unix, Windows), работающих с так называемыми <a href="http://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB">именованными каналами</a> (pipes). За более подробной информацией можете обратиться к <a href="http://help.sap.com/abapdocu_740/en/abapopen_dataset_os_addition.htm#!ABAP_ADDITION_1@1@">справке</a> по данному дополнению.</li>
</ul>
<p>&nbsp;</p>
<h4>Дополнения error_handling</h4>
<p>Синтаксис:</p>
<p><b>&#8230; [MESSAGE msg]</b><br />
<b>    [IGNORING CONVERSION ERRORS]</b><br />
<b>    [REPLACEMENT CHARACTER rc] &#8230; .</b></p>
<p>В случае возникновения ошибок, данные дополнения позволяют получать эти ошибки, подавлять некоторые ошибки, определять символы замены для неизвестных символов.</p>
<ul>
<li>Дополнение MESSAGE msg. В случае возникновения ошибки на уровне сервера приложения, в символьную переменную msg будет записан код ошибки, пример:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA mess TYPE string. 

OPEN DATASET `` FOR INPUT IN BINARY MODE MESSAGE mess. 

IF sy-subrc = 8. 
  MESSAGE mess TYPE 'I'. 
ENDIF.</pre><p></p>
<ul>
<li>Дополнение IGNORING CONVERSION ERRORS. Данное дополнение может быть использовано для подавления исключения CX_SY_CONVERSION_CODEPAGE. Данное исключение возникает, если при работе с файлом невозможно сделать преобразование из одной кодовой страницы в другую. Данное дополнение используется только при обработке текстовых файлов, текстовых файлов в режиме совместимости и бинарных файлов в режиме совместимости, но не для бинарных файлов. При этом каждый не конвертируемый символ заменяется по умолчанию символом «#», либо символом, указываемым в следующем дополнении.</li>
<li>REPLACEMENT CHARACTER rc. В качестве rc указывается символ, на который будут заменены не распознанные символы.</li>
</ul>
<p>&nbsp;</p>
<h3>TRANSFER</h3>
<p>Синтаксис:</p>
<p><b>TRANSFER dobj TO dset [LENGTH len]</b><b> </b><b><br />
[NO END OF LINE].</b></p>
<p>Данный оператор переносит содержимое переменной dobj в файл dset. В качестве переменной может быть использована любая символьная переменная или плоская структура. При обработке бинарного файла используются байтовые типы (x, xstring).  В юникодных программах при записи в текстовый файл может использоваться только символьная переменная (не структура), данное ограничение не распространяется на текстовые файлы, открытые в режиме совместимости.</p>
<p>В качестве dset указывается физическое имя файла. Содержимое dobj передается в файл начиная с текущей позиции указателя. После того, как данные будут перенесены в файл, курсор смесится на следующую позицию после перемещенных данных.</p>
<p>Для записи в юникодных программах, необходимо чтобы файл был открыт для записи, добавления или изменения.  Если файл был не открыт заранее, в не юникодных системах он будет открыт неявно.</p>
<p>В зависимости от типа доступа к файлу, есть определенные особенности:</p>
<ul>
<li>Файл открыт для чтения (FOR INPUT). Нельзя производить запись в юникодных программах. В не юникодных программах запись происходи так же, как если бы он был открыт с типом доступа &#8212; FOR UPDATE.</li>
<li>Файл открыт для записи (FOR OUTPUT). Запись происходит, начиная с текущей позиции указателя, если указатель был перемещен дальше конца файла, байты с позиции конца файла, по текущую позицию будут записаны 16-ричным представлением 0.</li>
<li>Если файл был открыт для добавления (APPENDING) , система начинает вести запись с текущего указателя, при первоначальном открытии указатель находится в конце файла.</li>
<li>Файл открыт для изменения (CHANGING). Запись происходит с текущей позиции указателя, если указатель был перемещен дальше конца файла, байты с позиции конца файла, по текущую позицию будут записаны 16-ричным представлением 0. Если часть файла должна быть перезаписана, обязательно открывать с типом доступа CHANGING для юникодных программ. В не юникодных программах, файл, открытый для чтения может быть перезаписан, но SAP не рекомендует этого делать.</li>
</ul>
<p>Кроме того, на работу оператора влияет  тип содержимого файла:</p>
<ul>
<li>Если файл открыт как текстовый или текстовый в режиме совместимости, любые пробелы на концах символьных переменных обрезаются, кроме переменных с типом string. Если необходимо преобразование, в кодовую страницу отличную от системной, происходит преобразование, затем побайтно идет запись в файл.</li>
<li>После записи в файл содержимого из dobj автоматически вставляется метка конца строки, определенная при открытии. Чтобы система не добавляла метку, используется дополнение NO END OF LINE.</li>
</ul>
<p>Следует знать некоторые особенности:</p>
<ul>
<li>Оператор TRANSFER либо возвращает sy-subrc  = 0, либо вызывает исключение.</li>
<li>В не юникодных программах вызов OPEN DATASET перед TRANSFER не обязателен, поэтому в не юникодных программах при вызове оператора TRANSFER срабатывают автоматические проверки доступа к файлу, т.к. происходит неявный вызов OPEN DATASET.</li>
</ul>
<p>Дополнения:</p>
<ul>
<li>LENGTH len – определяет то, как много байтов или символов (в зависимости от типа содержимого) будет записано в файл.  Для бинарных, текстовых в режиме совместимости и бинарных в режиме совместимости файлов, дополнение определяет количество передаваемых байт.</li>
</ul>
<p>Если длинна 0 и меньше, ничего не будет записано.  Если количество в len больше количества символов или байт в dobj, вместо недостающих символов (байтов) в файл будут записаны пустые символы (пробелы) или 16-ричное представление 0.</p>
<p>Пример использования оператора TRANSFER:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE `flights.dat`, 
      wa   TYPE spfli. 

FIELD-SYMBOLS &lt;hex_container&gt; TYPE x. 

OPEN DATASET file FOR OUTPUT IN BINARY MODE. 

SELECT * 
       FROM spfli 
       INTO wa. 
  ASSIGN wa TO &lt;hex_container&gt; CASTING. 
  TRANSFER &lt;hex_container&gt; TO file. 
ENDSELECT. 

CLOSE DATASET file.</pre><p><b><i>Обрабатываемые</i></b><b><i> исключения</i></b></p>
<p><b>CX_</b><b>SY_</b><b>CODEPAGE_</b><b>CONVERTER_</b><b>INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)<br />
Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_</b><b>SY_</b><b>CONVERSION_</b><b>CODEPAGE</b></p>
<p>Причина: Преобразование невозможно.<br />
Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>IO</b></p>
<p>Причина: Ошибка при записи в файл.<br />
Ошибка времени выполнения: DATASET_WRITE_ERROR</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>OPEN</b></p>
<p>Причина: Файл не может быть открыт.<br />
Ошибка времени выполнения: DATASET_CANT_OPEN</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>OPEN_</b><b>MODE</b></p>
<p>Причина: Файл не был открыт для указанного типа доступа.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p>Причина: Файл открыт в юникодной программе с использованием OPEN DATASET &#8230; FOR INPUT и не может использоваться для записи.<br />
Ошибка времени выполнения: DATASET_READ_ONLY</p>
<p><b>CX_SY_PIPE_REOPEN</b></p>
<p>Причина: Рабочий процесс, в котором был открыт файл с именованным каналом либо закрыт, либо переключен.<br />
Ошибка времени выполнения: DATASET_PIPE_CLOSED</p>
<p><b>CX_SY_TOO_MANY_FILES</b></p>
<p>Причина: Достигнуто максимальное число открытых файлов.<br />
Ошибка времени выполнения: DATASET_TOO_MANY_FILES</p>
<p>&nbsp;</p>
<h2>READ DATASET</h2>
<p>Синтаксис:</p>
<p><b>READ DATASET dset INTO dobj [MAXIMUM LENGTH mlen]</b><br />
<b>                           [[ACTUAL] LENGTH alen].</b></p>
<p>Данный оператор производит чтение из файла dset в переменную dobj. В качестве переменной может выступать либо переменная с элементарным типом, либо переменная с типом плоской структуры. В юникодных программах обязательно чтобы переменная была символьной, если файл открыт как текстовый. Чтение происходит с текущей позиции указателя в файле. После того как чтение осуществлено, указатель перемещается на длину считанных данных.</p>
<p>В юникодных программах для того чтобы производить чтение из файла, он должен быть открыт с любым типом доступа.  Если файл не был открыт в не юникодной программе, его открытие происходит неявным образом.</p>
<p>На работу оператора влияет тип содержимого в файле:</p>
<ul>
<li>Если файл открыт как текстовый или как текстовый в режиме совместимости, данные считываются с текущей позиции до метки конца строки, указатель перемещается на позицию после метки конца строки. Если последний символ, в текстовым файле, не является меткой конца строки, конец текстового файла интерпретируется как конец строки.</li>
</ul>
<p>Если переменная dobj слишком коротка относительно считываемых символов, лишние символы обрезаются. Если же она длиннее, переменная заполняется пробелами справа. Если же dobj строковая переменная (тип string) в неё передаются только считанные символы.</p>
<ul>
<li>Если файл открыт как бинарный или как бинарный в режиме совместимости, система считывает ровно столько байтов, сколько может уместиться в переменной dobj. Файловый указатель так же перемещается по мере считывания. Если переменная dobj больше размеров файла, она заполняется 16-ричным представлением 0 справа. Если dobj строка, система пытается считать весь файл в переменную.</li>
</ul>
<p>Если при открытии файла указана необходимость в конвертации кодировок, она срабатывает до присвоения данных переменной, после чего в неё побайтно передаются сконвертированные данные.</p>
<p><b>Заполнение поля </b><b>sy-</b><b>subrc</b></p>
<p>Для текстовых файлов</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top"><b>sy-subrc</b></td>
<td valign="top"><b>Значение</b></td>
</tr>
<tr>
<td valign="top">0</td>
<td valign="top">Данные считаны до явно определенной метки конца строки или до неявной метки конца строки в конце файла.</td>
</tr>
<tr>
<td valign="top">4</td>
<td valign="top">Была сделана попытка чтения данных после конца файла.</td>
</tr>
</tbody>
</table>
<p>Для бинарных файлов</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top"><b>sy-subrc</b></td>
<td valign="top"><b>Значение</b></td>
</tr>
<tr>
<td valign="top">0</td>
<td valign="top">Данные были считаны; при этом система либо достигла конца файла, либо нет</td>
</tr>
<tr>
<td valign="top">4</td>
<td valign="top">Либо была совершена попытка чтения после конца файла, либо переменная в которую происходит чтение оказалась длиннее его содержимого</td>
</tr>
</tbody>
</table>
<p>Существуют следующие особенности:</p>
<ul>
<li>Так как в не юникодных программах открытие файла может происходить не явно, для них вызывается автоматическая проверка полномочий.</li>
<li>Текстовый файл без явно записанных меток конца строки, всегда имеет неявную метку конца строки в конце файла.</li>
<li>При переносе цифровых данных или смешанных структур рекомендуется считывать данные в ссылочную переменную байтового типа, присвоенную с помощью дополнения CASTING (ниже будет показан альтернативный способ считывания, непосредственно в байтовый буфер):</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE `flights.dat`,
      wa   TYPE spfli,
      itab LIKE TABLE OF wa.

FIELD-SYMBOLS &lt;hex_container&gt; TYPE x.

OPEN DATASET file FOR INPUT IN BINARY MODE.

ASSIGN wa TO &lt;hex_container&gt; CASTING.

DO.
  READ DATASET file INTO &lt;hex_container&gt;.
  IF sy-subrc = 0.
    APPEND wa TO itab.
  ELSE.
    EXIT.
  ENDIF.
ENDDO.

CLOSE DATASET file.</pre><p>Дополнения:</p>
<ul>
<li><b>[ACTUAL] LENGTH alen</b>  &#8212; записывает считанный объем данных в переменную alen. Для текстовых – количество символов, для бинарных и в режиме совместимости – количество байт. <b> </b>Слово ACTUAL было введено, чтобы отличать это дополнение от следующего и должно быть всегда использовано.</li>
<li><b>MAXIMUM</b><b> </b><b>LENGTH</b><b> </b><b>mlen</b><b> </b><b>– </b>определяет, как много символов (байт) будет считано из файла. Для текстовых – количество символов, для бинарных и в режиме совместимости – количество байт. Пример:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE `flights.dat`,
      hex_container TYPE x LENGTH 1000,
      len TYPE i,
      itab          TYPE TABLE OF spfli.

FIELD-SYMBOLS &lt;spfli&gt; TYPE spfli.

DESCRIBE FIELD &lt;spfli&gt; LENGTH len IN BYTE MODE.

OPEN DATASET file FOR INPUT IN BINARY MODE.

ASSIGN hex_container TO &lt;spfli&gt; CASTING.

DO.
  READ DATASET file INTO hex_container MAXIMUM LENGTH len.
  IF sy-subrc = 0.
    APPEND &lt;spfli&gt; TO itab.
  ELSE.
    EXIT.
  ENDIF.
ENDDO.

CLOSE DATASET file.</pre><p><b><i>Обрабатываемые</i></b><b><i> исключения</i></b><b><i></i></b></p>
<p><b>CX_SY_CODEPAGE_CONVERTER_INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)<br />
Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_SY_CONVERSION_CODEPAGE</b></p>
<p>Причина: Преобразование невозможно.<br />
Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_SY_FILE_IO</b></p>
<p>Причина: Ошибка при чтении файла.<br />
Ошибка времени выполнения: DATASET_READ_ERROR</p>
<p><b>CX_SY_FILE_OPEN</b></p>
<p>Причина: Файл не был открыт.<br />
Ошибка времени выполнения: DATASET_CANT_OPEN</p>
<p><b>CX_SY_FILE_OPEN_MODE</b></p>
<p>Причина: Файл не был открыт для указанного режима.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p><b>CX_SY_PIPE_REOPEN</b></p>
<p>Причина: Рабочий процесс, в котором был открыт файл с именованным каналом либо закрыт, либо переключен.<br />
Ошибка времени выполнения: DATASET_PIPE_CLOSED</p>
<p>&nbsp;</p>
<h2>GET DATASET</h2>
<p>Синтаксис:</p>
<p><b>GET DATASET dset [POSITION pos] [ATTRIBUTES attr].</b></p>
<p>Данный оператор необходим для получения информации о наборе данных dset. При работе с ним, системное поле с кодом ошибки (sy-subrc) всегда равно 0, однако могут быть вызваны исключения (см. ниже)</p>
<p>Если вызывать оператор без дополнений, он может использоваться для проверки, был ли открыт набор данных ранее, если нет, система вызовет исключение.</p>
<p>Дополнения:</p>
<ul>
<li><b>POSITION pos</b>  &#8212; считывает в переменную pos, с типом i, текущий адрес указателя в файле. Позиция указателя всегда определена в байтах. Если позиция находится в начале файла, значение в переменной будет равно 0. Данное дополнение, не может быть одновременно использовано с описанным выше дополнением FILTER (система вызовет исключение). Для файлов, чей размер превышает 2 ГБ, невозможно получить все позиции указателя в файле. (не хватит диапазона типа i). Пример:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE 'test.dat',
      text TYPE string, pos TYPE i.

OPEN DATASET file FOR OUTPUT IN TEXT MODE
                             ENCODING DEFAULT
                             WITH SMART LINEFEED.
TRANSFER '1234567890' TO file.
GET DATASET file POSITION pos.
TRANSFER 'ABCDEFGHIJ' TO file.
CLOSE DATASET file.

OPEN DATASET file FOR INPUT IN TEXT MODE
                            ENCODING DEFAULT
                            WITH SMART LINEFEED
                            AT POSITION pos.
READ DATASET file INTO text.
CLOSE DATASET file.</pre><p></p>
<ul>
<li> <b>ATTRIBUTES attr</b>  &#8212; считывает атрибуты открытого набора данных. В качестве attr используется переменная с типом dset_attributes:</li>
</ul>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/attr.png"><img loading="lazy" class="alignnone size-full wp-image-1665" src="http://abap-blog.ru/wp-content/uploads/2013/12/attr.png" alt="attr" width="478" height="317" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/attr.png 478w, https://abap-blog.ru/wp-content/uploads/2013/12/attr-300x198.png 300w" sizes="(max-width: 478px) 100vw, 478px" /></a></p>
<p>Данная структура имеет два компонента, фиксированные атрибуты и изменяемые атрибуты. Изменяемые атрибуты можно поменять с помощью оператора SET DATASET (см. ниже). В следующем примере проверяется, открыт ли файл с дополнением FILTER, если нет, можно считать указатель файла:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: dset TYPE string VALUE 'test.dat', 
      pos TYPE I, attr TYPE dset_attributes.

OPEN DATASET dset FOR INPUT IN BINARY MODE 
                  FILTER 'uncompress'. 

... 

GET DATASET dset ATTRIBUTES attr. 
IF attr-fixed-indicator-filter &lt;&gt; 'X'. 
  GET DATASET dset POSITION pos. 
ELSE. 
  ... 
ENDIF. 

CLOSE DATASET dset.</pre><p><b><i>Обрабатываемые исключения</i></b></p>
<ul>
<li><b>CX_SY_FILE_OPEN_MODE</b> &#8212; файл не открыт.</li>
<li><b>CX_SY_FILE_POSITION</b> – невозможно получить позицию указателя файла.</li>
<li><b>CX_SY_CONVERSION_OVERFLOW</b> – переменная pos слишком мала, чтобы в неё можно было записать позицию указателя.</li>
</ul>
<p>&nbsp;</p>
<h2>SET DATASET</h2>
<p>Синтаксис:</p>
<p><b>SET DATASET dset [POSITION {pos|{END OF FILE}}]</b><br />
<b>[ATTRIBUTES attr].</b></p>
<p>Данный оператор позволяет изменять позицию курсора в файле, а так же изменяемые атрибуты набора данных.</p>
<p>Дополнения:</p>
<ul>
<li>[POSITION {pos|{END OF FILE}}] – перемещает указатель файла на позицию указанную в переменной pos, с типом i, либо если указано END OF FILE на конец файла. Если в переменной pos будет 0, указатель переместиться в начало файла, если – 1 в конец. Другие отрицательные значения не разрешается использовать. В зависимости от типа доступа, в котором открыт файл, есть некоторые особенности:
<ul>
<li>Если файл открыт для чтения, и позиция pos будет больше чем длинна файла, указатель будет перемещен вне файла, считать данные не получится до тех пор, пока указатель не будет перемещен в тело файла. Если в не юникодной программе совершить при этом запись, файл с конца будет заполнен 16-ричным представлением 0 до текущей позиции, после чего произойдет запись.</li>
<li>Если файл был открыт для записи или изменения и курсор был перемещен за пределы файла, при записи в него, с конца файла до текущей позиции он будет заполнен 16-ричным представлением 0, затем произойдет запись.</li>
<li>Если файл был открыт для добавления, позиция указателя в нем всегда остается в его конце.</li>
</ul>
</li>
</ul>
<p>Данное дополнение не может быть использовано, если файл был открыт с дополнением FILTER. Для файлов более 2 ГБ, невозможно определить позицию указателя.  Произвольное перемещение указателя больше подходит для бинарных файлов, чем для текстовых. В текстовых файлах позиция будет зависеть от кодировки, символов конца строки, использования юникода, а так же метки порядка байт.  Пример использования дополнения:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE 'test1.dat',
pos TYPE i,
text TYPE string.

OPEN DATASET file FOR OUTPUT IN TEXT MODE
ENCODING DEFAULT
WITH SMART LINEFEED.

TRANSFER: 'Line1' TO file,
'Line2' TO file,
'Line3' TO file.

SET DATASET file POSITION 0.
READ DATASET file INTO text.
SET DATASET file POSITION END OF FILE.

TRANSFER: 'Line4' TO file,
'Line5' TO file,
'Line6' TO file.

CLOSE DATASET file.</pre><p></p>
<ul>
<li>ATTRIBUTES attr – устанавливает изменяемые атрибуты. Для некоторых из изменяемых атрибутов существуют константы из пула типов DSET:</li>
</ul>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/attr2.png"><img loading="lazy" class="alignnone size-full wp-image-1664" src="http://abap-blog.ru/wp-content/uploads/2013/12/attr2.png" alt="attr2" width="355" height="513" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/attr2.png 355w, https://abap-blog.ru/wp-content/uploads/2013/12/attr2-207x300.png 207w" sizes="(max-width: 355px) 100vw, 355px" /></a></p>
<p>Пример:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: dset TYPE string VALUE 'test.dat', 
attr TYPE dset_attributes. 

OPEN DATASET dset FOR INPUT IN LEGACY TEXT MODE 
WITH NATIVE LINEFEED. 

... 

GET DATASET dset ATTRIBUTES attr. 

IF attr-fixed-mode = 'T' OR 
attr-fixed-mode = 'LT'. 
CLEAR attr-changeable. 
attr-changeable-indicator-conv_errors = 'X'. 
attr-changeable-conv_errors = 'I'. 
attr-changeable-indicator-linefeed_mode = 'X'. 
attr-changeable-linefeed_mode = 'S'. 
IF attr-fixed-mode = 'LT'. 
attr-changeable-indicator-code_page = 'X'. 
attr-changeable-code_page = '1100'. 
ENDIF. 
SET DATASET dset ATTRIBUTES attr-changeable. 
ENDIF. 

CLOSE DATASET dset.</pre><p><b><i>Обрабатываемые</i></b><b><i> исключения</i></b></p>
<p><b>CX_SY_CODEPAGE_CONVERTER_INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)<br />
Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_</b><b>SY_</b><b>CONVERSION_</b><b>CODEPAGE</b></p>
<p>Причина: Изменение символов замены и обработки ошибок возможно лишь для файлов открытых в TEXT MODE или LEGACY &#8230; MODE.<br />
Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_OPEN_MODE</b></p>
<p>Причина: Файл открыт на чтение, изменение невозможно<br />
Ошибка времени выполнения: DATASET_READ_ONLY</p>
<p>Причина: Файл не был открыт.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p>Причина: Файл открыт в неподдерживаемом режиме.<br />
Ошибка времени выполнения: DATASET_INCOMPATIBLE_MODE</p>
<p><b>CX_SY_FILE_POSITION</b></p>
<p>Причина: Ошибка при смене указателя.<br />
Ошибка времени выполнения: DATASET_SEEK_ERROR</p>
<p>Причина: Нет доступа для смены позиции.<br />
Ошибка времени выполнения: DATASET_NO_POSITION</p>
<p>Причина: Перемещение невозможно на указанную позицию, слишком большая позиция.<br />
Ошибка времени выполнения: DATASET_OFFSET_TOO_LARGE</p>
<p><b><i>Не обрабатываемые исключения</i></b></p>
<p>Причина: Невозможно изменить позицию для именованного канала.<br />
Ошибка времени выполнения: DATASET_PIPE_POSITION</p>
<p>&nbsp;</p>
<h2>TRUNCATE DATASET</h2>
<p>Синтаксис:</p>
<p><b>TRUNCATE DATASET dset AT {CURRENT POSITION}|{POSITION pos}.</b></p>
<p>С помощью данного оператора можно изменить размер файла (уменьшить или увеличить). Уменьшается когда позиция указателя после AT меньше текущего размера файла, увеличивается, когда больше. При увеличении размера файл заполняется 16-ричным представлением 0.</p>
<p>Оператор можно использовать, если файл открыт на запись, изменение или дополнение, а так же не указано дополнение FILTER.</p>
<p>Оператор всегда возвращает sy-subrc равное 0, либо вызывает исключение. Оператор не устанавливает новую позицию для указателя в файле. Если файл открыт для добавления, указатель перемещается непосредственно перед записью в файл.</p>
<p>Дополнения:</p>
<ul>
<li>CURRENT POSITION  &#8212; устанавливает конец в файла в текущей позиции</li>
<li>POSITION pos – устанавливает конец файла в указанной в pos позиции. В pos может быть передана любая числовая переменная, если её значение целое и не отрицательное.</li>
</ul>
<p>Пример использования оператора TRUNCATE:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: name TYPE string VALUE `test.dat`,
      hex  TYPE xstring.

hex = 'FFFF'.

OPEN DATASET name FOR OUTPUT IN BINARY MODE.

TRANSFER hex TO name.
SET DATASET name POSITION 0.
READ DATASET name INTO hex.

TRUNCATE DATASET name AT POSITION 1.
SET DATASET name POSITION 0.
READ DATASET name INTO hex.

TRUNCATE DATASET name AT POSITION 2.
SET DATASET name POSITION 0.
READ DATASET name INTO hex.

CLOSE DATASET name.</pre><p>После первого вызова оператора в файле останется значение «FF», после второго «FF00».</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_OPEN</b></p>
<p>Причина: Файл не был открыт.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p>Причина: Файл открыт только для чтения.<br />
Ошибка времени выполнения: DATASET_READ_ONLY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>POSITION</b></p>
<p>Причина: Указана неверная позиция.<br />
Ошибка времени выполнения: DATASET_OFFSET_TOO_LARGE</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>TRUNCATE</b></p>
<p>Причина: ОС не может изменить размер файла.<br />
Ошибка времени выполнения: DATASET_TRUNCATE_ERROR</p>
<p>Причина: Невозможно изменить размер файла, открытого с дополнением FILTER.<br />
Ошибка времени выполнения: DATASET_TRUNCATE_ERROR</p>
<p><b><i>Не обрабатываемые исключения</i></b></p>
<p>Причина: Внутренняя ошибка.<br />
Ошибка времени выполнения: DATASET_TRUNCATE_ERROR</p>
<p>&nbsp;</p>
<h2>CLOSE DATASET</h2>
<p>Синтаксис:</p>
<p><b>CLOSE DATASET dset.</b></p>
<p>Оператор закрывает набор данных. Если файл уже был закрыт или еще не открыт, система игнорирует данный оператор, sy-subrc равен 0.  Если в ОС используется буфер при изменении файла, все что было в нем, переносится в файл.  Если при закрытии программы не было явного вызова закрытия набора данных, он закрывается автоматически.</p>
<p>Если файл открыт с дополнением FILTER, при его закрытии sy-subrc содержит код возврата из именованного канала, возвращаемый ОС. Если не было исключений sy-subrc равно 0.</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_CLOSE</b></p>
<p>Причина: Файл не был закрыт. Возможной причиной является недостаток памяти.<br />
Ошибка времени выполнения: DATASET_CANT_CLOSE</p>
<p>&nbsp;</p>
<h2>DELETE DATASET</h2>
<p>Синтаксис:</p>
<p><b>DELETE DATASET dset.</b></p>
<p>Удаляет указанный файл, при этом он может быть закрыт или открыт.  Если имя файла приходит извне, оно может нести серьезный риск из-за обхода директорий (см. выше) и требует дополнительной проверки.</p>
<p>Если значение поля sy-subrc равно 0, файл был удален. Если значение поля sy-subrc равно 4, файл не был удален.</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>OPEN</b></p>
<p>Причина: Файл не может быть открыт<br />
Ошибка времени выполнения: DATASET_CANT_OPEN</p>
<p>&nbsp;</p>
<h2>Дополнительные операции при работе с файлами</h2>
<p>Файловый интерфейс ABAP не предоставляет таких возможностей, как: переименовать файл (без его копирования в другой файл), листинга в директориях на сервере приложений,  копирования файла без его полного считывания через сервер приложений и др. Большинство этих операций выполняются на уровне системных команд сервера приложений, таких как: cp, mv, mkdir и других.</p>
<p>Для демонстрации работы данных операций можно посмотреть программу <a href="http://scn.sap.com/community/abap/blog/2012/05/03/al11-replacement">ZAL11</a>, которая является заменой стандартной тр. AL11, но с более продвинутыми возможностями:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/zall11.png"><img loading="lazy" class="alignnone size-large wp-image-1666" src="http://abap-blog.ru/wp-content/uploads/2013/12/zall11-1024x459.png" alt="zall11" width="550" height="246" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/zall11-1024x459.png 1024w, https://abap-blog.ru/wp-content/uploads/2013/12/zall11-300x134.png 300w, https://abap-blog.ru/wp-content/uploads/2013/12/zall11.png 1213w" sizes="(max-width: 550px) 100vw, 550px" /></a></p>
<p>Так, например, выглядит процедура копирования (перемещения) файла (директории):</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;      Form  COPY_ITEM
*&amp;---------------------------------------------------------------------*
*       Copy or move remote file/folder
*----------------------------------------------------------------------*
*      --&gt;PW_NAME        File/folder to move/copy
*      --&gt;PW_PATH_TARGET Target folder
*      --&gt;PW_ACTION      Move : 2, copy : 1
*      --&gt;PW_TYPE        0=file, 1=folder
*----------------------------------------------------------------------*
FORM copy_item USING pw_name TYPE c
                     pw_path_target TYPE c
                     pw_action TYPE i
                     pw_type TYPE i.
  DATA : lw_command(1000) TYPE c,
         lw_action(1) TYPE c,
         lw_name TYPE string,
         lw_target TYPE string.

* Authority check for move/copy files
  IF s_auth-move_file NE c_true AND pw_type = 0.
    MESSAGE 'You are not allowed to perform this action'(e21)
            TYPE 'S' DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.

* Authority check for move/copy folders
  IF s_auth-move_folder NE c_true AND pw_type = 1.
    MESSAGE 'You are not allowed to perform this action'(e21)
            TYPE 'S' DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.

  CONCATENATE '"' pw_name '"' INTO lw_name.
  CONCATENATE '"' pw_path_target '"' INTO lw_target.

* Confirm action on remote server
  IF pw_action = 1.
    lw_command = 'Are you sure you want to copy # into # ?'(t01).
  ELSE.
    lw_command = 'Are you sure you want to move # into # ?'(t02).
  ENDIF.
  REPLACE FIRST OCCURRENCE OF c_wildcard IN lw_command WITH lw_name.
  REPLACE FIRST OCCURRENCE OF c_wildcard IN lw_command WITH lw_target.
  PERFORM confirm_action USING lw_command CHANGING lw_action.
  IF lw_action = space.
    EXIT.
  ENDIF.

  IF pw_action = 1.
* Server command to copy file/folder
    CONCATENATE 'cp -r' lw_name lw_target INTO lw_command
                SEPARATED BY space.
  ELSE.
* Server command to move file/folder
    CONCATENATE 'mv' lw_name lw_target INTO lw_command
                SEPARATED BY space.
  ENDIF.
  CALL 'SYSTEM' ID 'COMMAND' FIELD lw_command.

* If application server is too fast, file server is not updated
* before querriing. Wait 1 second after server action
  WAIT UP TO 1 SECONDS.

ENDFORM.</pre><p>Вызов системных команд подобным образом, не является безопасным, подробнее читайте в <a title="Безопасный запуск системных команд из ABAP" href="http://scn.sap.com/community/abap/blog/2013/10/29/secure-execution-of-os-commands-by-abap-programs" target="_blank" rel="noopener">блоге</a>.</p>
<p>&nbsp;</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/">Файловый интерфейс — операции с файлами</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
	</channel>
</rss>
