<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>ABAP Objects | ABAP Blog</title>
	<atom:link href="https://abap-blog.ru/category/osnovy-abap/oop/feed/" rel="self" type="application/rss+xml" />
	<link>https://abap-blog.ru</link>
	<description>Все о разработке в решениях от SAP</description>
	<lastBuildDate>Tue, 02 Mar 2021 06:15:57 +0000</lastBuildDate>
	<language>ru-RU</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.1</generator>
	<item>
		<title>Введение в ООП ABAP</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/vvedenie-v-oop-abap/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/vvedenie-v-oop-abap/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Thu, 26 Sep 2019 15:28:53 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">https://abap-blog.ru/?p=3277</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[<div class="arve aligncenter" data-mode="normal" data-provider="youtubelist" id="arve-youtubelist-ploc6uc3ml1jt55kwljve1qxnsp9emojg2618a04c3debf9921082866" style="max-width:1280px;" itemscope itemtype="http://schema.org/VideoObject">
<span class="arve-inner">
<span class="arve-embed arve-embed--has-aspect-ratio arve-embed--16by9">
<meta itemprop="embedURL" content="https://www.youtube.com/embed/videoseries?list=PLoc6uc3ML1JT55KwLJVe1QXnsP9emoJG2&amp;iv_load_policy=3&amp;modestbranding=1&amp;rel=0&amp;autohide=1&amp;playsinline=0&amp;vq=hd1080&amp;autoplay=0">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen class="arve-iframe fitvidsignore" data-arve="arve-youtubelist-ploc6uc3ml1jt55kwljve1qxnsp9emojg2618a04c3debf9921082866" data-src-no-ap="https://www.youtube.com/embed/videoseries?list=PLoc6uc3ML1JT55KwLJVe1QXnsP9emoJG2&amp;iv_load_policy=3&amp;modestbranding=1&amp;rel=0&amp;autohide=1&amp;playsinline=0&amp;vq=hd1080&amp;autoplay=0" frameborder="0" height="720" sandbox="allow-scripts allow-same-origin allow-presentation allow-popups allow-popups-to-escape-sandbox" scrolling="no" src="https://www.youtube.com/embed/videoseries?list=PLoc6uc3ML1JT55KwLJVe1QXnsP9emoJG2&#038;iv_load_policy=3&#038;modestbranding=1&#038;rel=0&#038;autohide=1&#038;playsinline=0&#038;vq=hd1080&#038;autoplay=0" width="1280"></iframe>
<meta itemprop="name" content="Введение в ООП ABAP">
<meta itemprop="description" content="Введение в ООП ABAP">

</span>

</span>

</div><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/vvedenie-v-oop-abap/">Введение в ООП ABAP</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/vvedenie-v-oop-abap/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Writing Testable Code for ABAP</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/writing-testable-code-for-abap/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/writing-testable-code-for-abap/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Wed, 14 Mar 2018 09:01:53 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=3198</guid>

					<description><![CDATA[<p>На openSAP стал доступен курс, направленный на ABAP разработчиков, которые хотят научиться разрабатывать тестируемый код. Основные темы затрагиваемые курсом: Introduction to ABAP Unit Testing Test-Driven Development Pair Programming &#38; Writing Testable Code Test Isolation Theory and Practice Dependency Lookup Working with Legacy Code, Tools and Summary https://open.sap.com/courses/wtc1</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/writing-testable-code-for-abap/">Writing Testable Code for ABAP</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>На openSAP стал доступен курс, направленный на ABAP разработчиков, которые хотят научиться разрабатывать тестируемый код.</p>
<p>Основные темы затрагиваемые курсом:</p>
<ul>
<li>Introduction to ABAP Unit Testing</li>
<li>Test-Driven Development</li>
<li>Pair Programming &amp; Writing Testable Code</li>
<li>Test Isolation Theory and Practice</li>
<li>Dependency Lookup</li>
<li>Working with Legacy Code, Tools and Summary</li>
</ul>
<p><a href="https://open.sap.com/courses/wtc1">https://open.sap.com/courses/wtc1</a></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/writing-testable-code-for-abap/">Writing Testable Code for ABAP</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/writing-testable-code-for-abap/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Паттерны проектирования в ABAP примерах</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 08 May 2016 06:00:36 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<category><![CDATA[паттерны проектирования]]></category>
		<category><![CDATA[шаблоны проектирования]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2729</guid>

					<description><![CDATA[<p>Ранее в блоге уже упоминались паттерны проектирования (GoF), однако их рассмотрение было несколько скомканным и не полным, в данной статье они будут рассмотрены более подробно. Изучая паттерны, не стоит считать их неким священным Граалем, способным решить все задачи, они лишь инструмент, который нужно еще и грамотно применить. Главное, что нужно оценивать это то, какую проблему [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/">Паттерны проектирования в ABAP примерах</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Ранее в блоге уже упоминались паттерны проектирования (GoF), однако их рассмотрение было несколько скомканным и не полным, в данной статье они будут рассмотрены более подробно.</p>
<p><span id="more-2729"></span></p>
<p>Изучая паттерны, не стоит считать их неким священным Граалем, способным решить все задачи, они лишь инструмент, который нужно еще и грамотно применить. Главное, что нужно оценивать это то, какую проблему решает тот или иной паттерн и для чего он создан. Бездумное применение паттернов лишь внесёт дополнительную сложность в Ваше решение.</p>
<p>Большинство паттернов имеют свою каноническую реализацию, а есть и упрощённые/усложнённые варианты. В данной статье не будут рассматриваться все реализации, более подробную информацию Вы сможете найти в соответствующей литературе и курсах, ссылки на которые будут в конце статьи.</p>
<p>&nbsp;</p>
<h4>Порождающие паттерны (Creational patterns)</h4>
<p>&nbsp;</p>
<p>За конструирование объектов в ООП языках обычно отвечает конструктор и клиент, вызывающий конструктор нужного ему класса. Однако бывают случаи, когда заранее тип объекта не известен или использование конструктора напрямую является неудобным или невозможным. Порождающие паттерны помогают решить типовые проблемы создания объектов.</p>
<p>К порождающим паттернам относятся:</p>
<ul>
<li><a href="http://abap-blog.ru/oop/abstraktnaya-fabrika/">Абстрактная фабрика</a> (Abstract factory)</li>
<li><a href="http://abap-blog.ru/oop/fabrichnyj-metod/">Фабричный метод</a> (Factory method)</li>
<li><a href="http://abap-blog.ru/oop/stroitel/">Строитель</a> (Builder)</li>
<li><a href="http://abap-blog.ru/oop/prototip/">Прототип</a> (Prototype)</li>
<li><a href="http://abap-blog.ru/oop/odinochka/">Одиночка</a> (Singleton)</li>
</ul>
<h4>Поведенческие паттерны (Behavioral patterns)</h4>
<p>&nbsp;</p>
<p>Поведенческие шаблоны проектирования определяют общие закономерности связей между объектами, реализующими их. Следование этим шаблонам уменьшает связность системы и облегчает коммуникацию между объектами, что увеличивает гибкость программного продукта.</p>
<p>К поведенческим паттернам относятся:</p>
<ul>
<li><a href="http://abap-blog.ru/oop/strategiya/">Стратегия </a>(Strategy)</li>
<li><a href="http://abap-blog.ru/oop/shablonnyj-metod-template-method/">Шаблонный метод </a>(Template method)</li>
<li><a href="http://abap-blog.ru/oop/posrednik-mediator/">Посредник </a>(Mediator)</li>
<li><a href="http://abap-blog.ru/oop/komanda-command-2/">Команда </a>(Command)</li>
<li><a href="http://abap-blog.ru/oop/cepochka-otvetstvennosti-chain-of-responsibility/">Цепочка обязанностей </a>(Chain of Responsibility)</li>
<li><a href="http://abap-blog.ru/oop/interpretator-interpreter/">Интерпретатор </a>(Interpreter)</li>
<li><a href="http://abap-blog.ru/oop/iterator-iterator/">Итератор </a>(Iterator)</li>
<li><a href="http://abap-blog.ru/oop/xranitel-memento/">Хранитель </a>(Memento)</li>
<li><a href="http://abap-blog.ru/oop/nablyudatel-observer/">Наблюдатель </a>(Observer)</li>
<li><a href="http://abap-blog.ru/oop/sostoyanie-state/">Состояние </a>(State)</li>
<li><a href="http://abap-blog.ru/oop/posetitel-visitor/">Посетитель </a>(Visitor)</li>
<li>&#8230;</li>
</ul>
<p>&nbsp;</p>
<h4>Структурные паттерны (Structural patterns)</h4>
<p>&nbsp;</p>
<p>Структурные паттерны рассматривают вопросы о компоновке системы на основе классов и объектов. При этом могут использоваться следующие механизмы:</p>
<ul>
<li>Наследование, когда базовый класс определяет интерфейс, а подклассы &#8212; реализацию. Структуры на основе наследования получаются статичными.</li>
<li>Композиция, когда структуры строятся путем объединения объектов некоторых классов. Композиция позволяет получать структуры, которые можно изменять во время выполнения.</li>
</ul>
<p>К структурным паттернам относятся:</p>
<ul>
<li><a href="http://abap-blog.ru/oop/adapter-adapter/">Адаптер </a>(Adapter)</li>
<li><a href="http://abap-blog.ru/oop/most-bridge/">Мост </a>(Bridge)</li>
<li><a href="http://abap-blog.ru/oop/komponovshhik-composite/">Компоновщик </a>(Composite)</li>
<li><a href="http://abap-blog.ru/oop/dekorator-decorator-wrapper/">Декоратор </a>(Decorator)</li>
<li><a href="http://abap-blog.ru/oop/fasad-facade/">Фасад </a>(Facade)</li>
<li><a href="http://abap-blog.ru/oop/prisposoblenec/">Приспособленец </a>(Flyweight)</li>
<li><a href="http://abap-blog.ru/oop/zamestitel-proxy/">Заместитель </a>(Proxy)</li>
<li>&#8230;</li>
</ul>
<p>&nbsp;</p>
<h4>Источники</h4>
<p>&nbsp;</p>
<ol>
<li>Youtube канал <a href="https://www.youtube.com/channel/UCVbz7l0COUdLupcY4YtYH0w">Сергея Немчинского</a>.</li>
<li>Видео курс Александра Шевчука на  <a href="http://itvdn.com/ru/patterns">ITVDN</a>.</li>
<li><a href="http://www.ozon.ru/context/detail/id/31789305/">Паттерны проектирования на платформе .NET</a> от Сергея Теплякова. Пожалуй лучшая книга по теме.</li>
<li>Видео курс Design Patterns Library на <a href="https://www.pluralsight.com/courses/patterns-library">Pluralsight</a>.</li>
<li><a href="https://habrahabr.ru/post/136766/">Статья </a>о паттернах в ООП метафорах.</li>
<li><a href="http://www.ozon.ru/context/detail/id/2457392/">Приемы объектно-ориентированного проектирования. Паттерны проектирования</a>.</li>
<li>Э. Фриман. <a href="http://www.ozon.ru/context/detail/id/31079082/">Паттерны проектирования.</a></li>
<li>Wiki. <a href="https://ru.m.wikipedia.org/wiki/Шаблон_проектирования">Шаблоны проектирования</a>.</li>
</ol><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/">Паттерны проектирования в ABAP примерах</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/patterny-proektirovaniya-v-abap-primerax/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Одиночка (Singleton)</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/odinochka/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/odinochka/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 May 2016 09:06:07 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2767</guid>

					<description><![CDATA[<p>Метафора &#160; Представьте, что Вам нужно организовать в городе телефонную связь. Можно протянуть кабеля от каждого жителя к каждому, но такое решение явно имеет недостаток при добавлении нового жителя, т.к. придётся тянуть от него кабель до всех других. Гораздо дешевле создать в городе телефонную станцию, к которой будет подсоединен каждый житель. Для того чтобы позвонить [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/odinochka/">Одиночка (Singleton)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<h4>Метафора</h4>
<p>&nbsp;</p>
<p>Представьте, что Вам нужно организовать в городе телефонную связь. Можно протянуть кабеля от каждого жителя к каждому, но такое решение явно имеет недостаток при добавлении нового жителя, т.к. придётся тянуть от него кабель до всех других. Гораздо дешевле создать в городе телефонную станцию, к которой будет подсоединен каждый житель. Для того чтобы позвонить нужно будет связаться со станцией, а далее станция сделает перенаправление к любому подключенному к ней жителю. Телефонная станция в данном контексте является одиночкой, смысл в том, что когда вы говорите «Мне нужна телефонная станция», вам бы отвечали «Вот она, держи», а не «Давай создадим её заново». Одиночка всегда один.</p>
<p>&nbsp;</p>
<p><span id="more-2767"></span></p>
<h4>Назначение</h4>
<p>&nbsp;</p>
<p>Гарантирует, что у класса всегда будет существовать только один экземпляр, и предоставляет глобальную точку доступа к нему.</p>
<p>Плюсы:</p>
<ul>
<li>Контролируемый доступ к единственному экземпляру</li>
</ul>
<p>Недостатки паттерна:</p>
<ul>
<li>Использование одиночки приводит к неявным зависимостям. Так как получение инстанции может происходить где угодно, это усложняет процесс анализа работы классов, использующих их.</li>
</ul>
<p>&nbsp;</p>
<h4>Диаграмма</h4>
<p>&nbsp;</p>
<div id="attachment_2768" style="width: 173px" class="wp-caption aligncenter"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/5-Singleton.png"><img aria-describedby="caption-attachment-2768" loading="lazy" class="size-full wp-image-2768" src="http://abap-blog.ru/wp-content/uploads/2016/05/5-Singleton.png" alt="Одиночка" width="163" height="134" /></a><p id="caption-attachment-2768" class="wp-caption-text">Одиночка</p></div>
<p>&nbsp;</p>
<h4>Пример</h4>
<p>&nbsp;</p><pre class="urvanov-syntax-highlighter-plain-tag">CLASS lcl_singleton DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS:
      get_instance RETURNING VALUE(ro_singleton) TYPE REF TO lcl_singleton.
  PRIVATE SECTION.
    CLASS-DATA:
      go_instance TYPE REF TO lcl_singleton.
ENDCLASS.

CLASS lcl_singleton IMPLEMENTATION.
  METHOD get_instance.
    IF go_instance IS NOT BOUND.
      CREATE OBJECT go_instance.
    ENDIF.

    ro_singleton = go_instance.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA: lo_singleton TYPE REF TO lcl_singleton.
  " Создание инстанции класса "LCL_SINGLETON" вне класса не разрешено
  " CREATE OBJECT lo_singleton.

  lo_singleton = lcl_singleton=&gt;get_instance( ).</pre><p>Создание класса напрямую запрещено через CREATE PRIVATE, вместо этого создан метод возвращающий инстанцию класса, причем он проверяет, создан ли уже ранее объект или нет и если создан, возвращает его. Т.к. это статический атрибут, инстанция будет всегда одной в рамках сессии.</p>
<p>Одним из недостатков этого подхода является невозможность замены одиночки в юнит-тестах на объекты заглушки, решить эту проблему поможет несколько расширенная версия:</p><pre class="urvanov-syntax-highlighter-plain-tag">INTERFACE lif_singleton.
  METHODS:
    do_something.
ENDINTERFACE.

CLASS lcl_singleton DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES: lif_singleton.
    ALIASES: do_something FOR lif_singleton~do_something.
    CLASS-DATA:
      go_instance TYPE REF TO lif_singleton.
    CLASS-METHODS:
      get_instance RETURNING VALUE(ro_singleton) TYPE REF TO lif_singleton.
ENDCLASS.

CLASS lcl_singleton IMPLEMENTATION.
  METHOD get_instance.
    IF go_instance IS NOT BOUND.
      CREATE OBJECT go_instance TYPE lcl_singleton.
    ENDIF.

    ro_singleton = go_instance.
  ENDMETHOD.

  METHOD do_something.
    WRITE 'Something'.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_singleton_for_testing DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_singleton.
    ALIASES: do_something FOR lif_singleton~do_something.
ENDCLASS.

CLASS lcl_singleton_for_testing IMPLEMENTATION.
  METHOD do_something.
    WRITE 'Something for test'.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA: lo_singleton TYPE REF TO lif_singleton.
  DATA: lo_singleton_for_testing TYPE REF TO lcl_singleton_for_testing.

  CREATE OBJECT lo_singleton_for_testing.
  lcl_singleton=&gt;go_instance = lo_singleton_for_testing.

  lo_singleton ?= lcl_singleton=&gt;get_instance( ).
  lo_singleton-&gt;do_something( ).</pre><p>Основная идея тут вынести поведение одиночки в интерфейс и через публичное свойство (или метод) подменить инстанцию на ту, что нужна для теста.</p>
<p>Кроме перечисленных подходов одиночка может быть представлен как класс с исключительно статическими методами и атрибутами.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/odinochka/">Одиночка (Singleton)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/odinochka/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Прототип (Prototype)</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/prototip/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/prototip/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 May 2016 09:00:49 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2761</guid>

					<description><![CDATA[<p>Метафора &#160; Данный паттерн чем-то напоминает «фабрику», он также служит для создания объектов, однако с немного другим подходом. Представьте, что у вас есть пустой пакет (из-под сока), а вам нужен полный с апельсиновым соком. Вы «говорите» пакету «Хочу пакет апельсинового сока», он в свою очередь создает свою копию и заполняет ее соком, который вы попросили. [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/prototip/">Прототип (Prototype)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<h4>Метафора</h4>
<p>&nbsp;</p>
<p>Данный паттерн чем-то напоминает «фабрику», он также служит для создания объектов, однако с немного другим подходом. Представьте, что у вас есть пустой пакет (из-под сока), а вам нужен полный с апельсиновым соком. Вы «говорите» пакету «Хочу пакет апельсинового сока», он в свою очередь создает свою копию и заполняет ее соком, который вы попросили. Немного «сказочный пример», но в программировании часто так и бывает. В данном случае пустой пакет и является «прототипом», и в зависимости от того что вам требуется, он создает на своей основе требуемые вами объекты (пакеты сока). Клонирование не обязательно должно производится на самом «пакете», это может быть и какой-то другой «объект», главное лишь что данный «прототип» позволяет получать его экземпляры.</p>
<p>&nbsp;</p>
<p><span id="more-2761"></span></p>
<h4>Назначение</h4>
<p>&nbsp;</p>
<p>Паттерн применяется для тех случаев, когда требуется построение некоторых объектов на базе состояния общего для них прототипа. Клонирование в данном контексте подразумевает копирование состояния одного объекта, и установка его в другом. Сам процесс построения клонов не подразумевает повторный вызов конструктора у клонов на стороне клиента, в данном случае используется вызов специального метода, который вернет клона с состоянием как у прототипа. Благодаря тому, что метод клонирования наследуется из базового класса, клиенту не обязательно знать к какому типу относится объект.</p>
<p>Часто паттерн применяется, когда первоначальное состояние объекта довольно долго инициализируется, при этом данный шаг пропускается при операции клонирования, т.к. прототип уже проинициализирован и может предоставить своё состояние для клона.</p>
<p>&nbsp;</p>
<h4>Диаграмма</h4>
<p>&nbsp;</p>
<div id="attachment_2763" style="width: 573px" class="wp-caption aligncenter"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/4.prototype.png"><img aria-describedby="caption-attachment-2763" loading="lazy" class="size-full wp-image-2763" src="http://abap-blog.ru/wp-content/uploads/2016/05/4.prototype.png" alt="Прототип" width="563" height="235" srcset="https://abap-blog.ru/wp-content/uploads/2016/05/4.prototype.png 563w, https://abap-blog.ru/wp-content/uploads/2016/05/4.prototype-300x125.png 300w" sizes="(max-width: 563px) 100vw, 563px" /></a><p id="caption-attachment-2763" class="wp-caption-text">Прототип</p></div>
<p>&nbsp;</p>
<h4>Пример</h4>
<p>&nbsp;</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;  Определение классов
*&amp;---------------------------------------------------------------------*

INTERFACE lif_clonable.
  METHODS:
    clone RETURNING VALUE(ro_clone) TYPE REF TO lif_clonable.
ENDINTERFACE.

CLASS lcl_request DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_clonable.
    ALIASES clone FOR lif_clonable~clone.
    TYPES:
      BEGIN OF ty_request_state,
        request_id      TYPE i,
        entity_id       TYPE i,
        request_data    TYPE string,
      END OF ty_request_state.
    METHODS:
      constructor IMPORTING iv_entity_id TYPE i
                            is_state TYPE ty_request_state OPTIONAL,
      get_state   RETURNING VALUE(rs_state) TYPE ty_request_state.
  PRIVATE SECTION.
    DATA:
      ms_request_data  TYPE ty_request_state.
ENDCLASS.

CLASS lcl_request IMPLEMENTATION.
  METHOD constructor.
    " Если передали состояние, инициализируемся по нему
    IF is_state IS SUPPLIED.
      ms_request_data  = is_state.
      RETURN.
    ENDIF.

    " Эмулируем вызов RFC
    WAIT UP TO 3 SECONDS.
    " В реальности было бы что-то вроде
    " CALL FUNCTION 'ZGET_DATA_FROM_RFC'
    " EXPORTING
    "   iv_entity_id = iv_entity_id
    " IMPORTING
    "   es_request_data = ms_request_data 
    ms_request_data -entity_id = iv_entity_id.
    ms_request_data -request_data = 'Sample data'.
    ms_request_data -request_id = 1.
  ENDMETHOD.

  METHOD get_state.
    rs_state = ms_request_data .
  ENDMETHOD.

  METHOD clone.
    DATA:
      lo_clone TYPE REF TO lcl_request.

    CREATE OBJECT lo_clone
      EXPORTING
        iv_entity_id = 0
        is_state = me-&gt;get_state( ).

    ro_clone = lo_clone.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Работа с прототипом
*&amp;---------------------------------------------------------------------*

START-OF-SELECTION.
  DATA:
    lo_request TYPE REF TO lcl_request,
    ls_state   TYPE lcl_request=&gt;ty_request_state,
    lo_clone   TYPE REF TO lcl_request.

  CREATE OBJECT lo_request
    EXPORTING
      iv_entity_id = 1.

  ls_state = lo_request-&gt;get_state( ).

  WRITE: / ls_state-entity_id, ls_state-request_data, ls_state-request_id.

  " Повторный вызов конструктора приведет к задержке при инициализации
  " воспользуемся методом клонирования

  lo_clone ?= lo_request-&gt;clone( ).

  ls_state = lo_clone-&gt;get_state( ).

  WRITE: / ls_state-entity_id, ls_state-request_data, ls_state-request_id.</pre><p>В примере вместо повторной инициализации объекта используется метод его клонирования с передачей состояния. Для упрощения инициализация происходит прямо в конструкторе (запрос лучше отправлять в отдельном методе, а конструктор оставить только для присвоения состояния).</p>
<p>В других языках программирования есть встроенные механизмы для копирования объектов, в ABAP такой механизм так же имеется, реализован через системный вызов (см. класс cl_os_state):</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;  Определение классов
*&amp;---------------------------------------------------------------------*

CLASS lcl_request DEFINITION INHERITING FROM cl_os_state.
  PUBLIC SECTION.
    ALIASES: clone FOR if_os_clone~clone.
    TYPES:
      BEGIN OF ty_request_state,
        request_id      TYPE i,
        entity_id       TYPE i,
        request_data    TYPE string,
      END OF ty_request_state.
    METHODS:
      constructor IMPORTING iv_entity_id TYPE i
                            iv_skip_init TYPE abap_bool OPTIONAL,
      get_state   RETURNING VALUE(rs_state) TYPE ty_request_state.
  PRIVATE SECTION.
    DATA:
      ms_request_data TYPE ty_request_state.
ENDCLASS.

CLASS lcl_request IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).

    CHECK iv_skip_init = abap_false.
    " Эмулируем вызов RFC
    WAIT UP TO 3 SECONDS.
    " В реальности было бы что-то вроде
    " CALL FUNCTION 'ZGET_DATA_FROM_RFC'
    " EXPORTING
    "   iv_entity_id = iv_entity_id
    " IMPORTING
    "   es_request_data = ms_request_data
    ms_request_data-entity_id = iv_entity_id.
    ms_request_data-request_data = 'Sample data'.
    ms_request_data-request_id = 1.
  ENDMETHOD.

  METHOD get_state.
    rs_state = ms_request_data.
  ENDMETHOD.

ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Работа с прототипом
*&amp;---------------------------------------------------------------------*

START-OF-SELECTION.
  DATA:
    lo_request TYPE REF TO lcl_request,
    ls_state   TYPE lcl_request=&gt;ty_request_state,
    lo_clone   TYPE REF TO lcl_request.

  CREATE OBJECT lo_request
    EXPORTING
      iv_entity_id = 1.

  ls_state = lo_request-&gt;get_state( ).

  WRITE: / ls_state-entity_id, ls_state-request_data, ls_state-request_id.

  " Повторный вызов конструктора приведет к задержке при инициализации
  " воспользуемся методом клонирования

  lo_clone ?= lo_request-&gt;clone( ).

  ls_state = lo_clone-&gt;get_state( ).

  WRITE: / ls_state-entity_id, ls_state-request_data, ls_state-request_id.</pre><p>&nbsp;</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/prototip/">Прототип (Prototype)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/prototip/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Строитель (Builder)</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/stroitel/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/stroitel/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 May 2016 08:50:36 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2747</guid>

					<description><![CDATA[<p>Метафора &#160; Метафора данного паттерна явно следует из его названия. Представьте ситуацию, когда на стройке работает прораб (Director) и строители (Builder’ы). Строители умеют выполнять некоторые работы, которые необходимы, например, для кладки стены: положить на фундамент гидроизоляцию, замешать раствор, выложить кладку из кирпича. Однако сам строитель не знает технологического процесса который необходимо выполнить для того чтобы [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/stroitel/">Строитель (Builder)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<h4>Метафора</h4>
<p>&nbsp;</p>
<p>Метафора данного паттерна явно следует из его названия. Представьте ситуацию, когда на стройке работает прораб (Director) и строители (Builder’ы). Строители умеют выполнять некоторые работы, которые необходимы, например, для кладки стены: положить на фундамент гидроизоляцию, замешать раствор, выложить кладку из кирпича. Однако сам строитель не знает технологического процесса который необходимо выполнить для того чтобы успешно построить стену. Для этого существует прораб, который благодаря своим знаниям и умениям строителя сможет организовать процесс создания стены. Кроме того, в нашем примере может быть ситуация, когда один строитель может строить одну стену, но совсем не понимает, как построить другую. Для этого начальник стройки (клиент) определяет каким строителем снабдить прораба для получения необходимого типа стены. В метафоре важно понимать, что процесс постройки любой стены унифицирован и имеет четко определенные шаги, а уже конкретный строитель знает, как реализовать эти шаги для создания нужного типа стены (продукта), а прораб контролирует выполнение шагов.</p>
<p>&nbsp;</p>
<p><span id="more-2747"></span></p>
<h4>Назначение</h4>
<p>&nbsp;</p>
<p>Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления. Паттерн подходит для ситуаций, когда процесс создания продукта является сложным и состоит из нескольких этапов, при этом одним клиентам нужны одни параметры создаваемого продукта, другим другие.</p>
<p>&nbsp;</p>
<h4>Диаграмма</h4>
<div id="attachment_2750" style="width: 763px" class="wp-caption aligncenter"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/3-Builder.png"><img aria-describedby="caption-attachment-2750" loading="lazy" class="size-full wp-image-2750" src="http://abap-blog.ru/wp-content/uploads/2016/05/3-Builder.png" alt="Строитель" width="753" height="344" srcset="https://abap-blog.ru/wp-content/uploads/2016/05/3-Builder.png 753w, https://abap-blog.ru/wp-content/uploads/2016/05/3-Builder-300x137.png 300w" sizes="(max-width: 753px) 100vw, 753px" /></a><p id="caption-attachment-2750" class="wp-caption-text">Строитель</p></div>
<p>&nbsp;</p>
<h4>Пример</h4>
<p>&nbsp;</p><pre class="urvanov-syntax-highlighter-plain-tag">PARAMETERS: p_list TYPE abap_bool RADIOBUTTON GROUP 1,
            p_gui  TYPE abap_bool RADIOBUTTON GROUP 1.

*&amp;---------------------------------------------------------------------*
*&amp;  Определение классов
*&amp;---------------------------------------------------------------------*

CLASS lcl_alv_builder DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS:
      setup_display_options ABSTRACT ,
      setup_functions ABSTRACT ,
      get_alv RETURNING value(ro_alv) TYPE REF TO cl_salv_table.
  PROTECTED SECTION.
    DATA:
      mo_alv TYPE REF TO cl_salv_table.
ENDCLASS.                    "lcl_alv_builder DEFINITION

CLASS lcl_list_alv_builder DEFINITION INHERITING FROM lcl_alv_builder.
  PUBLIC SECTION.
    METHODS:
      constructor IMPORTING ir_table TYPE REF TO data,
      setup_display_options REDEFINITION,
      setup_functions REDEFINITION.
ENDCLASS.                    "lcl_list_alv_builder DEFINITION

CLASS lcl_gui_alv_builder DEFINITION INHERITING FROM lcl_alv_builder.
  PUBLIC SECTION.
    METHODS:
      constructor IMPORTING ir_table TYPE REF TO data,
      setup_display_options REDEFINITION,
      setup_functions REDEFINITION.
ENDCLASS.                    "lcl_gui_alv_builder DEFINITION

CLASS lcl_alv_maker DEFINITION.
  PUBLIC SECTION.
    METHODS:
      constructor IMPORTING io_alv_builder TYPE REF TO lcl_alv_builder,
      construct_alv RETURNING VALUE(ro_alv) TYPE REF TO cl_salv_table.
  PRIVATE SECTION.
    DATA:
      mo_builder TYPE REF TO lcl_alv_builder.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Реализация классов
*&amp;---------------------------------------------------------------------*

CLASS lcl_alv_builder IMPLEMENTATION.
  METHOD get_alv.
    ro_alv = mo_alv.
  ENDMETHOD.                    "get_alv
ENDCLASS.                    "lcl_alv_builder IMPLEMENTATION

CLASS lcl_list_alv_builder IMPLEMENTATION.
  METHOD constructor.
    FIELD-SYMBOLS:
      &lt;lt_table&gt; TYPE table.

    super-&gt;constructor( ).

    ASSIGN ir_table-&gt;* TO &lt;lt_table&gt;.
    CHECK sy-subrc EQ 0.

    TRY.
        cl_salv_table=&gt;factory(
          EXPORTING
            list_display   = if_salv_c_bool_sap=&gt;true
          IMPORTING
            r_salv_table   = mo_alv
          CHANGING
            t_table        = &lt;lt_table&gt;
        ).
      CATCH cx_salv_msg.
    ENDTRY.
  ENDMETHOD.                    "constructor

  METHOD setup_display_options.
    " Определение настроек отображения специфичных для списка
  ENDMETHOD.                    "setup_display_options

  METHOD setup_functions.
    " Определение настроек функций для списка
  ENDMETHOD.                    "setup_functions

ENDCLASS.                    "lcl_list_alv_builder IMPLEMENTATION

CLASS lcl_gui_alv_builder IMPLEMENTATION.
  METHOD constructor.
    FIELD-SYMBOLS:
      &lt;lt_table&gt; TYPE table.

    super-&gt;constructor( ).

    ASSIGN ir_table-&gt;* TO &lt;lt_table&gt;.
    CHECK sy-subrc EQ 0.

    TRY.
        cl_salv_table=&gt;factory(
          EXPORTING
            list_display   = if_salv_c_bool_sap=&gt;false
          IMPORTING
            r_salv_table   = mo_alv
          CHANGING
            t_table        = &lt;lt_table&gt;
        ).
      CATCH cx_salv_msg.
    ENDTRY.
  ENDMETHOD.                    "constructor

  METHOD setup_display_options.
    " Определение настроек отображения специфичных для gui alv
  ENDMETHOD.                    "setup_display_options

  METHOD setup_functions.
    " Определение настроек функций для gui alv
  ENDMETHOD.                    "setup_functions
ENDCLASS.                    "lcl_gui_alv_builder IMPLEMENTATION

CLASS lcl_alv_maker IMPLEMENTATION.
  METHOD constructor.
    mo_builder = io_alv_builder.
  ENDMETHOD.

  METHOD construct_alv.
    mo_builder-&gt;setup_display_options( ).
    mo_builder-&gt;setup_functions( ).
    ro_alv = mo_builder-&gt;get_alv( ).
  ENDMETHOD.

ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Работа с объектами
*&amp;---------------------------------------------------------------------*
START-OF-SELECTION.
  DATA:
    lo_alv_maker    TYPE REF TO lcl_alv_maker,
    lo_alv_builder  TYPE REF TO lcl_alv_builder,
    lt_table        TYPE TABLE OF spfli,
    lr_table        TYPE REF TO data.

  SELECT * FROM spfli INTO CORRESPONDING FIELDS OF TABLE lt_table.
  GET REFERENCE OF lt_table INTO lr_table.

  CASE abap_true.
    WHEN p_list.
      CREATE OBJECT lo_alv_builder TYPE lcl_list_alv_builder EXPORTING ir_table = lr_table.
    WHEN p_gui.
      CREATE OBJECT lo_alv_builder TYPE lcl_gui_alv_builder EXPORTING ir_table = lr_table.
  ENDCASE.

  CREATE OBJECT lo_alv_maker EXPORTING io_alv_builder = lo_alv_builder.

  lo_alv_maker-&gt;construct_alv( )-&gt;display( ).</pre><p>В примере реализовано несколько классов строителей, которые создают либо ALV в виде списка, либо в виде грида. Управляет последовательностью операций по созданию ALV класс-директор – lcl_alv_maker. В зависимости от параметров с экрана выбора, класс-директор компонуется либо одним строителем, либо другим.</p>
<p>На практике очень часто используется упрощенная схема данного паттерна, т.к. возможность создания разнообразных продуктов нужна относительно редко, и возрастающая при этом сложность не всегда окупается.</p>
<p>Диаграмма упрощённой реализации:</p>
<div id="attachment_2752" style="width: 573px" class="wp-caption aligncenter"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/3.1-SimpleBuilder.png"><img aria-describedby="caption-attachment-2752" loading="lazy" class="wp-image-2752 size-full" src="http://abap-blog.ru/wp-content/uploads/2016/05/3.1-SimpleBuilder.png" alt="Упрощённый строитель" width="563" height="253" srcset="https://abap-blog.ru/wp-content/uploads/2016/05/3.1-SimpleBuilder.png 563w, https://abap-blog.ru/wp-content/uploads/2016/05/3.1-SimpleBuilder-300x135.png 300w" sizes="(max-width: 563px) 100vw, 563px" /></a><p id="caption-attachment-2752" class="wp-caption-text">Упрощённый строитель</p></div>
<p>&nbsp;</p>
<p>Пример:</p><pre class="urvanov-syntax-highlighter-plain-tag">CLASS lcl_product DEFINITION.
  PUBLIC SECTION.
    DATA:
      mv_header TYPE string,
      mv_footer TYPE string,
      mv_text   TYPE string.
    METHODS:
      write.
ENDCLASS.

CLASS lcl_product IMPLEMENTATION.
  METHOD write.
    WRITE: / 'HDR:', mv_header, 'FTR:', mv_footer, 'TXT:', mv_text.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_builder DEFINITION.
  PUBLIC SECTION.
    METHODS:
      init_product  RETURNING VALUE(ro_builder) TYPE REF TO lcl_builder,
      set_header    IMPORTING iv_header TYPE string RETURNING VALUE(ro_builder) TYPE REF TO lcl_builder,
      set_footer    IMPORTING iv_footer TYPE string RETURNING VALUE(ro_builder) TYPE REF TO lcl_builder,
      set_text      IMPORTING iv_text   TYPE string RETURNING VALUE(ro_builder) TYPE REF TO lcl_builder,
      get_product   RETURNING VALUE(ro_product) TYPE REF TO lcl_product.
  PRIVATE SECTION.
    DATA:
      mo_product TYPE REF TO lcl_product.
ENDCLASS.

CLASS lcl_builder IMPLEMENTATION.
  METHOD init_product.
    CREATE OBJECT mo_product.
    ro_builder = me.
  ENDMETHOD.

  METHOD set_header.
    IF mo_product IS NOT BOUND.
      init_product( ).
    ENDIF.

    mo_product-&gt;mv_header = iv_header.
    ro_builder = me.
  ENDMETHOD.

  METHOD set_footer.
    IF mo_product IS NOT BOUND.
      init_product( ).
    ENDIF.

    mo_product-&gt;mv_footer = iv_footer.
    ro_builder = me.
  ENDMETHOD.

  METHOD set_text.
    IF mo_product IS NOT BOUND.
      init_product( ).
    ENDIF.

    mo_product-&gt;mv_text = iv_text.
    ro_builder = me.
  ENDMETHOD.

  METHOD get_product.
    ro_product = mo_product.
  ENDMETHOD.

ENDCLASS.

START-OF-SELECTION.
  DATA: lo_product TYPE REF TO lcl_product,
        lo_builer  TYPE REF TO lcl_builder.

  CREATE OBJECT lo_builer.
  lo_product = lo_builer-&gt;set_footer( 'Footer1' )-&gt;set_header( 'Header 1' )-&gt;set_text( 'Text 1' )-&gt;get_product( ).
  lo_product-&gt;write( ).
  lo_product = lo_builer-&gt;init_product( )-&gt;set_footer( 'Footer2' )-&gt;set_header( 'Header 2' )-&gt;set_text( 'Text 2' )-&gt;get_product( ).
  lo_product-&gt;write( ).</pre><p>В данном примере мы предоставили клиенту интерфейс по созданию некоторого продукта, при этом клиент сам определяет каким образом его создать, какие операции использовать.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/stroitel/">Строитель (Builder)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/stroitel/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Фабричный метод (Factory method)</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/fabrichnyj-metod/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/fabrichnyj-metod/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 May 2016 08:43:12 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2740</guid>

					<description><![CDATA[<p>Назначение &#160; Паттерн решает задачу определения некоторого интерфейса по созданию класса, конкретную реализацию которого определяют дочерние классы, реализующие данный интерфейс. В отличие от абстрактной фабрики, фабричный метод оперирует созданием одного единственного объекта, а не семейства. Данный паттерн имеет несколько версий реализации, мы рассмотрим реализацию через статический метод в базовом классе. В такой реализации в статический [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/fabrichnyj-metod/">Фабричный метод (Factory method)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<h4>Назначение</h4>
<p>&nbsp;</p>
<p>Паттерн решает задачу определения некоторого интерфейса по созданию класса, конкретную реализацию которого определяют дочерние классы, реализующие данный интерфейс. В отличие от абстрактной фабрики, фабричный метод оперирует созданием одного единственного объекта, а не семейства.</p>
<p>Данный паттерн имеет несколько версий реализации, мы рассмотрим реализацию через статический метод в базовом классе. В такой реализации в статический метод поступают некоторые аргументы, на основе которых принимается решение о создании того или иного наследника базового класса.</p>
<p><span id="more-2740"></span></p>
<p>Преимущества:</p>
<ul>
<li>Избавляет от необходимости лишнего связывания клиентского кода с дочерними классами, т.е. место, где создаются наследники явно определено в статическом методе базового класса, а не скрыто где-то у клиента. Клиент, как и в случае с абстрактной фабрикой не завязан на конкретные реализации, а оперирует абстракцией.</li>
</ul>
<p>&nbsp;</p>
<h4>Диаграмма</h4>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div id="attachment_2744" style="width: 583px" class="wp-caption aligncenter"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/2-FactoryMethod.png"><img aria-describedby="caption-attachment-2744" loading="lazy" class="wp-image-2744 size-full" title="Фабричный метод" src="http://abap-blog.ru/wp-content/uploads/2016/05/2-FactoryMethod.png" alt="2-FactoryMethod" width="573" height="259" srcset="https://abap-blog.ru/wp-content/uploads/2016/05/2-FactoryMethod.png 573w, https://abap-blog.ru/wp-content/uploads/2016/05/2-FactoryMethod-300x136.png 300w" sizes="(max-width: 573px) 100vw, 573px" /></a><p id="caption-attachment-2744" class="wp-caption-text">Фабричный метод</p></div>
<p>&nbsp;</p>
<h4>Пример</h4>
<p>&nbsp;</p><pre class="urvanov-syntax-highlighter-plain-tag">PARAMETERS: p_type TYPE i.
*&amp;---------------------------------------------------------------------*
*&amp;  Определение классов
*&amp;---------------------------------------------------------------------*

CLASS lcl_base_writer DEFINITION.
  PUBLIC SECTION.
    TYPES:
      ty_report_type TYPE i.
    CONSTANTS:
      gc_report_pdf     TYPE ty_report_type VALUE 1,
      gc_report_write   TYPE ty_report_type VALUE 2,
      gc_report_alv     TYPE ty_report_type VALUE 3.
    CLASS-METHODS:
      get_writer importing iv_type type ty_report_type default gc_report_write returning value(ro_writer) TYPE REF TO lcl_base_writer.
    METHODS:
      write_data.
ENDCLASS.                    "lcl_base_writer DEFINITION

CLASS lcl_write_writer DEFINITION INHERITING FROM lcl_base_writer.
  PUBLIC SECTION.
    METHODS: write_data REDEFINITION.
ENDCLASS.                    "lcl_write_writer DEFINITION

CLASS lcl_alv_writer DEFINITION INHERITING FROM lcl_base_writer.
  PUBLIC SECTION.
    METHODS: write_data REDEFINITION.
ENDCLASS.                    "lcl_alv_writer DEFINITION

CLASS lcl_pdf_writer DEFINITION INHERITING FROM lcl_base_writer.
  PUBLIC SECTION.
    METHODS: write_data REDEFINITION.
ENDCLASS.                    "lcl_pdf_writer DEFINITION

*&amp;---------------------------------------------------------------------*
*&amp;  Реализация классов
*&amp;---------------------------------------------------------------------*

CLASS lcl_base_writer IMPLEMENTATION.
  METHOD get_writer.
    CASE iv_type.
      WHEN gc_report_pdf.
        CREATE OBJECT ro_writer TYPE lcl_pdf_writer.
      WHEN gc_report_write.
        CREATE OBJECT ro_writer TYPE lcl_write_writer.
      WHEN gc_report_alv.
        CREATE OBJECT ro_writer TYPE lcl_alv_writer.
      WHEN OTHERS.
        " RAISE EXCEPTION.
    ENDCASE.
  ENDMETHOD.                    "get_writer

  METHOD write_data.
    "RAISE EXCEPTION...
    WRITE: / 'Use factory method!'.
  ENDMETHOD.
ENDCLASS.                    "lcl_base_writer IMPLEMENTATION

CLASS lcl_pdf_writer IMPLEMENTATION.
  METHOD write_data.
    WRITE: / 'Write with pdf'.
  ENDMETHOD.                    "write_data
ENDCLASS.                    "lcl_pdf_writer IMPLEMENTATION

CLASS lcl_write_writer IMPLEMENTATION.
  METHOD write_data.
    WRITE: / 'Write with write'.
  ENDMETHOD.                    "write_data
ENDCLASS.                    "lcl_write_writer IMPLEMENTATION

CLASS lcl_alv_writer IMPLEMENTATION.
  METHOD write_data.
    WRITE: / 'Write with alv'.
  ENDMETHOD.                    "write_data
ENDCLASS.                    "lcl_alv_writer IMPLEMENTATION

*&amp;---------------------------------------------------------------------*
*&amp;  Реализация клиента
*&amp;---------------------------------------------------------------------*
START-OF-SELECTION.
  DATA: lo_writer TYPE REF TO lcl_base_writer.

  lo_writer = lcl_base_writer=&gt;get_writer( p_type ).
  lo_writer-&gt;write_data( ).</pre><p>Как видно у базового класса определен фабричный метод get_writer, который в зависимости от передаваемого в него типа будет создавать того или иного наследника. Клиент работает с абстракцией, и фабричный метод скрывает от него иерархию наследования.</p>
<p>В данном случае сделан один общий метод для получения инстанции, однако зачастую бывает <strong>лучше создать отдельные методы</strong>, чтобы не перегружать общий фабричный метод ненужными аргументами, которые могут потребоваться для создания одного наследника и не потребоваться для создания другого.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/fabrichnyj-metod/">Фабричный метод (Factory method)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/fabrichnyj-metod/feed/</wfw:commentRss>
			<slash:comments>16</slash:comments>
		
		
			</item>
		<item>
		<title>Абстрактная фабрика (Abstract factory)</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/abstraktnaya-fabrika/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/abstraktnaya-fabrika/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 May 2016 08:34:30 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2733</guid>

					<description><![CDATA[<p>Метафора &#160; Метафора паттерна описывается его названием. Когда вам необходима бутылка колы, вам не нужно при этом знать, как их производят на фабрике. Достаточно сказать «дайте мне колы», а фабрика уже возвращает вам бутылку. Каким образом создать эту бутылку остается полностью на совести фабрики. Предназначение фабрики в том, чтобы можно было бы в любой момент [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/abstraktnaya-fabrika/">Абстрактная фабрика (Abstract factory)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<h4>Метафора</h4>
<p>&nbsp;</p>
<p>Метафора паттерна описывается его названием. Когда вам необходима бутылка колы, вам не нужно при этом знать, как их производят на фабрике. Достаточно сказать «дайте мне колы», а фабрика уже возвращает вам бутылку. Каким образом создать эту бутылку остается полностью на совести фабрики. Предназначение фабрики в том, чтобы можно было бы в любой момент времени полностью изменить процесс создания продукта так, чтобы клиент ничего об этом не знал и запрашивал бы продукт, как и раньше. Пример: клиент хочет прохладительный напиток, при этом снабдив клиента одной или другой фабрикой, мы сможем переключать его потребность на бутылку колы или спрайта.</p>
<p>Как правило, одна фабрика занимается «производством» только одного рода «продуктов». Не рекомендуется «фабрику колы» создавать с учетом производства автомобильных покрышек. Как и в жизни, паттерн «фабрика» часто создается «одиночкой».</p>
<p>&nbsp;</p>
<p><span id="more-2733"></span></p>
<h4>Назначение</h4>
<p>&nbsp;</p>
<p>Паттерн применяется, когда необходимо получать семейство <strong>взаимосвязанных</strong> или <strong>родственных</strong> объектов не специфицируя их конкретных классов. Таким образом, в интерфейсах фабрик не указываются конкретные классы, вместо этого указываются абстрактные классы, из которых уже наследуются конкретные, каждая фабрика решает какой конкретный класс из семейства необходимо ей создать.</p>
<p>Паттерн не рекомендуется использовать:</p>
<ul>
<li>Когда вектор изменения направлен на добавление новых продуктов, т.к. добавляя один метод для создания некоторого продукта, вам необходимо продублировать его на все фабрики;</li>
<li>Для создания не связанных объектов: бутылка колы и автомобиль, т.к. это усложняет понимание необходимости в такой фабрике.</li>
</ul>
<p>Плюсы:</p>
<ul>
<li>Фабрика гарантирует сочетаемость продуктов, так в бутылке из-под coca-cola вы не получите машинное масло (тут бутылка колы рассматривается как набор отдельных объектов: пластиковый контейнер и его наполнение);</li>
<li>Упрощение взаимозаменяемости семейства продуктов, Вы можете подменить одну фабрику на другую, при этом клиент будет оперировать новым семейством продуктов, т.к. внутри используются абстрактные интерфейсы. Конкретные классы изолируются внутри фабрик, клиенту о них знать не нужно;</li>
<li>Возможность расширить систему на новые фабрики не нарушая OCP принцип (SOLID).</li>
</ul>
<p>&nbsp;</p>
<h4>Диаграмма</h4>
<p>&nbsp;</p>
<div id="attachment_2731" style="width: 793px" class="wp-caption alignnone"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/1-AbstractFactory.png"><img aria-describedby="caption-attachment-2731" loading="lazy" class="size-full wp-image-2731" src="http://abap-blog.ru/wp-content/uploads/2016/05/1-AbstractFactory.png" alt="Абстрактная фабрика" width="783" height="424" srcset="https://abap-blog.ru/wp-content/uploads/2016/05/1-AbstractFactory.png 783w, https://abap-blog.ru/wp-content/uploads/2016/05/1-AbstractFactory-300x162.png 300w, https://abap-blog.ru/wp-content/uploads/2016/05/1-AbstractFactory-768x416.png 768w" sizes="(max-width: 783px) 100vw, 783px" /></a><p id="caption-attachment-2731" class="wp-caption-text">Абстрактная фабрика</p></div>
<p>На данном рисунке мы видим некоторый класс Client, который работает с абстрактной фабрикой. Все конкретные фабрики наследуются от абстрактной фабрики (AbstractFactory), абстрактная фабрика создает некие абстрактные продукты. Конкретные фабрики решают, какие конкретные продукты они будут создавать. Клиент во время исполнения снабжается той или иной реализацией абстрактной фабрики.</p>
<p>&nbsp;</p>
<h4>Пример</h4>
<p>&nbsp;</p>
<p>В данном примере и далее по ходу статьи нет отдельного класса клиента, вся работа с шаблонами происходит непосредственно в программе:</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;  Описание абстракций
*&amp;---------------------------------------------------------------------*

CLASS lcl_abstract_product_a DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS: run ABSTRACT.
ENDCLASS.

CLASS lcl_abstract_product_b DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS: run ABSTRACT.
ENDCLASS.

CLASS lcl_abstract_factory DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS:
      create_product_a ABSTRACT RETURNING VALUE(ro_product_a) TYPE REF TO lcl_abstract_product_a,
      create_product_b ABSTRACT RETURNING VALUE(ro_product_b) TYPE REF TO lcl_abstract_product_b.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Описание конкретных реализаций - продуктов
*&amp;---------------------------------------------------------------------*

CLASS lcl_concrete_product_a_1 DEFINITION INHERITING FROM lcl_abstract_product_a.
  PUBLIC SECTION.
    METHODS run REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_product_a_2 DEFINITION INHERITING FROM lcl_abstract_product_a.
  PUBLIC SECTION.
    METHODS run REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_product_b_1 DEFINITION INHERITING FROM lcl_abstract_product_b.
  PUBLIC SECTION.
    METHODS run REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_product_b_2 DEFINITION INHERITING FROM lcl_abstract_product_b.
  PUBLIC SECTION.
    METHODS run REDEFINITION.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Описание конкретных реализаций - фабрик
*&amp;---------------------------------------------------------------------*

CLASS lcl_concrete_factory_1 DEFINITION INHERITING FROM lcl_abstract_factory.
  PUBLIC SECTION.
    METHODS:
      create_product_a REDEFINITION,
      create_product_b REDEFINITION.
ENDCLASS.

CLASS lcl_concrete_factory_2 DEFINITION INHERITING FROM lcl_abstract_factory.
  PUBLIC SECTION.
    METHODS:
      create_product_a REDEFINITION,
      create_product_b REDEFINITION.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Реализация конкретных продуктов
*&amp;---------------------------------------------------------------------*

CLASS lcl_concrete_product_a_1 IMPLEMENTATION.
  METHOD run.
    WRITE: / 'Run with product A-1'.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_concrete_product_a_2 IMPLEMENTATION.
  METHOD run.
    WRITE: / 'Run with product A-2'.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_concrete_product_b_1 IMPLEMENTATION.
  METHOD run.
    WRITE: / 'Run with product B-1'.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_concrete_product_b_2 IMPLEMENTATION.
  METHOD run.
    WRITE: / 'Run with product B-2'.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Реализация конкретных фабрик
*&amp;---------------------------------------------------------------------*

CLASS lcl_concrete_factory_1 IMPLEMENTATION.
  METHOD create_product_a.
    CREATE OBJECT ro_product_a TYPE lcl_concrete_product_a_1.
  ENDMETHOD.

  METHOD create_product_b.
    CREATE OBJECT ro_product_b TYPE lcl_concrete_product_b_1.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_concrete_factory_2 IMPLEMENTATION.
  METHOD create_product_a.
    CREATE OBJECT ro_product_a TYPE lcl_concrete_product_a_2.
  ENDMETHOD.

  METHOD create_product_b.
    CREATE OBJECT ro_product_b TYPE lcl_concrete_product_b_2.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Работа с фабриками
*&amp;---------------------------------------------------------------------*

START-OF-SELECTION.
  DATA:
    lo_factory   TYPE REF TO lcl_abstract_factory,
    lo_product_a TYPE REF TO lcl_abstract_product_a,
    lo_product_b TYPE REF TO lcl_abstract_product_b.

  CREATE OBJECT lo_factory TYPE lcl_concrete_factory_1.
  lo_product_a = lo_factory-&gt;create_product_a( ).
  lo_product_b = lo_factory-&gt;create_product_b( ).

  lo_product_a-&gt;run( ).
  lo_product_b-&gt;run( ).

  CREATE OBJECT lo_factory TYPE lcl_concrete_factory_2.
  lo_product_a = lo_factory-&gt;create_product_a( ).
  lo_product_b = lo_factory-&gt;create_product_b( ).

  lo_product_a-&gt;run( ).
  lo_product_b-&gt;run( ).</pre><p>В нашем примере фабрика создается непосредственно в коде программы, однако в реальных программах заранее определить нужную фабрику может быть невозможно. Решается это за счёт динамического создания фабрики, класс которой определен из настроек, где-нибудь в кластере ракурсов, при этом настройка эта считывается в еще одном классе, который служит своего рода фабрикой фабрик.</p>
<h4>Видео</h4>
<p>&nbsp;</p>
<div class="arve aligncenter" data-mode="normal" data-oembed="1" data-provider="youtube" id="arve-youtube-zqmhkouw-vu618a04c3f0464348968604" style="max-width:900px;" itemscope itemtype="http://schema.org/VideoObject">
<span class="arve-inner">
<span class="arve-embed arve-embed--has-aspect-ratio arve-embed--16by9">
<meta itemprop="embedURL" content="https://www.youtube-nocookie.com/embed/zQMhKouW-VU?feature=oembed&amp;iv_load_policy=3&amp;modestbranding=1&amp;rel=0&amp;autohide=1&amp;playsinline=0&amp;autoplay=0">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen class="arve-iframe fitvidsignore" data-arve="arve-youtube-zqmhkouw-vu618a04c3f0464348968604" data-src-no-ap="https://www.youtube-nocookie.com/embed/zQMhKouW-VU?feature=oembed&amp;iv_load_policy=3&amp;modestbranding=1&amp;rel=0&amp;autohide=1&amp;playsinline=0&amp;autoplay=0" frameborder="0" height="506.25" sandbox="allow-scripts allow-same-origin allow-presentation allow-popups allow-popups-to-escape-sandbox" scrolling="no" src="https://www.youtube-nocookie.com/embed/zQMhKouW-VU?feature=oembed&#038;iv_load_policy=3&#038;modestbranding=1&#038;rel=0&#038;autohide=1&#038;playsinline=0&#038;autoplay=0" width="900"></iframe>

</span>

</span>

</div><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/abstraktnaya-fabrika/">Абстрактная фабрика (Abstract factory)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/abstraktnaya-fabrika/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Итератор (Iterator)</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/iterator-iterator/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/iterator-iterator/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 May 2016 08:00:52 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2861</guid>

					<description><![CDATA[<p>Метафора &#160; Все помнят школьное «на первый второй рассчитайся!»? Вот именно в этот момент шеренга вашего класса и являлась реализацией паттерна «итератор», хотя в программировании это конечно более функциональное понятие, но суть примерно та же. «Итератор» предоставляет правила доступа к списку каких-либо объектов независимо от того, что это за объекты. То есть не важно, какой [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/iterator-iterator/">Итератор (Iterator)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<h4>Метафора</h4>
<p>&nbsp;</p>
<p>Все помнят школьное «на первый второй рассчитайся!»? Вот именно в этот момент шеренга вашего класса и являлась реализацией паттерна «итератор», хотя в программировании это конечно более функциональное понятие, но суть примерно та же. «Итератор» предоставляет <strong>правила доступа</strong> к <strong>списку</strong> каких-либо объектов независимо от того, что это за объекты. То есть не важно, какой именно класс построен и из каких учеников, должны быть общие правила подсчета и обращения как каждому ученику по списку, вроде «13-ый, выйти из строя». Ссылки, которые вы видите на многих сайтах для переходов по страницам, вроде «следующая», «предыдущая», «в начало» и т.п. по своей сути также являются доступом «итератору» который отвечает за страницы сайта.</p>
<p>&nbsp;</p>
<p><span id="more-2861"></span></p>
<h4>Назначение</h4>
<p>&nbsp;</p>
<p>Паттерн предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления. Итератор предоставляет абстрактный интерфейс для доступа к содержимому составных объектов, не раскрывая клиентам их внутреннюю структуру.</p>
<p>Преимущества:</p>
<ul>
<li>Поддерживает различные способы перебора агрегата, одновременно могут быть активны несколько переборов.</li>
</ul>
<p>&nbsp;</p>
<h4>Диаграмма</h4>
<p>&nbsp;</p>
<div id="attachment_2862" style="width: 703px" class="wp-caption aligncenter"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/Iterator.png"><img aria-describedby="caption-attachment-2862" loading="lazy" class="size-full wp-image-2862" src="http://abap-blog.ru/wp-content/uploads/2016/05/Iterator.png" alt="Итератор" width="693" height="297" srcset="https://abap-blog.ru/wp-content/uploads/2016/05/Iterator.png 693w, https://abap-blog.ru/wp-content/uploads/2016/05/Iterator-300x129.png 300w" sizes="(max-width: 693px) 100vw, 693px" /></a><p id="caption-attachment-2862" class="wp-caption-text">Итератор</p></div>
<p>&nbsp;</p>
<p>Клиент работает с абстрактным интерфейсом итератора, реализацию которого, получает от конкретного составного объекта. Конкретный итератор следит за текущей позицией в конкретном агрегате.</p>
<p>&nbsp;</p>
<h4>Пример</h4>
<p>&nbsp;</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;  Определение объектов / интерфейсов
*&amp;---------------------------------------------------------------------*

INTERFACE lif_iterator.
  METHODS:
    first RETURNING VALUE(rs_spfli) TYPE spfli,
    next RETURNING VALUE(rs_spfli) TYPE spfli,
    is_done RETURNING VALUE(rv_done) TYPE abap_bool,
    current RETURNING VALUE(rs_spfli) TYPE spfli.
ENDINTERFACE.

CLASS lcl_aggregate DEFINITION FRIENDS lif_iterator.
  PUBLIC SECTION.
    METHODS: create_iterator RETURNING VALUE(ro_iterator) TYPE REF TO lif_iterator,
             constructor.
  PRIVATE SECTION.
    DATA:
      mt_data TYPE STANDARD TABLE OF spfli.
ENDCLASS.

CLASS lcl_iterator DEFINITION.
  PUBLIC SECTION.
    INTERFACES: lif_iterator.
    ALIASES: first FOR lif_iterator~first,
             next  FOR lif_iterator~next,
             is_done FOR lif_iterator~is_done,
             current FOR lif_iterator~current.
    METHODS:
      constructor IMPORTING io_aggregate TYPE REF TO lcl_aggregate.
 PRIVATE SECTION.
  DATA:
    mv_position TYPE i,
    mv_lines    TYPE i,
    mo_aggregate TYPE REF TO lcl_aggregate.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Реализация
*&amp;---------------------------------------------------------------------*

CLASS lcl_aggregate IMPLEMENTATION.
  METHOD constructor.
    SELECT * FROM spfli INTO CORRESPONDING FIELDS OF TABLE mt_data.
  ENDMETHOD.

  METHOD create_iterator.
    CREATE OBJECT ro_iterator TYPE lcl_iterator
      EXPORTING
        io_aggregate = me.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_iterator IMPLEMENTATION.
  METHOD constructor.
    mo_aggregate = io_aggregate.
    mv_lines = lines( mo_aggregate-&gt;mt_data ).
    mv_position = 0.
  ENDMETHOD.

  METHOD first.
    mv_position = 1.

    READ TABLE mo_aggregate-&gt;mt_data INDEX mv_position INTO rs_spfli.
  ENDMETHOD.

  METHOD next.
    mv_position = mv_position + 1.

    IF mv_position &gt; mv_lines.
      mv_position = mv_position - 1.
      RETURN.
    ENDIF.

    READ TABLE mo_aggregate-&gt;mt_data INDEX mv_position INTO rs_spfli.
  ENDMETHOD.

  METHOD is_done.
    IF ( mv_position + 1 ) &gt; mv_lines.
      rv_done = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD current.
    READ TABLE mo_aggregate-&gt;mt_data INDEX mv_position INTO rs_spfli.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Работа с шаблоном
*&amp;---------------------------------------------------------------------*

START-OF-SELECTION.
  DATA:
    lo_aggregate TYPE REF TO lcl_aggregate,
    lo_iterator  TYPE REF TO lif_iterator,
    ls_spfli     TYPE spfli.

  CREATE OBJECT lo_aggregate.
  lo_iterator = lo_aggregate-&gt;create_iterator( ).

  WHILE lo_iterator-&gt;is_done( ) &lt;&gt; abap_true.
    ls_spfli = lo_iterator-&gt;next( ).
    WRITE: / sy-index, ls_spfli-connid, ls_spfli-carrid.
  ENDWHILE.</pre><p>В данном примере мы сделали простейший итератор по таблице из объекта lcl_aggregate. Последовательность доступа к таблице относительно текущей позиции в итераторе.</p>
<p>Итераторы широко используются в библиотеках работы с XML, например, в iXML для обхода DOM:</p><pre class="urvanov-syntax-highlighter-plain-tag">CLASS ixml_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.

CLASS ixml_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl_demo_output=&gt;new(
      )-&gt;begin_section( `XML-Data` ).
    DATA(xml) =
     `&lt;?xml version="1.0"?&gt;` &amp;&amp;
     `&lt;order number="4711"` &amp;&amp;
     ` xmlns:demo="http://www.sap.com/abapdemos"&gt;` &amp;&amp;
     `&lt;!-- Head and body of order --&gt;` &amp;&amp;
     ` &lt;demo:head&gt;` &amp;&amp;
     ` &lt;demo:status&gt;confirmed&lt;/demo:status&gt;` &amp;&amp;
     ` &lt;demo:date format="mm-dd-yyyy"&gt;07-19-2012&lt;/demo:date&gt;` &amp;&amp;
     ` &lt;/demo:head&gt;` &amp;&amp;
     ` &lt;demo:body&gt;`  &amp;&amp;
     ` &lt;demo:item units="2" price="17.00"&gt;Part No. 0110&lt;/demo:item&gt;` &amp;&amp;
     ` &lt;demo:item units="1" price="10.50"&gt;Part No. 1609&lt;/demo:item&gt;` &amp;&amp;
     ` &lt;demo:item units="5" price="12.30"&gt;Part No. 1710&lt;/demo:item&gt;` &amp;&amp;
     ` &lt;/demo:body&gt;` &amp;&amp;
     `&lt;/order&gt;`.
    out-&gt;write_xml( xml ).

    out-&gt;next_section( `XML-Document in DOM-Format` ).
    TYPES: BEGIN OF t_node,
            gid     TYPE i,
            type    TYPE i,
            prefix  TYPE string,
            name    TYPE string,
            value   TYPE string,
          END OF t_node.
    DATA node_tab TYPE STANDARD TABLE OF t_node.
    DATA(ixml)          = cl_ixml=&gt;create( ).
    DATA(document)      = ixml-&gt;create_document( ).
    TRY.
        CALL TRANSFORMATION id SOURCE XML xml
                               RESULT XML document.
      CATCH cx_transformation_error.
        RETURN.
    ENDTRY.
    DATA(iterator) = document-&gt;create_iterator( ).
    DO.
      DATA(node) = iterator-&gt;get_next( ).
      IF node IS INITIAL.
        EXIT.
      ENDIF.
      APPEND VALUE #(
        gid     = node-&gt;get_gid( )
        type    = node-&gt;get_type( )
        prefix  = node-&gt;get_namespace_prefix( )
        name    = node-&gt;get_name( )
        value   = node-&gt;get_value( ) ) TO node_tab.
    ENDDO.
    out-&gt;write_data( node_tab ).

    TYPES: BEGIN OF t_attribute,
             name  TYPE string,
             value TYPE string,
           END OF t_attribute.
    DATA attribute_tab TYPE STANDARD TABLE OF t_attribute.
    iterator-&gt;reset( ).
    DO.
      node = iterator-&gt;get_next( ).
      IF node IS INITIAL.
        EXIT.
      ENDIF.
      DATA(attributes) = node-&gt;get_attributes( ).
      IF attributes IS INITIAL OR attributes-&gt;get_length( ) = 0.
        CONTINUE.
      ENDIF.
      CLEAR attribute_tab.
      DO.
        DATA(attribute) = attributes-&gt;get_item( sy-index - 1 ).
        IF attribute IS INITIAL.
          EXIT.
        ENDIF.
        APPEND VALUE #(
          name  = attribute-&gt;get_name( )
          value = attribute-&gt;get_value( ) ) TO attribute_tab.
      ENDDO.
      out-&gt;begin_section( |Attributes of GID { node-&gt;get_gid( ) }|
        )-&gt;write_data( attribute_tab
        )-&gt;end_section( ).
    ENDDO.

    out-&gt;display( ).
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  ixml_demo=&gt;main( ).</pre><p>Еще один пример итератора из стандарта &#8212; cl_object_collection:</p><pre class="urvanov-syntax-highlighter-plain-tag">data: lv_result TYPE float.
  data(lo_container) = new cl_object_collection( ).
  data(lo_circle) = new zcl_circle( 1 ).
  lo_container-&gt;add( lo_circle ).

  data(lo_circle2) = new zcl_circle( 1 ).
  lo_container-&gt;add( lo_circle2 ).

  data(lo_rectangle) = new zcl_rectangle( iv_width = 1 iv_height = 2 ).
  lo_container-&gt;add( lo_rectangle ).

  data(lo_iterator) = lo_container-&gt;get_iterator( ).

  WHILE lo_iterator-&gt;has_next( ).
    data(lo_shape) = cast ZIF_SHAPE( lo_iterator-&gt;get_next( ) ).
    lv_result = lv_result + lo_shape-&gt;get_area( ).
  ENDWHILE.</pre><p>&nbsp;</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/iterator-iterator/">Итератор (Iterator)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/iterator-iterator/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Посетитель (Visitor)</title>
		<link>https://abap-blog.ru/osnovy-abap/oop/posetitel-visitor/</link>
					<comments>https://abap-blog.ru/osnovy-abap/oop/posetitel-visitor/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 May 2016 08:00:51 +0000</pubDate>
				<category><![CDATA[ABAP Objects]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=2867</guid>

					<description><![CDATA[<p>Метафора &#160; Данный паттерн можно сравнить с прохождением обследования в больнице. Однако «посетителем» в терминах паттернов здесь будут сами врачи. Чтобы было понятнее: у нас есть больной, которого требуется обследовать и полечить, но так как за разные обследования отвечают разные врачи, то мы просто присылаем к больному врачей в качестве «посетителей». Правило взаимодействия для больного [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/posetitel-visitor/">Посетитель (Visitor)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<h4>Метафора</h4>
<p>&nbsp;</p>
<p>Данный паттерн можно сравнить с прохождением обследования в больнице. Однако «посетителем» в терминах паттернов здесь будут сами врачи. Чтобы было понятнее: у нас есть больной, которого требуется обследовать и полечить, но так как за разные обследования отвечают разные врачи, то мы просто присылаем к больному врачей в качестве «посетителей». Правило взаимодействия для больного очень простое «пригласите врача (посетителя) чтобы он сделал свою работу», а врач («посетитель») приходит, обследует и делает всё необходимое. Таким образом, следуя простым правилам можно использовать врачей для разных больных по одним и тем же алгоритмам. Как уже было сказано, паттерном «посетитель» в данном случае является врач, который может одинаково обслуживать разные объекты (больных) если его позовут.</p>
<p>&nbsp;</p>
<p><span id="more-2867"></span></p>
<h4>Назначение</h4>
<p>&nbsp;</p>
<p>Применяя паттерн посетитель, мы можем добавить операции над некоторыми объектами (иерархией объектов), не загрязняя их код, т.е. не расширяя классы.</p>
<p>В классическом представлении GoF, посетитель добавляет операции к некоторой иерархии классов, где в зависимости от типа операции могут отличаться. Однако посетитель может быть применён и не к связанным иерархией классам.</p>
<p>Преимущества:</p>
<ul>
<li>Упрощается добавление новых операций, объединяет родственные операции в классе &#171;Посетитель&#187;.</li>
</ul>
<p>Недостатки:</p>
<ul>
<li>Бизнес логика размазывается между классами иерархии и классами посетителей (нарушается принцип Information Expert из GRASP),</li>
<li>Усложнение структуры кода,</li>
<li>Если базовый класс посетителя реализует интерфейс с указанием конкретного типа элемента из иерархии, при добавлении нового элемента в иерархию будет затруднительным, т.к. потребует модификации посетителей.</li>
</ul>
<p>&nbsp;</p>
<h4>Диаграмма</h4>
<p>&nbsp;</p>
<div id="attachment_2868" style="width: 813px" class="wp-caption aligncenter"><a href="http://abap-blog.ru/wp-content/uploads/2016/05/visitor.png"><img aria-describedby="caption-attachment-2868" loading="lazy" class="size-full wp-image-2868" src="http://abap-blog.ru/wp-content/uploads/2016/05/visitor.png" alt="Посетитель" width="803" height="453" srcset="https://abap-blog.ru/wp-content/uploads/2016/05/visitor.png 803w, https://abap-blog.ru/wp-content/uploads/2016/05/visitor-300x169.png 300w, https://abap-blog.ru/wp-content/uploads/2016/05/visitor-768x433.png 768w" sizes="(max-width: 803px) 100vw, 803px" /></a><p id="caption-attachment-2868" class="wp-caption-text">Посетитель</p></div>
<p>&nbsp;</p>
<p>Некоторая иерархия объектов Element реализует интерфейс с методом Accept, который в свою очередь принимает на вход элемент с интерфейсом Visitor. Внутри метода Accept вызывается метод visit для конкретного типа элемента (VisitElementOne или VisitElementTwo). Передавая тот или иной Visitor, мы тем самым можем выполнять над объектами Element разные операции, не расширяя при этом их интерфейс. Если бы ABAP умел поддерживать перегрузку методов, внутри элементов можно было бы сделать один вызов метода visit (v.Visit(me)), а его реализацию под тот или иной тип объекта уже реализовывать в конкретном посетителе.</p>
<p>&nbsp;</p>
<h4>Пример</h4>
<p>&nbsp;</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;  Определение и описание классов
*&amp;---------------------------------------------------------------------*

CLASS lcl_element DEFINITION DEFERRED.

CLASS lcl_visitor DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS:
      visit ABSTRACT IMPORTING io_element TYPE REF TO lcl_element.
ENDCLASS.

CLASS lcl_element DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS:
      accept IMPORTING io_visitor TYPE REF TO lcl_visitor.
ENDCLASS.

CLASS lcl_element IMPLEMENTATION.
  METHOD accept.
    io_visitor-&gt;visit( me ).
  ENDMETHOD.
ENDCLASS.

CLASS lcl_element_one DEFINITION INHERITING FROM lcl_element.
  PUBLIC SECTION.
    METHODS:
      operationA.
ENDCLASS.

CLASS lcl_element_one IMPLEMENTATION.
  METHOD operationA.
    WRITE: / 'Operation Element One'.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_element_two DEFINITION INHERITING FROM lcl_element.
  PUBLIC SECTION.
    METHODS:
      operationB.
ENDCLASS.

CLASS lcl_element_two IMPLEMENTATION.
  METHOD operationB.
    WRITE: / 'Operation Element Two'.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_visitor_one DEFINITION INHERITING FROM lcl_visitor.
  PUBLIC SECTION.
    METHODS:
      visit REDEFINITION.
ENDCLASS.

CLASS lcl_visitor_one IMPLEMENTATION.
  METHOD visit.
    DATA: lo_element_one TYPE REF TO lcl_element_one.

    TRY.
      lo_element_one ?= io_element.
      lo_element_one-&gt;operationa( ).
    CATCH cx_root.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_visitor_two DEFINITION INHERITING FROM lcl_visitor.
  PUBLIC SECTION.
    METHODS:
      visit REDEFINITION.
ENDCLASS.

CLASS lcl_visitor_two IMPLEMENTATION.
  METHOD visit.
    DATA: lo_element_two TYPE REF TO lcl_element_two.

    TRY.
      lo_element_two ?= io_element.
      lo_element_two-&gt;operationb( ).
    CATCH cx_sy_move_cast_error.
      RETURN.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_structure DEFINITION INHERITING FROM lcl_element.
  PUBLIC SECTION.
    METHODS:
      add_element IMPORTING io_element TYPE REF TO lcl_element,
      accept REDEFINITION.
  PRIVATE SECTION.
    DATA:
      mt_elements TYPE STANDARD TABLE OF REF TO lcl_element.
ENDCLASS.

CLASS lcl_structure IMPLEMENTATION.
  METHOD add_element.
    APPEND io_element TO mt_elements.
  ENDMETHOD.

  METHOD accept.
    DATA:
      lo_element TYPE REF TO lcl_element.

    LOOP AT mt_elements INTO lo_element.
      io_visitor-&gt;visit( lo_element ).
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Работка с объектами шаблона
*&amp;---------------------------------------------------------------------*
START-OF-SELECTION.
  DATA:
    lo_structure TYPE REF TO lcl_structure,
    lo_el_one    TYPE REF TO lcl_element_one,
    lo_el_two    TYPE REF TO lcl_element_two,
    lo_vis_one   TYPE REF TO lcl_visitor_one,
    lo_vis_two   TYPE REF TO lcl_visitor_two.

  CREATE OBJECT lo_structure.
  CREATE OBJECT lo_el_one.
  CREATE OBJECT lo_el_two.
  " Операция над lcl_element_one
  CREATE OBJECT lo_vis_one.
  " Операция над lcl_element_two
  CREATE OBJECT lo_vis_two.

  lo_structure-&gt;add_element( lo_el_one ).
  lo_structure-&gt;add_element( lo_el_two ).

  lo_structure-&gt;accept( lo_vis_one ).
  lo_structure-&gt;accept( lo_vis_two ).</pre><p>В нашем примере мы создали двух посетителей, которые выполняют определённые операции над объектами. Каждая отдельная операция свойственна только конкретному типу элемента, соответственно нагружать общую иерархию и выносить это поведение (OperationA, OperationB) на верхний уровень иерархии не имеет смысла.</p>
<p>Так же мы не завязываемся на конкретные типы в интерфейсе посетителя, а оперируем абстракцией, что не столь оптимально, но зато нам не потребуется перестраивать интерфейс посетителя при добавлении в иерархию элементов нового класса.</p>
<p>Еще один пример:</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;  Определение и описание классов
*&amp;---------------------------------------------------------------------*

CLASS lcl_element DEFINITION DEFERRED.

CLASS lcl_visitor DEFINITION ABSTRACT.
  PUBLIC SECTION.
    DATA:
      mv_cost TYPE decfloat34.
    METHODS:
      visit ABSTRACT IMPORTING io_element TYPE REF TO lcl_element.
ENDCLASS.

CLASS lcl_element DEFINITION ABSTRACT.
  PUBLIC SECTION.
    DATA:
      mv_cost TYPE decfloat34.
    METHODS:
      constructor IMPORTING iv_cost TYPE decfloat34,
      accept IMPORTING io_visitor TYPE REF TO lcl_visitor.
ENDCLASS.

CLASS lcl_element IMPLEMENTATION.
  METHOD accept.
    io_visitor-&gt;visit( me ).
  ENDMETHOD.

  METHOD constructor.
    mv_cost = iv_cost.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_element_one DEFINITION INHERITING FROM lcl_element.
ENDCLASS.

CLASS lcl_element_one IMPLEMENTATION.
ENDCLASS.

CLASS lcl_element_two DEFINITION INHERITING FROM lcl_element.
ENDCLASS.

CLASS lcl_element_two IMPLEMENTATION.
ENDCLASS.

CLASS lcl_visitor_one DEFINITION INHERITING FROM lcl_visitor.
  PUBLIC SECTION.
    METHODS:
      visit REDEFINITION.
ENDCLASS.

CLASS lcl_visitor_one IMPLEMENTATION.
  METHOD visit.
    mv_cost = mv_cost + io_element-&gt;mv_cost.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_visitor_two DEFINITION INHERITING FROM lcl_visitor.
  PUBLIC SECTION.
    METHODS:
      visit REDEFINITION.
ENDCLASS.

CLASS lcl_visitor_two IMPLEMENTATION.
  METHOD visit.
    mv_cost = mv_cost + io_element-&gt;mv_cost * -1.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_structure DEFINITION.
  PUBLIC SECTION.
    METHODS:
      add_element IMPORTING io_element TYPE REF TO lcl_element,
      calculate_cost IMPORTING io_visitor TYPE REF TO lcl_visitor.
  PRIVATE SECTION.
    DATA:
      mt_elements TYPE STANDARD TABLE OF REF TO lcl_element.
ENDCLASS.

CLASS lcl_structure IMPLEMENTATION.
  METHOD add_element.
    APPEND io_element TO mt_elements.
  ENDMETHOD.

  METHOD calculate_cost.
    DATA:
      lo_element TYPE REF TO lcl_element.

    LOOP AT mt_elements INTO lo_element.
      io_visitor-&gt;visit( lo_element ).
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.

*&amp;---------------------------------------------------------------------*
*&amp;  Работка с объектами шаблона
*&amp;---------------------------------------------------------------------*
START-OF-SELECTION.
  DATA:
    lo_structure TYPE REF TO lcl_structure,
    lo_el_one    TYPE REF TO lcl_element_one,
    lo_el_two    TYPE REF TO lcl_element_two,
    lo_vis_one   TYPE REF TO lcl_visitor_one,
    lo_vis_two   TYPE REF TO lcl_visitor_two.

  CREATE OBJECT lo_structure.

  CREATE OBJECT lo_el_one
    EXPORTING
      iv_cost = 100.

  lo_structure-&gt;add_element( lo_el_one ).

  CREATE OBJECT lo_el_two
    EXPORTING
      iv_cost = 200.

  lo_structure-&gt;add_element( lo_el_two ).

  " Подсчёт прямой стоимости
  CREATE OBJECT lo_vis_one.
  " Подсчёт обратной стоимости
  CREATE OBJECT lo_vis_two.

  lo_structure-&gt;calculate_cost( lo_vis_one ).
  lo_structure-&gt;calculate_cost( lo_vis_two ).

  WRITE: / lo_vis_one-&gt;mv_cost.
  WRITE: / lo_vis_two-&gt;mv_cost.</pre><p>В данном примере у иерархии элементов единый интерфейс, а посетители используются для подсчёта некоторой абстрактной стоимости элемента, причём алгоритмы подсчёта у них разные. Алгоритм не завязан на тип объекта. Если потребуется высчитать некоторую другую стоимость по иному алгоритму, мы не будем нагромождать интерфейс иерархии, а создадим посетителя, который и выполнит нужный нам подсчёт (операцию над элементом).</p>
<p>Еще одна <a href="http://butunclebob.com/ArticleS.UncleBob.IuseVisitor">хорошая статья</a> по теме.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/oop/posetitel-visitor/">Посетитель (Visitor)</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/oop/posetitel-visitor/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
