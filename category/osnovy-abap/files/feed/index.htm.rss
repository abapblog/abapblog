<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Работа с файлами | ABAP Blog</title>
	<atom:link href="https://abap-blog.ru/category/osnovy-abap/files/feed/" rel="self" type="application/rss+xml" />
	<link>https://abap-blog.ru</link>
	<description>Все о разработке в решениях от SAP</description>
	<lastBuildDate>Sat, 02 Oct 2021 17:39:09 +0000</lastBuildDate>
	<language>ru-RU</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.8.1</generator>
	<item>
		<title>Файловый интерфейс &#8212; операции с файлами</title>
		<link>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/</link>
					<comments>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Mon, 09 Dec 2013 07:26:57 +0000</pubDate>
				<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[работа с файлами]]></category>
		<category><![CDATA[файл]]></category>
		<category><![CDATA[файловый интерфейс]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=1660</guid>

					<description><![CDATA[<p>Файловый интерфейс и юникод Поскольку содержимое файлов отражает структуру данных, обрабатываемую в памяти, файловый интерфейс в юникодных системах должен позволять следующее: Должна быть возможность обмена данными между юникодными и не юникодными системами (т.к. отображение данных в памяти отличается); Должна быть возможность обмена данными между различными юникодными системами; Должна быть возможность обмена данными между разными не юникодными системами, [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/">Файловый интерфейс — операции с файлами</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/file-transfers-_114260033.s300x300.jpg"><img loading="lazy" class="size-full wp-image-1661 alignleft" style="margin: 10px 30px 10px 10px;" src="http://abap-blog.ru/wp-content/uploads/2013/12/file-transfers-_114260033.s300x300.jpg" alt="file-transfers-_114260033.s300x300" width="300" height="232" /></a><strong>Файловый интерфейс и юникод</strong></p>
<p>Поскольку содержимое файлов отражает структуру данных, обрабатываемую в памяти, файловый интерфейс в юникодных системах должен позволять следующее:</p>
<ol>
<li>Должна быть возможность обмена данными между юникодными и не юникодными системами (т.к. отображение данных в памяти отличается);</li>
<li>Должна быть возможность обмена данными между различными юникодными системами;</li>
<li>Должна быть возможность обмена данными между разными не юникодными системами, в которых используются различные кодировки.</li>
</ol>
<p><span id="more-1660"></span></p>
<p>Данные требования накладывают определенные ограничения, так в юникодных системах требуется обязательное указание кодовой страницы, перед работой через интерфейс, кроме того:</p>
<ul>
<li>Файл должен быть явным образом открыт (OPEN DATASET), перед операцией чтения или записи. Кроме того файл, который был уже открыт ранее, не может быть открыт снова (до тех пор, пока не будет закрыт). В не юникодных системах открытие файла происходит неявным образом при обращении к нему (например, при чтении), соответственно не требуется явного открытия перед началом работы. Кроме того, выражение для открытия файла может быть запущено неоднократно, несмотря на то, что открыть файл в программе можно только после его закрытия, либо в первый раз. Повторное открытие в не юникодных системах просто пропускается.</li>
<li>Тип доступа (INPUT,OUTPUT..) и режим обработки файла (TEXT, BINARY) должны быть явно определены, когда файл открывается. В не юникодных системах, если ничего не будет задано, файл откроется с неявно заданными параметрами по умолчанию.</li>
<li>Если файл открыт для чтения, возможно только чтение. В не юникодных системах кроме чтения, возможна так же и запись.</li>
<li>Если файл открыт как текстовый (дополнение TEXT), только символьные переменные могут быть считаны или записаны в него. В не юникодных системах допускается считывание и запись из байтовых или числовых переменных.</li>
</ul>
<p><b>Рекомендуется придерживаться правил определенных в юникодных системах, даже если вы работаете в не юникодной системе.</b></p>
<p>Для поддержки работы с юникодом, был создан специальный системный класс CL_ABAP_FILE_UTILITIES. Некоторые его методы:</p>
<ul>
<li>CHECK_FOR_BOM – проверить наличие в файле метки <a href="http://ru.wikipedia.org/wiki/Byte_order_mark">BOM</a>.</li>
<li>CHECK_UTF8 – хранится ли файл в UTF-8. MAX_KB – определяет размер KB при сканировании.</li>
<li>CREATE_UTF8_FILE_WITH_BOM – создание файла в UTF-8 с меткой.</li>
<li>CHECK_XSTRING_UTF8 – проверить последовательность на наличие UTF-8 кодировки.</li>
<li>CHECK_STRING_7BIT_ASCII – проверяет, содержит ли строка только ASCII символы.</li>
</ul>
<p>&nbsp;</p>
<h2>Операторы файлового интерфейса</h2>
<p>Как было уже упомянуто ранее, файловый интерфейс в ABAP реализован с помощью набора операторов и их параметров:</p>
<ul>
<li>OPEN DATASET</li>
<li>TRANSFER</li>
<li>READ DATASET</li>
<li>GET DATASET</li>
<li>SET DATASET</li>
<li>TRUNCATE DATASET</li>
<li>CLOSE DATASET</li>
<li>DELETE DATASET</li>
</ul>
<p>&nbsp;</p>
<h3>OPEN DATASET</h3>
<p>Синтаксис:</p>
<p><strong>OPEN DATASET dset FOR access IN mode [position] [os_additions] [error_handling].</strong></p>
<p>Данный оператор открывает файл, указанный в dset, для доступа указанного в access и режиме хранения mode. Dset – символьная переменная, в которой будет правильное, с точки зрения ОС, физическое имя файла. Файл нельзя открывать более одного раза, без закрытия, иначе система вызовет исключение (для юникодных систем).</p>
<p>Дополнения position, os_additions, error_handling  указывают, с какой позиции начинать обработку файла, дополнения зависимые от ОС сервера приложений и поведение, связанное с обработкой ошибочных ситуаций.</p>
<p>Особенности:</p>
<ul>
<li>Количество файлов одновременно обрабатываемых не может превышать 100, для одной сессии.</li>
<li>При открытии набора срабатывают автоматические проверки полномочий (рассмотрены выше).</li>
<li>Если имя файла приходит откуда-то извне, необходимо его проверить, чтобы не подвергать систему риску, связанному с обходом <a href="http://help.sap.com/abapdocu_740/en/abendyn_file_scrty.htm">доступа к директориям</a>:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">CALL FUNCTION 'FILE_VALIDATE_NAME'

  EXPORTING
    logical_filename           = 'EXAMPLE_FILE'
  CHANGING
    physical_filename          = file
  EXCEPTIONS
    logical_filename_not_found = 1
    validation_failed          = 2
    OTHERS                     = 3.
IF sy-subrc = 0.
  OPEN DATASET file FOR OUTPUT IN BINARY MODE.
ELSE.
  cl_demo_output=&gt;display( |Error return code { sy-subrc }| ).
ENDIF.</pre><p>В приведенном ниже примере демонстрируется программа, в которой существует возможность обхода полномочий, так как нет проверки (уязвимость проявляет себя, когда в качестве части пути указываются «../» или «..\»):</p><pre class="urvanov-syntax-highlighter-plain-tag">PARAMETERS: pv_fname TYPE c LENGTH 64 LOWER CASE DEFAULT 'test.txt',
            pv_text  TYPE string LOWER CASE DEFAULT 'Содержимое файла'.
DATA        lv_full_name TYPE string.

AT SELECTION-SCREEN.
  IF pv_fname = ''.
    MESSAGE 'Необходимо указать имя файла' TYPE 'E'.
  ENDIF.
  lv_full_name = '/tmp/' &amp;&amp; pv_fname. "Assume enduser inputs only a relative file name.

START-OF-SELECTION.
  OPEN DATASET lv_full_name FOR OUTPUT IN TEXT MODE ENCODING UTF-8 .
  IF sy-subrc &lt;&gt; 0.
    MESSAGE 'Не могу открыть файл' &amp;&amp; lv_full_name TYPE 'E'.
  ELSE.
    TRANSFER pv_text TO lv_full_name.
    CLOSE DATASET lv_full_name.
    WRITE :/ 'Содержимое сохранено в:', lv_full_name.
  ENDIF.</pre><p>Возвращаемые значения поля ошибки, после вызова оператора:</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">sy-subrc</td>
<td valign="top">Значение</td>
</tr>
<tr>
<td valign="top">0</td>
<td valign="top">Файл был открыт.</td>
</tr>
<tr>
<td valign="top">8</td>
<td valign="top">ОС не смогла открыть файл.</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_OPEN</b></p>
<p>Причины: Файл уже открыт.</p>
<p>Ошибка времени выполнения: DATASET_REOPEN</p>
<p><b>CX_SY_CODEPAGE_CONVERTER_INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)</p>
<p>Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_SY_CONVERSION_CODEPAGE</b></p>
<p>Причина: Преобразование невозможно.</p>
<p>Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу</p>
<p>Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p>Причина: Нет доступа к открытию канала,  OPEN DATASET с дополнением FILTER.</p>
<p>Ошибка времени выполнения: OPEN_PIPE_NO_AUTHORITY</p>
<p><b>CX_SY_PIPES_NOT_SUPPORTED</b></p>
<p>Причина: ОС не поддерживает именованные каналы.</p>
<p>Ошибка времени выполнения: DATASET_NO_PIPE</p>
<p><b>CX_SY_TOO_MANY_FILES</b></p>
<p>Причина: Достигнуто максимальное число открытых файлов.</p>
<p>Ошибка времени выполнения: DATASET_TOO_MANY_FILES</p>
<p>&nbsp;</p>
<p><b><i>Не обрабатываемые исключения</i></b></p>
<p>Причина: Именованный канал уже открыт.</p>
<p>Ошибка времени выполнения: DATASET_PIPE_POSITION</p>
<p>&nbsp;</p>
<h4>Дополнение access</h4>
<p><strong>  &#8230; INPUT</strong></p>
<p><strong>| OUTPUT</strong><br />
<strong> | APPENDING</strong><br />
<strong> | UPDATE &#8230; .</strong></p>
<p>Дополнение указывает тип доступа, т.е. каким образом открывается файл: на чтение, запись, добавление или изменение. В юникодных системах указание данного дополнения является обязательным.</p>
<ul>
<li> <b>INPUT</b> – открывает файл для чтения. По умолчанию указатель внутри файла выставляется на начало файла (при работе с файлами важно понимать, что обычно они обрабатываются не целиком, а частями. Для того чтобы определить необходимое начало и конец, обрабатываемой части файла служит файловый указатель.). Если указанный файл не существует, поле sy-subrc будет равно 8. В юникодных программах запрещено вести запись в открытый для чтения файл, для не юникодных программ это ограничение не действует, однако для совместимости необходимо его соблюдать.</li>
<li><b>OUTPUT</b> – открытие файла для записи. Если файл существовал ранее, его содержимое удаляется. Если файл не существует, он создается. Чтение так же разрешено.</li>
<li><b>APPENDING</b> – открытие файла для добавления. Если файл уже существовал, он откроется,  указатель будет перемещен в конец файла. Если файл не существовал, он создается. Попытка чтения файла оператором READ DATASET будет прервана, sy-subrc возвратит 4.</li>
<li><b>UPDATE</b> – открытие файла для обновления существующего содержимого. По умолчанию указатель будет выставлен в начало файла. Если указанный файл не существует, sy-subrc возвратит значение равное 8.</li>
</ul>
<p>&nbsp;</p>
<h4>Дополнение mode</h4>
<p>Данное дополнение указывает на то, работаем ли мы с текстовым файлом или с бинарным. Атрибут LEGACY используется в том случае, когда мы хотим обеспечить совместимость с не юникодными системами.</p>
<p>Синтаксис:</p>
<p><strong>&#8230; {BINARY MODE}</strong></p>
<p><strong> | {TEXT MODE encoding [linefeed] }</strong><br />
<strong> | {LEGACY BINARY MODE [endian] [CODE PAGE cp]}</strong><br />
<strong> | {LEGACY TEXT MODE [endian] [CODE PAGE cp] [linefeed]} &#8230; .</strong></p>
<ul>
<li> <b>BINARY MODE</b>  &#8212; открывает файл как бинарный файл. При записи или чтении, бинарное представление переменных переносится в файл (из файла) в неизменном состоянии.</li>
<li><b>TEXT </b><b>MODE </b>– открывает файл как текстовый. Дополнение Encoding указывает на формат символьного представления (см. ниже). Когда происходит запись в файл, содержимое переменных преобразовывается в соответствии с форматом определенным в Encoding, после чего переносится в файл. Если переменная является символьной (clike) или плоской структурой, пробелы на концах обрезаются. Если используется строковый тип, пробелы не обрезаются. При записи данных, по умолчанию вставляется зависимый от платформы символ конца строки.</li>
</ul>
<p>Считывание происходит до символа конца строки, затем указанные символы преобразуются в соответствии с форматом определенным в Encoding, в текущий формат для сервера и записываются в переменную. Обработка символов конца строки зависит от дополнения linefeed.  Для юникодных программ, в данном режиме, при передаче или считывании из файла, могут быть использованы только символьные типы, кроме того необходимо обязательное указание дополнения encoding. В не юникодных программах дополнение encoding не обязательно. При перемещении указателя, при работе с текстовым файлом происходит перемещение на указанное количество символов, а не байт.</p>
<ul>
<li><b>LEGACY</b> – разница с простым открытием в том, что в данном случае можно задать кодовую страницу, через атрибут CODE PAGE и порядок байт, в атрибуте endian.  В режиме LEGACY TEXT MODE пробелы в символьных (clike) переменных или плоских структурах обрезаются.</li>
</ul>
<p>&nbsp;</p>
<h4><span style="font-size: 1em;">Дополнение linefeed</span></h4>
<p>Дополнение linefeed имеет следующий синтаксис:</p>
<p><strong>&#8230; WITH { NATIVE </strong></p>
<p><strong>| SMART<br />
| UNIX<br />
| WINDOWS } LINEFEED &#8230; .</strong></p>
<p>При использовании данного дополнения, профильный параметр abap/NTfmode (тр. RZ11) игнорируется. Нельзя использовать данное дополнение с дополнением TYPE, если его значение «NT» или «UNIX».</p>
<p>Если данное дополнение не используется, правила определения символа конца строки зависят от текущего сервера приложений и платформы, на которой он запущен:</p>
<ul>
<li>Для UNIX систем (Unix, OS/390, и IBM i5/OS) это «LF».</li>
<li>Для Windows – «CRLF». Кроме того для Windows систем может быть использован параметр abap/NTfmode, который определяет какой символ конца строки использовать для новых файлов. Если его значение «b» &#8212; используется маркер «LF». Если его значение «t» или пустое – используется маркер «CRLF». Данный параметр может быть переопределен в дополнении TYPE и значением для его «NT» или «UNIX». Если существующий файл был открыт без дополнения TYPE, происходит поиск маркера, если маркер был найден, он и будет использоваться для всего файла. Если маркер не был найден, будет использоваться профильный параметр  abap/NTfmode.</li>
</ul>
<p>Если дополнение было указано при открытии файла, оно может быть перезаписано, через оператор SET DATASET.</p>
<p>SAP рекомендует указывать дополнение linefeed, т.к. если его не указать логика определения указателя конца строки будет зависеть от множества факторов: ОС сервера приложений, профильный параметр, существующий символ в имеющемся файле.</p>
<p>Значения, указываемые в дополнении:</p>
<ul>
<li><b>NATIVE</b> – в зависимости от ОС на сервере приложений (см. выше)</li>
<li><b>SMART</b> – данное дополнение зависит от типа доступа к файлу:
<ul>
<li>Если файл открыт на чтение (FOR INPUT), оба маркера будут обрабатываться. При открытии EBCDIC файла так же обрабатывается маркер «NL» (new line).</li>
<li>Если файл открыт для дополнения или для обновления (APPENDING, UPDATE) происходит поиск маркера, который уже был использован в файле. Найденный маркер далее используется для записи. Если маркер не будет найден, будет использован маркер для ОС сервера приложений (как с дополнением NATIVE).</li>
<li>Если файл открывается для записи (OUTPUT), маркер определяется в зависимости от ОС сервера приложений (как с дополнением NATIVE).</li>
<li><b>UNIX</b> – используется «LF» маркер</li>
<li><b>WINDOWS</b> – используется «CRLF» маркер</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h4>Дополнение CODEPAGE</h4>
<p>Синтаксис:</p>
<p><strong>&#8230;  CODE PAGE cp &#8230;</strong></p>
<p>Указывает кодовую страницу, в которой представлены данные файла. Когда данные переносятся из файла в ABAP, происходит автоматическая конвертация в кодовую страницу, использующуюся на сервере приложений (если они не идентичны). При записи происходит аналогичная конвертация в указанную в дополнении кодировку.</p>
<p>В юникодных системах происходит преобразование символов из указанной кодовой страницы в юникодные символы, в соответствии с текущим форматом на сервере приложений.</p>
<p>В качестве параметра <b>cp</b> необходимо использовать переменную со значением из столбца CPCODEPAGE в таблице TCP00.</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/codepages.png"><img loading="lazy" class="alignnone size-full wp-image-1662" src="http://abap-blog.ru/wp-content/uploads/2013/12/codepages.png" alt="codepages" width="796" height="66" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/codepages.png 796w, https://abap-blog.ru/wp-content/uploads/2013/12/codepages-300x24.png 300w" sizes="(max-width: 796px) 100vw, 796px" /></a></p>
<h4></h4>
<h4>Дополнение ENCODING</h4>
<p>Синтаксис:</p>
<p><b>&#8230; </b><b>ENCODING</b><b> { </b><b>DEFAULT</b><b> </b><b><br />
</b><b>            </b><b> | {</b><b>UTF</b><b>-8 [</b><b>SKIPPING</b><b>|</b><b>WITH</b><b> </b><b>BYTE</b><b>&#8212;</b><b>ORDER</b><b> </b><b>MARK</b><b>]}</b><b> </b><b><br />
</b><b>            </b><b> | </b><b>NON</b><b>&#8212;</b><b>UNICODE</b><b> } &#8230; .</b></p>
<p>Определяет формат, используемый для текстовых файлов.  Данное дополнение обязательно для юникодных систем, в не юникодных может быть опущено (по умолчанию примет значение NON-UNICODE).</p>
<p>SAP рекомендует всегда использовать UTF-8 при работе с текстовыми файлами. Так как кодовые страницы не всегда можно идентифицировать относительно содержимого файла.</p>
<p>Может принимать следующие значения:</p>
<ul>
<li><b>DEFAULT</b> – в юникодных системах тоже самое что и UTF-8, для не юникодных систем NON-UNICODE.</li>
<li><b>UTF-8</b> [SKIPPING|WITH BYTE-ORDER MARK] – файл обрабатывается в соответствии с кодировкой <a href="http://ru.wikipedia.org/wiki/UTF-8">UTF-8</a>. С помощью дополнения указывается, необходимо ли обрабатывать символ порядка байт (<a href="http://ru.wikipedia.org/wiki/Byte_order_mark">BOM</a>):
<ul>
<li>SKIPING BYTE-ORDER MARK – используется только если файл открывается для чтения или изменения, если в файле присутствует данный символ указатель переводится на позицию после него, без дополнения файл обрабатывается как обычно.</li>
<li>WITH BYTE-ORDER MARK – используется для файлов открытых на запись (OUTPUT), если дополнение указано символ вставляется автоматически в начало файла, если не указано символ не будет вставлен.</li>
<li><b>NON-</b><b>UNICODE</b> – для не юникодных систем, данные переносятся в файл (из файла) без дополнительной конвертации. В юникодной системе, происходит преобразование в соответствии с настроенным присвоением, таблица TCP0C.</li>
</ul>
</li>
</ul>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/cpconvert.png"><img loading="lazy" class="alignnone size-full wp-image-1663" src="http://abap-blog.ru/wp-content/uploads/2013/12/cpconvert.png" alt="cpconvert" width="520" height="37" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/cpconvert.png 520w, https://abap-blog.ru/wp-content/uploads/2013/12/cpconvert-300x21.png 300w" sizes="(max-width: 520px) 100vw, 520px" /></a></p>
<p>Дополнение BYTE-ORDER MARK не может использоваться одновременно с дополнением position (см. ниже).</p>
<p>Рекомендации SAP:</p>
<ul>
<li>При открытии UTF-8 файлов на чтение желательно всегда пропускать символ порядка байт, использовать SKIPING дополнение.</li>
<li>При записи в UTF-8 файл, желательно всегда записывать метку с дополнением WITH BYTE-ORDER MARK.</li>
<li>С помощью класса CL_ABAP_FILE_UTILITIES и его метода  CREATE_UTF8_FILE_WITH_BOM, можно создать UTF-8 файл с меткой BOM. С помощью метода CHECK_UTF8 можно определить есть ли метка в указанном файле.</li>
</ul>
<p>UTF-16 файлы могут быть открыты только как бинарные файлы.</p>
<h4></h4>
<h4>Дополнение endian</h4>
<p>Синтаксис:</p>
<p><b>&#8230; {BIG|LITTLE} ENDIAN &#8230;</b></p>
<p>Дополнение указывает <a href="http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2">порядок байтов</a> при записи числовых переменных ABAP (i, decfloat16, decfloat34, f, или s).</p>
<p>&nbsp;</p>
<h4>Дополнение position</h4>
<p>Синтаксис:</p>
<p><b>&#8230; </b><b>AT</b><b> </b><b>POSITION</b><b> </b><b>pos</b><b> &#8230; .</b></p>
<p>Переводит указатель файла на указанное в переменной POS число байт. Если в качестве позиции передать -1, указатель будет переведен в конец файла.</p>
<p>Следует знать следующие особенности:</p>
<ul>
<li>Если файл открыт на чтение и значение в pos больше размера файла, указатель становится неопределенным и чтение в таком  случае будет невозможно, до тех пор, пока указатель не будет переведен в пределы размера файла. Если файл обрабатывается в не юникодной системе и происходит запись в него, все последующие от конца файла байты до указателя будут заполнены 16-ричным представлением 0, а запись начнется со следующего байта.</li>
<li>Если файл открыт для записи, все символы с начала файла, до указанной позиции заполняются 16-ричным представлением 0 и запись происходит со следующего байта.</li>
<li>Если файл открывается для добавления (APPENDING), данное дополнение игнорируется, указатель выставляется в конец файла.</li>
<li>Если файл открывается для изменения и позиция указана больше размера файла в байтах, все байты с конца файла по указанную позицию заполняются 16-ричным представлением 0 и запись происходит со следующего байта после указанной позиции.</li>
</ul>
<p>Дополнение не может быть использовано одновременно с дополнениями FILTER и BYTE-ORDER MARK.</p>
<p>&nbsp;</p>
<h4>Дополнения os_additions</h4>
<p>Синтаксис:</p>
<p><b>&#8230; [</b><b>TYPE</b><b> </b><b>attr</b><b>]</b><br />
<b>    </b><b>[</b><b>FILTER</b><b> </b><b>opcom</b><b>] &#8230; .</b></p>
<p>Данные дополнения указывают на специфические для ОС параметры при обработке файлов.</p>
<ul>
<li>Дополнение TYPE attr – зависит от ОС, используемой на сервере приложений. Если ОС не MS Windows, символьное значение, определенное в attr, содержит зависимые от ОС параметры для файла, который должен обрабатываться. Для MS Windows в этот параметр, при работе с текстовыми файлами или текстовыми файлами в режиме совместимости, может быть передан идентификатор символа конца строки: «NT» для CRLF «UNIX» для LF, но только в том случае, если не указано дополнение linefeed. Все остальные значения в данном параметре будут проигнорированы для MS Windows.</li>
</ul>
<p>Пример использования дополнения в ОС IBM i5/OS:</p><pre class="urvanov-syntax-highlighter-plain-tag">OPEN DATASET 'test.dat' 
  TYPE 'lrecl=80, blksize=8000, recfm=FB' 
  FOR OUTPUT IN TEXT MODE 
             ENCODING DEFAULT 
             WITH SMART LINEFEED.</pre><p></p>
<ul>
<li>Дополнение FILTER opcom – данное дополнение поддерживается для ОС (Unix, Windows), работающих с так называемыми <a href="http://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB">именованными каналами</a> (pipes). За более подробной информацией можете обратиться к <a href="http://help.sap.com/abapdocu_740/en/abapopen_dataset_os_addition.htm#!ABAP_ADDITION_1@1@">справке</a> по данному дополнению.</li>
</ul>
<p>&nbsp;</p>
<h4>Дополнения error_handling</h4>
<p>Синтаксис:</p>
<p><b>&#8230; [MESSAGE msg]</b><br />
<b>    [IGNORING CONVERSION ERRORS]</b><br />
<b>    [REPLACEMENT CHARACTER rc] &#8230; .</b></p>
<p>В случае возникновения ошибок, данные дополнения позволяют получать эти ошибки, подавлять некоторые ошибки, определять символы замены для неизвестных символов.</p>
<ul>
<li>Дополнение MESSAGE msg. В случае возникновения ошибки на уровне сервера приложения, в символьную переменную msg будет записан код ошибки, пример:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA mess TYPE string. 

OPEN DATASET `` FOR INPUT IN BINARY MODE MESSAGE mess. 

IF sy-subrc = 8. 
  MESSAGE mess TYPE 'I'. 
ENDIF.</pre><p></p>
<ul>
<li>Дополнение IGNORING CONVERSION ERRORS. Данное дополнение может быть использовано для подавления исключения CX_SY_CONVERSION_CODEPAGE. Данное исключение возникает, если при работе с файлом невозможно сделать преобразование из одной кодовой страницы в другую. Данное дополнение используется только при обработке текстовых файлов, текстовых файлов в режиме совместимости и бинарных файлов в режиме совместимости, но не для бинарных файлов. При этом каждый не конвертируемый символ заменяется по умолчанию символом «#», либо символом, указываемым в следующем дополнении.</li>
<li>REPLACEMENT CHARACTER rc. В качестве rc указывается символ, на который будут заменены не распознанные символы.</li>
</ul>
<p>&nbsp;</p>
<h3>TRANSFER</h3>
<p>Синтаксис:</p>
<p><b>TRANSFER dobj TO dset [LENGTH len]</b><b> </b><b><br />
[NO END OF LINE].</b></p>
<p>Данный оператор переносит содержимое переменной dobj в файл dset. В качестве переменной может быть использована любая символьная переменная или плоская структура. При обработке бинарного файла используются байтовые типы (x, xstring).  В юникодных программах при записи в текстовый файл может использоваться только символьная переменная (не структура), данное ограничение не распространяется на текстовые файлы, открытые в режиме совместимости.</p>
<p>В качестве dset указывается физическое имя файла. Содержимое dobj передается в файл начиная с текущей позиции указателя. После того, как данные будут перенесены в файл, курсор смесится на следующую позицию после перемещенных данных.</p>
<p>Для записи в юникодных программах, необходимо чтобы файл был открыт для записи, добавления или изменения.  Если файл был не открыт заранее, в не юникодных системах он будет открыт неявно.</p>
<p>В зависимости от типа доступа к файлу, есть определенные особенности:</p>
<ul>
<li>Файл открыт для чтения (FOR INPUT). Нельзя производить запись в юникодных программах. В не юникодных программах запись происходи так же, как если бы он был открыт с типом доступа &#8212; FOR UPDATE.</li>
<li>Файл открыт для записи (FOR OUTPUT). Запись происходит, начиная с текущей позиции указателя, если указатель был перемещен дальше конца файла, байты с позиции конца файла, по текущую позицию будут записаны 16-ричным представлением 0.</li>
<li>Если файл был открыт для добавления (APPENDING) , система начинает вести запись с текущего указателя, при первоначальном открытии указатель находится в конце файла.</li>
<li>Файл открыт для изменения (CHANGING). Запись происходит с текущей позиции указателя, если указатель был перемещен дальше конца файла, байты с позиции конца файла, по текущую позицию будут записаны 16-ричным представлением 0. Если часть файла должна быть перезаписана, обязательно открывать с типом доступа CHANGING для юникодных программ. В не юникодных программах, файл, открытый для чтения может быть перезаписан, но SAP не рекомендует этого делать.</li>
</ul>
<p>Кроме того, на работу оператора влияет  тип содержимого файла:</p>
<ul>
<li>Если файл открыт как текстовый или текстовый в режиме совместимости, любые пробелы на концах символьных переменных обрезаются, кроме переменных с типом string. Если необходимо преобразование, в кодовую страницу отличную от системной, происходит преобразование, затем побайтно идет запись в файл.</li>
<li>После записи в файл содержимого из dobj автоматически вставляется метка конца строки, определенная при открытии. Чтобы система не добавляла метку, используется дополнение NO END OF LINE.</li>
</ul>
<p>Следует знать некоторые особенности:</p>
<ul>
<li>Оператор TRANSFER либо возвращает sy-subrc  = 0, либо вызывает исключение.</li>
<li>В не юникодных программах вызов OPEN DATASET перед TRANSFER не обязателен, поэтому в не юникодных программах при вызове оператора TRANSFER срабатывают автоматические проверки доступа к файлу, т.к. происходит неявный вызов OPEN DATASET.</li>
</ul>
<p>Дополнения:</p>
<ul>
<li>LENGTH len – определяет то, как много байтов или символов (в зависимости от типа содержимого) будет записано в файл.  Для бинарных, текстовых в режиме совместимости и бинарных в режиме совместимости файлов, дополнение определяет количество передаваемых байт.</li>
</ul>
<p>Если длинна 0 и меньше, ничего не будет записано.  Если количество в len больше количества символов или байт в dobj, вместо недостающих символов (байтов) в файл будут записаны пустые символы (пробелы) или 16-ричное представление 0.</p>
<p>Пример использования оператора TRANSFER:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE `flights.dat`, 
      wa   TYPE spfli. 

FIELD-SYMBOLS &lt;hex_container&gt; TYPE x. 

OPEN DATASET file FOR OUTPUT IN BINARY MODE. 

SELECT * 
       FROM spfli 
       INTO wa. 
  ASSIGN wa TO &lt;hex_container&gt; CASTING. 
  TRANSFER &lt;hex_container&gt; TO file. 
ENDSELECT. 

CLOSE DATASET file.</pre><p><b><i>Обрабатываемые</i></b><b><i> исключения</i></b></p>
<p><b>CX_</b><b>SY_</b><b>CODEPAGE_</b><b>CONVERTER_</b><b>INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)<br />
Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_</b><b>SY_</b><b>CONVERSION_</b><b>CODEPAGE</b></p>
<p>Причина: Преобразование невозможно.<br />
Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>IO</b></p>
<p>Причина: Ошибка при записи в файл.<br />
Ошибка времени выполнения: DATASET_WRITE_ERROR</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>OPEN</b></p>
<p>Причина: Файл не может быть открыт.<br />
Ошибка времени выполнения: DATASET_CANT_OPEN</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>OPEN_</b><b>MODE</b></p>
<p>Причина: Файл не был открыт для указанного типа доступа.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p>Причина: Файл открыт в юникодной программе с использованием OPEN DATASET &#8230; FOR INPUT и не может использоваться для записи.<br />
Ошибка времени выполнения: DATASET_READ_ONLY</p>
<p><b>CX_SY_PIPE_REOPEN</b></p>
<p>Причина: Рабочий процесс, в котором был открыт файл с именованным каналом либо закрыт, либо переключен.<br />
Ошибка времени выполнения: DATASET_PIPE_CLOSED</p>
<p><b>CX_SY_TOO_MANY_FILES</b></p>
<p>Причина: Достигнуто максимальное число открытых файлов.<br />
Ошибка времени выполнения: DATASET_TOO_MANY_FILES</p>
<p>&nbsp;</p>
<h2>READ DATASET</h2>
<p>Синтаксис:</p>
<p><b>READ DATASET dset INTO dobj [MAXIMUM LENGTH mlen]</b><br />
<b>                           [[ACTUAL] LENGTH alen].</b></p>
<p>Данный оператор производит чтение из файла dset в переменную dobj. В качестве переменной может выступать либо переменная с элементарным типом, либо переменная с типом плоской структуры. В юникодных программах обязательно чтобы переменная была символьной, если файл открыт как текстовый. Чтение происходит с текущей позиции указателя в файле. После того как чтение осуществлено, указатель перемещается на длину считанных данных.</p>
<p>В юникодных программах для того чтобы производить чтение из файла, он должен быть открыт с любым типом доступа.  Если файл не был открыт в не юникодной программе, его открытие происходит неявным образом.</p>
<p>На работу оператора влияет тип содержимого в файле:</p>
<ul>
<li>Если файл открыт как текстовый или как текстовый в режиме совместимости, данные считываются с текущей позиции до метки конца строки, указатель перемещается на позицию после метки конца строки. Если последний символ, в текстовым файле, не является меткой конца строки, конец текстового файла интерпретируется как конец строки.</li>
</ul>
<p>Если переменная dobj слишком коротка относительно считываемых символов, лишние символы обрезаются. Если же она длиннее, переменная заполняется пробелами справа. Если же dobj строковая переменная (тип string) в неё передаются только считанные символы.</p>
<ul>
<li>Если файл открыт как бинарный или как бинарный в режиме совместимости, система считывает ровно столько байтов, сколько может уместиться в переменной dobj. Файловый указатель так же перемещается по мере считывания. Если переменная dobj больше размеров файла, она заполняется 16-ричным представлением 0 справа. Если dobj строка, система пытается считать весь файл в переменную.</li>
</ul>
<p>Если при открытии файла указана необходимость в конвертации кодировок, она срабатывает до присвоения данных переменной, после чего в неё побайтно передаются сконвертированные данные.</p>
<p><b>Заполнение поля </b><b>sy-</b><b>subrc</b></p>
<p>Для текстовых файлов</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top"><b>sy-subrc</b></td>
<td valign="top"><b>Значение</b></td>
</tr>
<tr>
<td valign="top">0</td>
<td valign="top">Данные считаны до явно определенной метки конца строки или до неявной метки конца строки в конце файла.</td>
</tr>
<tr>
<td valign="top">4</td>
<td valign="top">Была сделана попытка чтения данных после конца файла.</td>
</tr>
</tbody>
</table>
<p>Для бинарных файлов</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top"><b>sy-subrc</b></td>
<td valign="top"><b>Значение</b></td>
</tr>
<tr>
<td valign="top">0</td>
<td valign="top">Данные были считаны; при этом система либо достигла конца файла, либо нет</td>
</tr>
<tr>
<td valign="top">4</td>
<td valign="top">Либо была совершена попытка чтения после конца файла, либо переменная в которую происходит чтение оказалась длиннее его содержимого</td>
</tr>
</tbody>
</table>
<p>Существуют следующие особенности:</p>
<ul>
<li>Так как в не юникодных программах открытие файла может происходить не явно, для них вызывается автоматическая проверка полномочий.</li>
<li>Текстовый файл без явно записанных меток конца строки, всегда имеет неявную метку конца строки в конце файла.</li>
<li>При переносе цифровых данных или смешанных структур рекомендуется считывать данные в ссылочную переменную байтового типа, присвоенную с помощью дополнения CASTING (ниже будет показан альтернативный способ считывания, непосредственно в байтовый буфер):</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE `flights.dat`,
      wa   TYPE spfli,
      itab LIKE TABLE OF wa.

FIELD-SYMBOLS &lt;hex_container&gt; TYPE x.

OPEN DATASET file FOR INPUT IN BINARY MODE.

ASSIGN wa TO &lt;hex_container&gt; CASTING.

DO.
  READ DATASET file INTO &lt;hex_container&gt;.
  IF sy-subrc = 0.
    APPEND wa TO itab.
  ELSE.
    EXIT.
  ENDIF.
ENDDO.

CLOSE DATASET file.</pre><p>Дополнения:</p>
<ul>
<li><b>[ACTUAL] LENGTH alen</b>  &#8212; записывает считанный объем данных в переменную alen. Для текстовых – количество символов, для бинарных и в режиме совместимости – количество байт. <b> </b>Слово ACTUAL было введено, чтобы отличать это дополнение от следующего и должно быть всегда использовано.</li>
<li><b>MAXIMUM</b><b> </b><b>LENGTH</b><b> </b><b>mlen</b><b> </b><b>– </b>определяет, как много символов (байт) будет считано из файла. Для текстовых – количество символов, для бинарных и в режиме совместимости – количество байт. Пример:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE `flights.dat`,
      hex_container TYPE x LENGTH 1000,
      len TYPE i,
      itab          TYPE TABLE OF spfli.

FIELD-SYMBOLS &lt;spfli&gt; TYPE spfli.

DESCRIBE FIELD &lt;spfli&gt; LENGTH len IN BYTE MODE.

OPEN DATASET file FOR INPUT IN BINARY MODE.

ASSIGN hex_container TO &lt;spfli&gt; CASTING.

DO.
  READ DATASET file INTO hex_container MAXIMUM LENGTH len.
  IF sy-subrc = 0.
    APPEND &lt;spfli&gt; TO itab.
  ELSE.
    EXIT.
  ENDIF.
ENDDO.

CLOSE DATASET file.</pre><p><b><i>Обрабатываемые</i></b><b><i> исключения</i></b><b><i></i></b></p>
<p><b>CX_SY_CODEPAGE_CONVERTER_INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)<br />
Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_SY_CONVERSION_CODEPAGE</b></p>
<p>Причина: Преобразование невозможно.<br />
Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_SY_FILE_IO</b></p>
<p>Причина: Ошибка при чтении файла.<br />
Ошибка времени выполнения: DATASET_READ_ERROR</p>
<p><b>CX_SY_FILE_OPEN</b></p>
<p>Причина: Файл не был открыт.<br />
Ошибка времени выполнения: DATASET_CANT_OPEN</p>
<p><b>CX_SY_FILE_OPEN_MODE</b></p>
<p>Причина: Файл не был открыт для указанного режима.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p><b>CX_SY_PIPE_REOPEN</b></p>
<p>Причина: Рабочий процесс, в котором был открыт файл с именованным каналом либо закрыт, либо переключен.<br />
Ошибка времени выполнения: DATASET_PIPE_CLOSED</p>
<p>&nbsp;</p>
<h2>GET DATASET</h2>
<p>Синтаксис:</p>
<p><b>GET DATASET dset [POSITION pos] [ATTRIBUTES attr].</b></p>
<p>Данный оператор необходим для получения информации о наборе данных dset. При работе с ним, системное поле с кодом ошибки (sy-subrc) всегда равно 0, однако могут быть вызваны исключения (см. ниже)</p>
<p>Если вызывать оператор без дополнений, он может использоваться для проверки, был ли открыт набор данных ранее, если нет, система вызовет исключение.</p>
<p>Дополнения:</p>
<ul>
<li><b>POSITION pos</b>  &#8212; считывает в переменную pos, с типом i, текущий адрес указателя в файле. Позиция указателя всегда определена в байтах. Если позиция находится в начале файла, значение в переменной будет равно 0. Данное дополнение, не может быть одновременно использовано с описанным выше дополнением FILTER (система вызовет исключение). Для файлов, чей размер превышает 2 ГБ, невозможно получить все позиции указателя в файле. (не хватит диапазона типа i). Пример:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE 'test.dat',
      text TYPE string, pos TYPE i.

OPEN DATASET file FOR OUTPUT IN TEXT MODE
                             ENCODING DEFAULT
                             WITH SMART LINEFEED.
TRANSFER '1234567890' TO file.
GET DATASET file POSITION pos.
TRANSFER 'ABCDEFGHIJ' TO file.
CLOSE DATASET file.

OPEN DATASET file FOR INPUT IN TEXT MODE
                            ENCODING DEFAULT
                            WITH SMART LINEFEED
                            AT POSITION pos.
READ DATASET file INTO text.
CLOSE DATASET file.</pre><p></p>
<ul>
<li> <b>ATTRIBUTES attr</b>  &#8212; считывает атрибуты открытого набора данных. В качестве attr используется переменная с типом dset_attributes:</li>
</ul>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/attr.png"><img loading="lazy" class="alignnone size-full wp-image-1665" src="http://abap-blog.ru/wp-content/uploads/2013/12/attr.png" alt="attr" width="478" height="317" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/attr.png 478w, https://abap-blog.ru/wp-content/uploads/2013/12/attr-300x198.png 300w" sizes="(max-width: 478px) 100vw, 478px" /></a></p>
<p>Данная структура имеет два компонента, фиксированные атрибуты и изменяемые атрибуты. Изменяемые атрибуты можно поменять с помощью оператора SET DATASET (см. ниже). В следующем примере проверяется, открыт ли файл с дополнением FILTER, если нет, можно считать указатель файла:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: dset TYPE string VALUE 'test.dat', 
      pos TYPE I, attr TYPE dset_attributes.

OPEN DATASET dset FOR INPUT IN BINARY MODE 
                  FILTER 'uncompress'. 

... 

GET DATASET dset ATTRIBUTES attr. 
IF attr-fixed-indicator-filter &lt;&gt; 'X'. 
  GET DATASET dset POSITION pos. 
ELSE. 
  ... 
ENDIF. 

CLOSE DATASET dset.</pre><p><b><i>Обрабатываемые исключения</i></b></p>
<ul>
<li><b>CX_SY_FILE_OPEN_MODE</b> &#8212; файл не открыт.</li>
<li><b>CX_SY_FILE_POSITION</b> – невозможно получить позицию указателя файла.</li>
<li><b>CX_SY_CONVERSION_OVERFLOW</b> – переменная pos слишком мала, чтобы в неё можно было записать позицию указателя.</li>
</ul>
<p>&nbsp;</p>
<h2>SET DATASET</h2>
<p>Синтаксис:</p>
<p><b>SET DATASET dset [POSITION {pos|{END OF FILE}}]</b><br />
<b>[ATTRIBUTES attr].</b></p>
<p>Данный оператор позволяет изменять позицию курсора в файле, а так же изменяемые атрибуты набора данных.</p>
<p>Дополнения:</p>
<ul>
<li>[POSITION {pos|{END OF FILE}}] – перемещает указатель файла на позицию указанную в переменной pos, с типом i, либо если указано END OF FILE на конец файла. Если в переменной pos будет 0, указатель переместиться в начало файла, если – 1 в конец. Другие отрицательные значения не разрешается использовать. В зависимости от типа доступа, в котором открыт файл, есть некоторые особенности:
<ul>
<li>Если файл открыт для чтения, и позиция pos будет больше чем длинна файла, указатель будет перемещен вне файла, считать данные не получится до тех пор, пока указатель не будет перемещен в тело файла. Если в не юникодной программе совершить при этом запись, файл с конца будет заполнен 16-ричным представлением 0 до текущей позиции, после чего произойдет запись.</li>
<li>Если файл был открыт для записи или изменения и курсор был перемещен за пределы файла, при записи в него, с конца файла до текущей позиции он будет заполнен 16-ричным представлением 0, затем произойдет запись.</li>
<li>Если файл был открыт для добавления, позиция указателя в нем всегда остается в его конце.</li>
</ul>
</li>
</ul>
<p>Данное дополнение не может быть использовано, если файл был открыт с дополнением FILTER. Для файлов более 2 ГБ, невозможно определить позицию указателя.  Произвольное перемещение указателя больше подходит для бинарных файлов, чем для текстовых. В текстовых файлах позиция будет зависеть от кодировки, символов конца строки, использования юникода, а так же метки порядка байт.  Пример использования дополнения:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: file TYPE string VALUE 'test1.dat',
pos TYPE i,
text TYPE string.

OPEN DATASET file FOR OUTPUT IN TEXT MODE
ENCODING DEFAULT
WITH SMART LINEFEED.

TRANSFER: 'Line1' TO file,
'Line2' TO file,
'Line3' TO file.

SET DATASET file POSITION 0.
READ DATASET file INTO text.
SET DATASET file POSITION END OF FILE.

TRANSFER: 'Line4' TO file,
'Line5' TO file,
'Line6' TO file.

CLOSE DATASET file.</pre><p></p>
<ul>
<li>ATTRIBUTES attr – устанавливает изменяемые атрибуты. Для некоторых из изменяемых атрибутов существуют константы из пула типов DSET:</li>
</ul>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/attr2.png"><img loading="lazy" class="alignnone size-full wp-image-1664" src="http://abap-blog.ru/wp-content/uploads/2013/12/attr2.png" alt="attr2" width="355" height="513" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/attr2.png 355w, https://abap-blog.ru/wp-content/uploads/2013/12/attr2-207x300.png 207w" sizes="(max-width: 355px) 100vw, 355px" /></a></p>
<p>Пример:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: dset TYPE string VALUE 'test.dat', 
attr TYPE dset_attributes. 

OPEN DATASET dset FOR INPUT IN LEGACY TEXT MODE 
WITH NATIVE LINEFEED. 

... 

GET DATASET dset ATTRIBUTES attr. 

IF attr-fixed-mode = 'T' OR 
attr-fixed-mode = 'LT'. 
CLEAR attr-changeable. 
attr-changeable-indicator-conv_errors = 'X'. 
attr-changeable-conv_errors = 'I'. 
attr-changeable-indicator-linefeed_mode = 'X'. 
attr-changeable-linefeed_mode = 'S'. 
IF attr-fixed-mode = 'LT'. 
attr-changeable-indicator-code_page = 'X'. 
attr-changeable-code_page = '1100'. 
ENDIF. 
SET DATASET dset ATTRIBUTES attr-changeable. 
ENDIF. 

CLOSE DATASET dset.</pre><p><b><i>Обрабатываемые</i></b><b><i> исключения</i></b></p>
<p><b>CX_SY_CODEPAGE_CONVERTER_INIT</b></p>
<p>Причина: Желаемое преобразование невозможно. (Либо неверно указана желаемая кодировка, либо указанная кодировка не поддерживается на уровне системы)<br />
Ошибка времени выполнения: CONVT_CODEPAGE_INIT</p>
<p><b>CX_</b><b>SY_</b><b>CONVERSION_</b><b>CODEPAGE</b></p>
<p>Причина: Изменение символов замены и обработки ошибок возможно лишь для файлов открытых в TEXT MODE или LEGACY &#8230; MODE.<br />
Ошибка времени выполнения: CONVT_CODEPAGE</p>
<p><b>CX_SY_FILE_OPEN_MODE</b></p>
<p>Причина: Файл открыт на чтение, изменение невозможно<br />
Ошибка времени выполнения: DATASET_READ_ONLY</p>
<p>Причина: Файл не был открыт.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p>Причина: Файл открыт в неподдерживаемом режиме.<br />
Ошибка времени выполнения: DATASET_INCOMPATIBLE_MODE</p>
<p><b>CX_SY_FILE_POSITION</b></p>
<p>Причина: Ошибка при смене указателя.<br />
Ошибка времени выполнения: DATASET_SEEK_ERROR</p>
<p>Причина: Нет доступа для смены позиции.<br />
Ошибка времени выполнения: DATASET_NO_POSITION</p>
<p>Причина: Перемещение невозможно на указанную позицию, слишком большая позиция.<br />
Ошибка времени выполнения: DATASET_OFFSET_TOO_LARGE</p>
<p><b><i>Не обрабатываемые исключения</i></b></p>
<p>Причина: Невозможно изменить позицию для именованного канала.<br />
Ошибка времени выполнения: DATASET_PIPE_POSITION</p>
<p>&nbsp;</p>
<h2>TRUNCATE DATASET</h2>
<p>Синтаксис:</p>
<p><b>TRUNCATE DATASET dset AT {CURRENT POSITION}|{POSITION pos}.</b></p>
<p>С помощью данного оператора можно изменить размер файла (уменьшить или увеличить). Уменьшается когда позиция указателя после AT меньше текущего размера файла, увеличивается, когда больше. При увеличении размера файл заполняется 16-ричным представлением 0.</p>
<p>Оператор можно использовать, если файл открыт на запись, изменение или дополнение, а так же не указано дополнение FILTER.</p>
<p>Оператор всегда возвращает sy-subrc равное 0, либо вызывает исключение. Оператор не устанавливает новую позицию для указателя в файле. Если файл открыт для добавления, указатель перемещается непосредственно перед записью в файл.</p>
<p>Дополнения:</p>
<ul>
<li>CURRENT POSITION  &#8212; устанавливает конец в файла в текущей позиции</li>
<li>POSITION pos – устанавливает конец файла в указанной в pos позиции. В pos может быть передана любая числовая переменная, если её значение целое и не отрицательное.</li>
</ul>
<p>Пример использования оператора TRUNCATE:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: name TYPE string VALUE `test.dat`,
      hex  TYPE xstring.

hex = 'FFFF'.

OPEN DATASET name FOR OUTPUT IN BINARY MODE.

TRANSFER hex TO name.
SET DATASET name POSITION 0.
READ DATASET name INTO hex.

TRUNCATE DATASET name AT POSITION 1.
SET DATASET name POSITION 0.
READ DATASET name INTO hex.

TRUNCATE DATASET name AT POSITION 2.
SET DATASET name POSITION 0.
READ DATASET name INTO hex.

CLOSE DATASET name.</pre><p>После первого вызова оператора в файле останется значение «FF», после второго «FF00».</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_OPEN</b></p>
<p>Причина: Файл не был открыт.<br />
Ошибка времени выполнения: DATASET_NOT_OPEN</p>
<p>Причина: Файл открыт только для чтения.<br />
Ошибка времени выполнения: DATASET_READ_ONLY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>POSITION</b></p>
<p>Причина: Указана неверная позиция.<br />
Ошибка времени выполнения: DATASET_OFFSET_TOO_LARGE</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>TRUNCATE</b></p>
<p>Причина: ОС не может изменить размер файла.<br />
Ошибка времени выполнения: DATASET_TRUNCATE_ERROR</p>
<p>Причина: Невозможно изменить размер файла, открытого с дополнением FILTER.<br />
Ошибка времени выполнения: DATASET_TRUNCATE_ERROR</p>
<p><b><i>Не обрабатываемые исключения</i></b></p>
<p>Причина: Внутренняя ошибка.<br />
Ошибка времени выполнения: DATASET_TRUNCATE_ERROR</p>
<p>&nbsp;</p>
<h2>CLOSE DATASET</h2>
<p>Синтаксис:</p>
<p><b>CLOSE DATASET dset.</b></p>
<p>Оператор закрывает набор данных. Если файл уже был закрыт или еще не открыт, система игнорирует данный оператор, sy-subrc равен 0.  Если в ОС используется буфер при изменении файла, все что было в нем, переносится в файл.  Если при закрытии программы не было явного вызова закрытия набора данных, он закрывается автоматически.</p>
<p>Если файл открыт с дополнением FILTER, при его закрытии sy-subrc содержит код возврата из именованного канала, возвращаемый ОС. Если не было исключений sy-subrc равно 0.</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_CLOSE</b></p>
<p>Причина: Файл не был закрыт. Возможной причиной является недостаток памяти.<br />
Ошибка времени выполнения: DATASET_CANT_CLOSE</p>
<p>&nbsp;</p>
<h2>DELETE DATASET</h2>
<p>Синтаксис:</p>
<p><b>DELETE DATASET dset.</b></p>
<p>Удаляет указанный файл, при этом он может быть закрыт или открыт.  Если имя файла приходит извне, оно может нести серьезный риск из-за обхода директорий (см. выше) и требует дополнительной проверки.</p>
<p>Если значение поля sy-subrc равно 0, файл был удален. Если значение поля sy-subrc равно 4, файл не был удален.</p>
<p><b><i>Обрабатываемые исключения</i></b></p>
<p><b>CX_SY_FILE_AUTHORITY</b></p>
<p>Причина: Нет доступа к файлу<br />
Ошибка времени выполнения: OPEN_DATASET_NO_AUTHORITY</p>
<p><b>CX_</b><b>SY_</b><b>FILE_</b><b>OPEN</b></p>
<p>Причина: Файл не может быть открыт<br />
Ошибка времени выполнения: DATASET_CANT_OPEN</p>
<p>&nbsp;</p>
<h2>Дополнительные операции при работе с файлами</h2>
<p>Файловый интерфейс ABAP не предоставляет таких возможностей, как: переименовать файл (без его копирования в другой файл), листинга в директориях на сервере приложений,  копирования файла без его полного считывания через сервер приложений и др. Большинство этих операций выполняются на уровне системных команд сервера приложений, таких как: cp, mv, mkdir и других.</p>
<p>Для демонстрации работы данных операций можно посмотреть программу <a href="http://scn.sap.com/community/abap/blog/2012/05/03/al11-replacement">ZAL11</a>, которая является заменой стандартной тр. AL11, но с более продвинутыми возможностями:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/12/zall11.png"><img loading="lazy" class="alignnone size-large wp-image-1666" src="http://abap-blog.ru/wp-content/uploads/2013/12/zall11-1024x459.png" alt="zall11" width="550" height="246" srcset="https://abap-blog.ru/wp-content/uploads/2013/12/zall11-1024x459.png 1024w, https://abap-blog.ru/wp-content/uploads/2013/12/zall11-300x134.png 300w, https://abap-blog.ru/wp-content/uploads/2013/12/zall11.png 1213w" sizes="(max-width: 550px) 100vw, 550px" /></a></p>
<p>Так, например, выглядит процедура копирования (перемещения) файла (директории):</p><pre class="urvanov-syntax-highlighter-plain-tag">*&amp;---------------------------------------------------------------------*
*&amp;      Form  COPY_ITEM
*&amp;---------------------------------------------------------------------*
*       Copy or move remote file/folder
*----------------------------------------------------------------------*
*      --&gt;PW_NAME        File/folder to move/copy
*      --&gt;PW_PATH_TARGET Target folder
*      --&gt;PW_ACTION      Move : 2, copy : 1
*      --&gt;PW_TYPE        0=file, 1=folder
*----------------------------------------------------------------------*
FORM copy_item USING pw_name TYPE c
                     pw_path_target TYPE c
                     pw_action TYPE i
                     pw_type TYPE i.
  DATA : lw_command(1000) TYPE c,
         lw_action(1) TYPE c,
         lw_name TYPE string,
         lw_target TYPE string.

* Authority check for move/copy files
  IF s_auth-move_file NE c_true AND pw_type = 0.
    MESSAGE 'You are not allowed to perform this action'(e21)
            TYPE 'S' DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.

* Authority check for move/copy folders
  IF s_auth-move_folder NE c_true AND pw_type = 1.
    MESSAGE 'You are not allowed to perform this action'(e21)
            TYPE 'S' DISPLAY LIKE 'E'.
    EXIT.
  ENDIF.

  CONCATENATE '"' pw_name '"' INTO lw_name.
  CONCATENATE '"' pw_path_target '"' INTO lw_target.

* Confirm action on remote server
  IF pw_action = 1.
    lw_command = 'Are you sure you want to copy # into # ?'(t01).
  ELSE.
    lw_command = 'Are you sure you want to move # into # ?'(t02).
  ENDIF.
  REPLACE FIRST OCCURRENCE OF c_wildcard IN lw_command WITH lw_name.
  REPLACE FIRST OCCURRENCE OF c_wildcard IN lw_command WITH lw_target.
  PERFORM confirm_action USING lw_command CHANGING lw_action.
  IF lw_action = space.
    EXIT.
  ENDIF.

  IF pw_action = 1.
* Server command to copy file/folder
    CONCATENATE 'cp -r' lw_name lw_target INTO lw_command
                SEPARATED BY space.
  ELSE.
* Server command to move file/folder
    CONCATENATE 'mv' lw_name lw_target INTO lw_command
                SEPARATED BY space.
  ENDIF.
  CALL 'SYSTEM' ID 'COMMAND' FIELD lw_command.

* If application server is too fast, file server is not updated
* before querriing. Wait 1 second after server action
  WAIT UP TO 1 SECONDS.

ENDFORM.</pre><p>Вызов системных команд подобным образом, не является безопасным, подробнее читайте в <a title="Безопасный запуск системных команд из ABAP" href="http://scn.sap.com/community/abap/blog/2013/10/29/secure-execution-of-os-commands-by-abap-programs" target="_blank" rel="noopener">блоге</a>.</p>
<p>&nbsp;</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/">Файловый интерфейс — операции с файлами</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-operacii-s-fajlami/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Файловый интерфейс ABAP – контроль доступа и блокировки</title>
		<link>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-kontrol-dostupa-i-blokirovki/</link>
					<comments>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-kontrol-dostupa-i-blokirovki/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Mon, 09 Sep 2013 08:07:56 +0000</pubDate>
				<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[проверка полномочий]]></category>
		<category><![CDATA[файловый интерфейс]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=1639</guid>

					<description><![CDATA[<p>При работе с файлами, на стороне сервера приложений, срабатывает множество неявных проверок на полномочия: Проверка со стороны ОС Проверка на обработку директорий Проверка на обработку файлов Прочие системные проверки Далее более подробно о каждой из них. &#160; &#160; Проверки операционной системы Сервер приложений, запускается под определенным пользователем ОС, для этого пользователя должны быть настроены проверки [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-kontrol-dostupa-i-blokirovki/">Файловый интерфейс ABAP – контроль доступа и блокировки</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/cpanel-remote-access-keys.jpg"><img loading="lazy" class="size-full wp-image-1640 alignleft" style="margin: 10px;" src="http://abap-blog.ru/wp-content/uploads/2013/09/cpanel-remote-access-keys.jpg" alt="cpanel-remote-access-keys" width="265" height="270" /></a></p>
<p>При работе с файлами, на стороне сервера приложений, срабатывает множество неявных проверок на полномочия:</p>
<ul>
<li>Проверка со стороны ОС</li>
<li>Проверка на обработку директорий</li>
<li>Проверка на обработку файлов</li>
<li>Прочие системные проверки</li>
</ul>
<p>Далее более подробно о каждой из них.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span id="more-1639"></span><strong>Проверки операционной системы</strong></p>
<p>Сервер приложений, запускается под определенным пользователем ОС, для этого пользователя должны быть настроены проверки полномочий на уровне ОС. Если для пользователя не будет хватать прав, операторы файлового интерфейса будут возвращать код ошибки sy-subrc отличный от нуля, либо вызывать исключения. В зависимости от ОС, настройка полномочий будет отличаться, более подробно необходимо смотреть в справочной информации к ОС.</p>
<p><strong>Доступ к директориям</strong></p>
<p>Для операторов OPEN DATASET, READ DATASET, TRANSFER и DELETE DATASET срабатывают автоматические проверки, описанные в системной таблице – SPTH:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/spth.png"><img loading="lazy" class="alignnone size-full wp-image-1641" src="http://abap-blog.ru/wp-content/uploads/2013/09/spth.png" alt="spth" width="858" height="264" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/spth.png 858w, https://abap-blog.ru/wp-content/uploads/2013/09/spth-300x92.png 300w" sizes="(max-width: 858px) 100vw, 858px" /></a></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="102"><b>Поле</b></td>
<td valign="top" width="536"><b>Значение</b></td>
</tr>
<tr>
<td valign="top" width="102">PATH</td>
<td valign="top" width="536">Путь к директории</td>
</tr>
<tr>
<td valign="top" width="102">SAVEFLAG</td>
<td valign="top" width="536">Если значение &#171;X&#187;, файлы из директории PATH включаются в процедуру резервного копирования.</td>
</tr>
<tr>
<td valign="top" width="102">FS_NOREAD</td>
<td valign="top" width="536">Если данное поле имеет значение &#171;X&#187;, файлы из директории PATH, не могут быть открыты для чтения из ABAP. Данное значение перекрывает поле FS_NOWRITE, и FS_BRGRU, а так же проверки объекта S_DATASET.</td>
</tr>
<tr>
<td valign="top" width="102">FS_NOWRITE</td>
<td valign="top" width="536">Если данное поле имеет значение &#171;X&#187;, файлы из директории PATH не могут быть открыты для записи в ABAP. Данное значение перекрывает FS_BRGRU, а так же проверки  объекта S_DATASET.</td>
</tr>
<tr>
<td valign="top" width="102">FS_BRGRU</td>
<td valign="top" width="536">В данном поле содержится группа полномочий. Группа определяется в объекте S_PATH:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/s_path.png"><img loading="lazy" class="alignnone size-full wp-image-1642" style="margin-left: 10px; margin-right: 10px;" src="http://abap-blog.ru/wp-content/uploads/2013/09/s_path.png" alt="s_path" width="532" height="582" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/s_path.png 532w, https://abap-blog.ru/wp-content/uploads/2013/09/s_path-274x300.png 274w" sizes="(max-width: 532px) 100vw, 532px" /></a></p>
<p>Ведение групп полномочий осуществляется в ракурсе: <b>V_SPT</b></td>
</tr>
</tbody>
</table>
<p>Пример таблицы:</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top"><b>PATH</b></td>
<td valign="top"><b>SAVEFLAG</b></td>
<td valign="top"><b>FS_NOREAD</b></td>
<td valign="top"><b>FS_NOWRITE</b></td>
<td valign="top"><b>FS_BRGRU</b></td>
</tr>
<tr>
<td valign="top">*</td>
<td valign="top">&#8212;</td>
<td valign="top">X</td>
<td valign="top">X</td>
<td valign="top">&#8212;</td>
</tr>
<tr>
<td valign="top">/tmp</td>
<td valign="top">&#8212;</td>
<td valign="top">&#8212;</td>
<td valign="top">&#8212;</td>
<td valign="top">&#8212;</td>
</tr>
<tr>
<td valign="top">/tmp/myfiles</td>
<td valign="top">X</td>
<td valign="top">&#8212;</td>
<td valign="top">&#8212;</td>
<td valign="top">FILE</td>
</tr>
</tbody>
</table>
<p>Записи означают следующее:</p>
<ul>
<li>В первой строке включается запрет на изменение и запись всех файлов на сервере приложений, за исключением директории /tmp.</li>
<li>Во второй строке разрешается изменение и чтение всех файлов (за исключением директории /myfiles), не зависимо от группы полномочий, при этом файлы не участвуют в системе резервного копирования.</li>
<li>В третьей строке разрешается запись и изменение файлов, при наличии группы полномочий FILE, файлы из данной директории включаются в резервное копирование.</li>
</ul>
<p><strong>Проверки, относящиеся к специальным файлам</strong></p>
<p>Доступ к файлам с расширением .pse (Personal Security Environment), проверяется через объект полномочий: S_RZL_ADM, необходимо чтобы в поле ACTVT было значение 01.</p>
<p><strong>Доступ к файлам через объект S_DATASET</strong></p>
<p>Каждый раз, когда происходит обработка файлов через интерфейс, система неявно вызывает проверку объекта полномочий S_DATASET (тр. <b>SU21</b>):</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/s_dataset.png"><img loading="lazy" class="alignnone size-full wp-image-1643" src="http://abap-blog.ru/wp-content/uploads/2013/09/s_dataset.png" alt="s_dataset" width="532" height="582" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/s_dataset.png 532w, https://abap-blog.ru/wp-content/uploads/2013/09/s_dataset-274x300.png 274w" sizes="(max-width: 532px) 100vw, 532px" /></a></p>
<p>Данный объект содержит следующие поля: PROGRAM &#8212; в котором определено имя программы, FILENAME &#8212; физическое имя файла, и ACTVT &#8212; обозначающее действие над файлом. Если пользователь не обладает необходимыми полномочиями, вызывается обрабатываемое исключение. Для того чтобы избежать вызова исключения, можно заранее проверить полномочия с помощью ФМ: <b>AUTHORITY_</b><b>CHECK_</b><b>DATASET</b>, или стандартной проверкой полномочий оператором AUTHORITY-CHECK.</p>
<p>Пример проверки полномочий:</p><pre class="urvanov-syntax-highlighter-plain-tag">TYPE-POOLS sabc.

CALL FUNCTION 'AUTHORITY_CHECK_DATASET'
  EXPORTING
    program          = 'ZDATASET'
    activity         = sabc_act_read
    filename         = '/tmp/sapv01'
  EXCEPTIONS
    no_authority     = 1
    activity_unknown = 2.</pre><p><strong>Блокировка файлов</strong></p>
<p>Файловый интерфейс не содержит встроенного механизма блокировки. Могут возникать ситуации, когда один файл обрабатывается сразу несколькими программами одновременно. Если несколько программ ведут запись в один файл одновременно, результат подобных действий будет непредсказуемым.</p>
<p>Для того чтобы избежать подобных ситуаций, можно воспользоваться <a href="http://abap-blog.ru/abap/optimizaciya_integrazia/koncepciya-blokirovok-v-sap/">концепцией блокировок SAP</a>, либо использовать уникальные имена файлов через генерацию GUID (<a href="http://help.sap.com/abapdocu_702/en/abencl_system_uuid.htm">UUID</a>).</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-kontrol-dostupa-i-blokirovki/">Файловый интерфейс ABAP – контроль доступа и блокировки</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-kontrol-dostupa-i-blokirovki/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Файловый интерфейс ABAP &#8212; логические и физические имена файлов</title>
		<link>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-log-phys-name/</link>
					<comments>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-log-phys-name/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 01 Sep 2013 07:51:38 +0000</pubDate>
				<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[файловый интерфейс]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=1611</guid>

					<description><![CDATA[<p>Для манипуляций с файлами на стороне сервера приложений был разработан файловый интерфейс ABAP. Данный интерфейс реализован набором операторов ABAP и их атрибутов. Как будет видно в следующих статьях, интерфейс позволяет работать с файлами на абстрактном уровне, где ключевым объектом является набор данных (dataset). Набор данных это нечто вроде файлового дескриптора, при программировании работы с файлами [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-log-phys-name/">Файловый интерфейс ABAP — логические и физические имена файлов</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/images1.jpg"><img loading="lazy" class="size-full wp-image-1630 alignleft" style="margin: 5px;" src="http://abap-blog.ru/wp-content/uploads/2013/09/images1.jpg" alt="images" width="250" height="200" /></a>Для манипуляций с файлами на стороне сервера приложений был разработан файловый интерфейс ABAP.</p>
<p>Данный интерфейс реализован набором операторов ABAP и их атрибутов. Как будет видно в следующих статьях, интерфейс позволяет работать с файлами на абстрактном уровне, где ключевым объектом является набор данных (dataset).</p>
<p>Набор данных это нечто вроде файлового дескриптора, при программировании работы с файлами в ОС, на других языках. Так же, как и с дескрипторами, в ABAP можно одновременно работать с несколькими файлами (Читать из одного, а записывать в другой и т.п.), но открывать один и тот же файл без его закрытия в рамках одной программы невозможно (для юникодных программ, для не юникодных программ повторное открытие не приведет к ошибке, но будет проигнорировано).</p>
<p>Следует помнить, так как файловый интерфейс предназначен для работы с текущим сервером приложений, могут возникнуть трудности в системах с несколькими серверами приложений.</p>
<p>В данной статье рассмотрен вопрос хранения путей для директорий и файлов, вне зависимости от ОС и сервера приложений.</p>
<p><span id="more-1611"></span></p>
<h2>Физические и логические имена файлов</h2>
<p>Все операторы, используемые в файловом интерфейсе, оперируют физическими именами файлов, которые зависят от операционной системы, используемой на сервере приложений. Физическое имя файла представляет из себя описание пути к файлу и его имя (C:\1.txt или /home/123.text).  Допускается использование пробелов в именах файлов. Если передано имя файла, без указания пути к нему, по умолчанию путь к файлу берется из профильного параметра <b>DIR_</b><b>HOME</b> (редактируется в транзакции <b>RZ11</b>):</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/dir_home.png"><img loading="lazy" class="alignnone size-full wp-image-1612" src="http://abap-blog.ru/wp-content/uploads/2013/09/dir_home.png" alt="dir_home" width="599" height="321" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/dir_home.png 599w, https://abap-blog.ru/wp-content/uploads/2013/09/dir_home-300x160.png 300w" sizes="(max-width: 599px) 100vw, 599px" /></a></p>
<p>Имена файлов и директорий можно хранить как текстовые константы в ABAP коде, однако для этого необходимо учитывать то, на какой ОС работает сервер приложений, а если их несколько? Кроме того необходимо иметь возможность генерации имен файлов в зависимости от тех или иных параметров.  Облегчить данную задачу поможет концепция логических имен.</p>
<p>Для манипуляции с файлами вне зависимости от платформы, были разработаны логические имена файлов, по сути, являющиеся записью в таблице БД, в которой для каждой ОС обозначен свой физический путь и правила его формирования.</p>
<p>Задать логические имена файлов можно двумя способами:</p>
<ul>
<li>Для независимых от манданта имен файлов, через транзакцию <b>FILE</b></li>
<li>Для зависимых через транзакцию <b>SF01</b></li>
</ul>
<p>Первым делом настраивается определение синтаксической группы (набора правил наименования файлов), для операционной системы:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/syntax_group.png"><img loading="lazy" class="alignnone size-full wp-image-1613" src="http://abap-blog.ru/wp-content/uploads/2013/09/syntax_group.png" alt="syntax_group" width="774" height="221" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/syntax_group.png 774w, https://abap-blog.ru/wp-content/uploads/2013/09/syntax_group-300x85.png 300w" sizes="(max-width: 774px) 100vw, 774px" /></a></p>
<p>На данном шаге определяются:</p>
<ul>
<li>Код синтаксической группы</li>
<li>Название синтаксической группы</li>
<li>Максимальная длинна имени файла</li>
<li>Использовать ли в качестве расширения формат файла (TXT, BIN и т.п.)</li>
<li>Активность данной группы</li>
</ul>
<p>После определения синтаксической группы необходимо присвоить её для ОС:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/syntax_group2.png"><img loading="lazy" class="alignnone size-full wp-image-1614" src="http://abap-blog.ru/wp-content/uploads/2013/09/syntax_group2.png" alt="syntax_group2" width="671" height="151" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/syntax_group2.png 671w, https://abap-blog.ru/wp-content/uploads/2013/09/syntax_group2-300x67.png 300w" sizes="(max-width: 671px) 100vw, 671px" /></a></p>
<p>При получении физического имени файла по логическому, в качестве ОС будет взято значение из системного параметра <b>sy-</b><b>opsys</b>.</p>
<p>Далее необходимо определить логический путь к файлу, т.е. директорию, в которой он будет обрабатываться:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/logical_path.png"><img loading="lazy" class="alignnone size-full wp-image-1615" src="http://abap-blog.ru/wp-content/uploads/2013/09/logical_path.png" alt="logical_path" width="778" height="431" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/logical_path.png 778w, https://abap-blog.ru/wp-content/uploads/2013/09/logical_path-300x166.png 300w" sizes="(max-width: 778px) 100vw, 778px" /></a></p>
<p>Для каждого из логического пути можно настроить присвоение физического пути, относительно платформы:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/phys_path.png"><img loading="lazy" class="alignnone size-full wp-image-1616" src="http://abap-blog.ru/wp-content/uploads/2013/09/phys_path.png" alt="phys_path" width="780" height="134" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/phys_path.png 780w, https://abap-blog.ru/wp-content/uploads/2013/09/phys_path-300x51.png 300w" sizes="(max-width: 780px) 100vw, 780px" /></a></p>
<p>Как видно из рисунка, физический путь представляет из себя специальную строку с параметрами. Могут быть использованы следующие параметры:</p>
<ul>
<li>&lt;FILENAME&gt; &#8212; подставляется значение из физического файла (см. ниже)</li>
<li>&lt;OPSYS&gt; &#8212; название ОС</li>
<li>&lt;INSTANCE&gt; &#8212; название инстанции сервера приложений</li>
<li>&lt;SYSID&gt; &#8212; SY-SYSID</li>
<li>&lt;DBSYS&gt; &#8212; SY-DBSYS</li>
<li>&lt;SAPRL&gt; &#8212; SY-SAPRL</li>
<li>&lt;HOST&gt; &#8212; SY-HOST</li>
<li>&lt;CLIENT&gt; &#8212; SY-MANDT</li>
<li>&lt;LANGUAGE&gt; &#8212; SY-LANGU</li>
<li>&lt;DATE&gt; &#8212; SY-DATUM</li>
<li>&lt;YEAR&gt; &#8212; SY-DATUM, 4-символа</li>
<li>&lt;SYEAR&gt; &#8212; SY-DATUM, 2-символа</li>
<li>&lt;MONTH&gt; &#8212; SY-DATUM</li>
<li>&lt;DAY&gt; &#8212; SY-DATUM</li>
<li>&lt;WEEKDAY&gt; &#8212; SY-FDAYW</li>
<li>&lt;TIME&gt; &#8212; SY-UZEIT</li>
<li>&lt;STIME&gt; &#8212; SY-UZEIT</li>
<li>&lt;HOUR&gt; &#8212; SY-UZEIT</li>
<li>&lt;MINUTE&gt; &#8212; SY-UZEIT</li>
<li>&lt;SECOND&gt; &#8212; SY-UZEIT</li>
<li>&lt;PARAM_1&gt; &#8212; внешний параметр 1 (Заполняются в ФМ получения физ. имени файла)</li>
<li>&lt;PARAM_2&gt; &#8212; внешний параметр 2</li>
<li>&lt;PARAM_3&gt; &#8212; внешний параметр 3</li>
<li>&lt;P=name&gt; &#8212; в качестве имени указывается имя параметра из RZ11</li>
<li>&lt;V=name&gt; &#8212; имя переменной</li>
</ul>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/variable.png"><img loading="lazy" class="alignnone size-full wp-image-1617" src="http://abap-blog.ru/wp-content/uploads/2013/09/variable.png" alt="variable" width="717" height="158" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/variable.png 717w, https://abap-blog.ru/wp-content/uploads/2013/09/variable-300x66.png 300w" sizes="(max-width: 717px) 100vw, 717px" /></a></p>
<ul>
<li> &lt;F=name&gt; &#8212; возвращает результат ФМ с именем: FILENAME_EXIT_name, пример:</li>
</ul>
<p></p><pre class="urvanov-syntax-highlighter-plain-tag">FUNCTION FILENAME_EXIT_EXAMPLE.
*"----------------------------------------------------------------------
*"Lokale Schnittstelle:
*"       EXPORTING
*"             OUTPUT
*"----------------------------------------------------------------------
 OUTPUT = SY-UNAME.
ENDFUNCTION.</pre><p></p>
<ul>
<li>&lt;Y=name&gt; &#8212; аналогично с ФМ: Y_FILENAME_EXIT_name</li>
<li>&lt;Z=name&gt; &#8212; аналогично с ФМ: Z_FILENAME_EXIT_name</li>
</ul>
<p>Далее настраиваются логические имена файлов:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/phys_names.png"><img loading="lazy" class="alignnone size-full wp-image-1618" src="http://abap-blog.ru/wp-content/uploads/2013/09/phys_names.png" alt="phys_names" width="731" height="146" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/phys_names.png 731w, https://abap-blog.ru/wp-content/uploads/2013/09/phys_names-300x59.png 300w" sizes="(max-width: 731px) 100vw, 731px" /></a></p>
<p>Для логического файла определяются:</p>
<ul>
<li>Его название</li>
<li>Физический путь, правила заполнения аналогичны для физ. пути для директорий</li>
<li>Формат данных – может использоваться в качестве расширения файла (если установлена соответствующая настройка, см. выше).</li>
<li>Прикладная область</li>
<li>Логический путь</li>
</ul>
<p>После необходимых настроек, получить физическое имя файла, по его логическому имени, можно через ФМ <b>FILE_GET_NAME </b>(или воспользоваться классом &#8212; CL_FS_PATH).</p>
<p>Параметры импорта:</p>
<ul>
<li>CLIENT &#8212; мандант</li>
<li>LOGICAL_FILENAME – логическое имя файла (обязательно в верхнем регистре)</li>
<li>OPERATING_SYSTEM &#8212; ОС</li>
<li>PARAMETER_1 – внешний параметр  1 (рассмотрены выше, при описании физ. пути)</li>
<li>PARAMETER_2 – внешний параметр  2</li>
<li>PARAMETER_3 – внешний параметр  3</li>
<li>USE_PRESENTATION_SERVER – использовать название ОС с сервера представления</li>
<li>WITH_FILE_EXTENSION – использовать в качестве расширения формат файла (для формата данных DIR игнорируется)</li>
<li>USE_BUFFER &#8212; использование буфера при чтении данных из таблиц</li>
<li>ELEMINATE_BLANKS – убрать все пробелы из имени файла</li>
<li>INCLUDING_DIR &#8212; в большинстве случаев ФМ используется для получения имен файлов. Если в пользовательской настройке определен формат данных DIR, система возвратит физический путь к директории, но только если данный индикатор будет выставлен в &#8216;X&#8217;. Индикатор не установлен по умолчанию, система ожидает что будет получен именно физический путь<strong> к файлу</strong> и если при этом был выставлен формат DIR, произойдет исключение &#8212; FILE_NOT_FOUND.</li>
</ul>
<p>Параметры экспорта:</p>
<ul>
<li>EMERGENCY_FLAG – если данный параметр не пустой, физический путь не был считан. В данной ситуации в качестве пути будет использовано значение из профильного параметра <b>DIR_</b><b>GLOBAL</b>.</li>
<li>FILE_FORMAT – формат файла</li>
<li>FILE_NAME – физический путь к файлу</li>
</ul>
<p>Исключения:</p>
<ul>
<li>FILE_NOT_FOUND – вызывается, если физическое имя файла не определено.</li>
</ul>
<p>Пример вызова:</p><pre class="urvanov-syntax-highlighter-plain-tag">CALL FUNCTION 'FILE_GET_NAME'
     EXPORTING
           LOGICAL_FILENAME        = 'DATA_FILE'
           PARAMETER_1             = '01'
     IMPORTING
           EMERGENCY_FLAG          = LD_EMERGENCY_FLAG
           FILE_FORMAT             = LD_FILE_FORMAT
           FILE_NAME               = LD_FILE_NAME
     EXCEPTIONS
           FILE_NOT_FOUND          = 1
           OTHERS                  = 2.</pre><p>Для экранов часто требуется позволить пользователю выбрать логическое имя файла, можно сделать через ФМ:</p>
<ul>
<li>FILE_LOGFILE_ALIAS_PBO</li>
<li>FILE_LOGFILE_ALIAS_PAI,</li>
<li>FILE_LOGFILE_ALIAS_F4</li>
</ul>
<p>Пример:</p><pre class="urvanov-syntax-highlighter-plain-tag">PARAMETERS:
  p_fname TYPE FILEINTERN.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_fname.
  CALL FUNCTION 'FILE_LOGFILE_ALIAS_F4'
    EXPORTING
      ed_logfile_appl     = p_fname
    CHANGING
      cd_logical_file     = p_fname
    EXCEPTIONS
      exc_no_values_found = 1
      others              = 2.</pre><p><a href="http://abap-blog.ru/wp-content/uploads/2013/09/f4.png"><img loading="lazy" class="alignnone size-full wp-image-1619" src="http://abap-blog.ru/wp-content/uploads/2013/09/f4.png" alt="f4" width="719" height="283" srcset="https://abap-blog.ru/wp-content/uploads/2013/09/f4.png 719w, https://abap-blog.ru/wp-content/uploads/2013/09/f4-300x118.png 300w" sizes="(max-width: 719px) 100vw, 719px" /></a></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-log-phys-name/">Файловый интерфейс ABAP — логические и физические имена файлов</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/files/fajlovyj-interfejs-abap-log-phys-name/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Выгрузить данные из ALV в XML с произвольной структурой</title>
		<link>https://abap-blog.ru/osnovy-abap/sap-dynpro/vygruzit-dannye-iz-alv-v-xml-s-proizvolnoj-strukturoj/</link>
					<comments>https://abap-blog.ru/osnovy-abap/sap-dynpro/vygruzit-dannye-iz-alv-v-xml-s-proizvolnoj-strukturoj/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Thu, 05 Jul 2012 04:33:45 +0000</pubDate>
				<category><![CDATA[SAP Dynpro]]></category>
		<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[abap upload]]></category>
		<category><![CDATA[ALV]]></category>
		<category><![CDATA[XML]]></category>
		<category><![CDATA[Преобразование]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=869</guid>

					<description><![CDATA[<p>Задача: результат работы стандартного отчёта необходимо выгрузить в XML файл, с применением определенных правил построения XML (заданной схемой). &#160; В качестве решения будут использованы шаблоны для ракурса Microsoft Excel в ALV. Инструкцию о том как их использовать вы можете найти на сайте sapland.ru Excel будет выступать в качестве конвертора. Выгрузив файл через стандартный шаблон в [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/sap-dynpro/vygruzit-dannye-iz-alv-v-xml-s-proizvolnoj-strukturoj/">Выгрузить данные из ALV в XML с произвольной структурой</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Задача: результат работы стандартного отчёта необходимо выгрузить в XML файл, с применением определенных правил построения XML (заданной схемой).</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2012/07/Безымянный.png"><img loading="lazy" class="alignleft size-full wp-image-870" title="Безымянный" src="http://abap-blog.ru/wp-content/uploads/2012/07/Безымянный.png" alt="" width="786" height="70" srcset="https://abap-blog.ru/wp-content/uploads/2012/07/Безымянный.png 786w, https://abap-blog.ru/wp-content/uploads/2012/07/Безымянный-300x26.png 300w" sizes="(max-width: 786px) 100vw, 786px" /></a></p>
<p>&nbsp;</p>
<p>В качестве решения будут использованы шаблоны для ракурса Microsoft Excel в ALV. Инструкцию о том как их использовать вы можете найти на сайте <a title="SapLand.ru" href="http://sapland.ru" target="_blank" rel="noopener">sapland.ru</a> Excel будет выступать в качестве конвертора.</p>
<p><span id="more-869"></span>Выгрузив файл через стандартный шаблон в Excel, мы получим лишь электронную таблицу без возможности выгрузки в нужном нам XML формате.</p>
<p>Для того чтобы иметь возможность сохранить в нужном формате, необходимо использовать возможности Excel по выгрузке XML, а именно XML карты. В excel карты выглядят примерно следующим образом:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2012/07/schm.png"><img loading="lazy" class="size-full wp-image-871 alignnone" title="schm" src="http://abap-blog.ru/wp-content/uploads/2012/07/schm.png" alt="" width="251" height="245" /></a></p>
<p>Открыть этот инструмент можно через панель – разработчик. Карта представляет собой структуру XML файла, элементы карты можно присваивать полям Excel документа. Предположим, что нам необходимо на выходе получать следующий формат:</p><pre class="urvanov-syntax-highlighter-plain-tag">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;tenderposition_import&gt;
         &lt;tenderpositions&gt;
          &lt;tenderposition&gt;
             &lt;amount&gt;10.00&lt;/amount&gt;
             &lt;maxprice&gt;1200&lt;/maxprice&gt;
             &lt;gost&gt;ГОСТ 22123456&lt;/gost&gt;
             &lt;units&gt;пачки.&lt;/units&gt;
             &lt;comment&gt;Комментарий2&lt;/comment&gt;
             &lt;title&gt;Вытяжка Krona Elis 60022 (тестовый товар)&lt;/title&gt;
             &lt;description&gt;&lt;/description&gt;
           &lt;/tenderposition&gt;
         &lt;/tenderpositions&gt;
&lt;/tenderposition_import&gt;</pre><p>Для данного XML файла нам необходимо составить соответствующую карту (см. рисунок наверху). Карта может быть составлена на основе XML документа или XSD схемы. Нас интересует второй вариант. Т.к. схему нам хранить не нужно, создавать мы ее будем динамически. Присваивать элементы полям Excel так же динамически.</p>
<p>Один из вариантов создания XSD схемы:</p><pre class="urvanov-syntax-highlighter-plain-tag">Sub BuildXSD()
   Dim StrMyXml As String, MyMap As XmlMap
   Dim StrMySchema As String
   Dim slideName As String
   Dim currentMap As XmlMap
   Dim processComments As Boolean

   For Each currentMap In ActiveWorkbook.XmlMaps
       ActiveWorkbook.XmlMaps(currentMap.Name).Delete
   Next

  StrMyXml = "&lt;?xml version=""1.0"" encoding=""UTF-8"" standalone=""no"" ?&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:schema xmlns:xsd=""http://www.w3.org/2001/XMLSchema""&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""tenderposition_import""&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:complexType&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:sequence&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""tenderpositions""&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:complexType&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:sequence&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element minOccurs=""0"" maxOccurs=""unbounded"" name=""tenderposition""&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:complexType&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:sequence&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""amount"" type=""xsd:string""/&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""maxprice"" type=""xsd:string""/&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""gost"" type=""xsd:string""/&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""units"" type=""xsd:string""/&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""comment"" type=""xsd:string""/&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""title"" type=""xsd:string""/&gt;"
  StrMyXml = StrMyXml &amp; "&lt;xsd:element name=""description"" type=""xsd:string""/&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:sequence&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:complexType&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:element&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:sequence&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:complexType&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:element&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:sequence&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:complexType&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:element&gt;"
  StrMyXml = StrMyXml &amp; "&lt;/xsd:schema&gt;"

  Set MyMap = ThisWorkbook.XmlMaps.Add(StrMyXml)
  MyMap.ShowImportExportValidationErrors = True
  MyMap.PreserveColumnFilter = True
  MyMap.PreserveNumberFormatting = True
  MyMap.AdjustColumnWidth = True
  MyMap.Name = "mymap"

  StrMySchema = ThisWorkbook.XmlMaps(1).Schemas(1).XML
End Sub</pre><p>Как видно из кода мы заранее подготовленную схему XSD загружаем в Excel. Далее необходимо привязать слолбцы к нужным XML полям:</p><pre class="urvanov-syntax-highlighter-plain-tag">Sub CreateList()
   Dim lstContacts As ListObject
   Set mapContact = ActiveWorkbook.XmlMaps(1)

   For Each lstContacts In ActiveSheet.ListObjects
       lstContacts.Unlist
   Next

   Set lstContacts = ActiveSheet.ListObjects.Add(Destination:=ThisWorkbook.ActiveSheet.Range("A:G"))
   lstContacts.ShowTableStyleColumnStripes = True

   strXPath = "/tenderposition_import/tenderpositions/tenderposition/amount"
   lstContacts.ListColumns(1).XPath.SetValue mapContact, strXPath

   strXPath = "/tenderposition_import/tenderpositions/tenderposition/maxprice"
   lstContacts.ListColumns(2).XPath.SetValue mapContact, strXPath

   strXPath = "/tenderposition_import/tenderpositions/tenderposition/gost"
   lstContacts.ListColumns(3).XPath.SetValue mapContact, strXPath

   strXPath = "/tenderposition_import/tenderpositions/tenderposition/units"
   lstContacts.ListColumns(4).XPath.SetValue mapContact, strXPath

   strXPath = "/tenderposition_import/tenderpositions/tenderposition/comment"
   lstContacts.ListColumns(5).XPath.SetValue mapContact, strXPath

   strXPath = "/tenderposition_import/tenderpositions/tenderposition/title"
   lstContacts.ListColumns(6).XPath.SetValue mapContact, strXPath

   strXPath = "/tenderposition_import/tenderpositions/tenderposition/description"
   lstContacts.ListColumns(7).XPath.SetValue mapContact, strXPath
End Sub</pre><p>Описывать работу с внутренними объектами VBA не стану, все можно найти по F1. Теперь необходимо вызвать данные процедуры во время открытия листа (например – Format). После чего данные на листе будут связаны с картой, их можно будет сохранить в нужном xml формате. Обратите внимание на код связывания, там жестко прописаны номера столбцов с данными. В результате связывания должно получится что-то вроде этого:</p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2012/07/done.png"><img loading="lazy" class="alignleft size-full wp-image-872" title="done" src="http://abap-blog.ru/wp-content/uploads/2012/07/done.png" alt="" width="794" height="634" srcset="https://abap-blog.ru/wp-content/uploads/2012/07/done.png 794w, https://abap-blog.ru/wp-content/uploads/2012/07/done-300x239.png 300w" sizes="(max-width: 794px) 100vw, 794px" /></a></p>
<p>&nbsp;</p>
<p>Сохранив в виде XML получим необходимую нам структуру. Таким образом, используя Excel в качестве конвертора, можно выгружать данные из ALV в XML с любой структурой.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/sap-dynpro/vygruzit-dannye-iz-alv-v-xml-s-proizvolnoj-strukturoj/">Выгрузить данные из ALV в XML с произвольной структурой</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/sap-dynpro/vygruzit-dannye-iz-alv-v-xml-s-proizvolnoj-strukturoj/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Работа с MIME репозитарием</title>
		<link>https://abap-blog.ru/osnovy-abap/rabota-s-mime-repozitariem/</link>
					<comments>https://abap-blog.ru/osnovy-abap/rabota-s-mime-repozitariem/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Fri, 13 Apr 2012 04:57:45 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[Сетевые технологии]]></category>
		<category><![CDATA[cl_mime_repository_api]]></category>
		<category><![CDATA[if_mr_api]]></category>
		<category><![CDATA[MIME репозитарий]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=709</guid>

					<description><![CDATA[<p>Работа с MIME репозитарием через ABAP возможна используя класс:  cl_mime_repository_api. Пример его использования: [crayon-618a04f067688982366338/]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/rabota-s-mime-repozitariem/">Работа с MIME репозитарием</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Работа с MIME репозитарием через ABAP возможна используя класс:  <strong>cl_mime_repository_api. </strong>Пример его использования:</p><pre class="urvanov-syntax-highlighter-plain-tag">REPORT ZMIME_API.

DATA: go_mime_api TYPE REF TO if_mr_api,
      gv_x_str    TYPE XSTRING,
      gv_str      TYPE STRING.

" Создает экземпляр класса для работы с репозитарием
go_mime_api = cl_mime_repository_api=&gt;get_api( ).

gv_str = 'Hello World!'.

" Преобразуем в XSTRING
CALL FUNCTION 'HR_KR_STRING_TO_XSTRING'
  EXPORTING
    unicode_string         = gv_str
  IMPORTING
    XSTRING_STREAM         = gv_x_str
  EXCEPTIONS
    INVALID_CODEPAGE       = 1
    INVALID_STRING         = 2
    OTHERS                 = 3.

" Запищем в репозитарий.
go_mime_api-&gt;put(
  EXPORTING
    i_url                     = '/SAP/BC/BSP/SAP/.../TEST.TXT'
    i_content                 = gv_x_str
  EXCEPTIONS
    parameter_missing         = 1
    error_occured             = 2
    cancelled                 = 3
    permission_failure        = 4
    data_inconsistency        = 5
    new_loio_already_exists   = 6
    is_folder                 = 7
    OTHERS                    = 8
).

IF sy-subrc &lt;&gt; 0.
 MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
ENDIF.

CLEAR: gv_x_str, gv_str.

" Прочитаем содержимое из репозитария
go_mime_api-&gt;get(
  EXPORTING
    i_url                  = '/SAP/BC/BSP/SAP/.../TEST.TXT'
  IMPORTING
    e_content              = gv_x_str
  EXCEPTIONS
    parameter_missing      = 1
    error_occured          = 2
    not_found              = 3
    permission_failure     = 4
    OTHERS                 = 5
).

IF sy-subrc &lt;&gt; 0.
  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
ENDIF.

" Преобразуем обратно в строку
CALL FUNCTION 'HR_KR_XSTRING_TO_STRING'
  EXPORTING
    in_xstring          = gv_x_str
  IMPORTING
    out_string          = gv_str.

WRITE gv_str.</pre><p></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/rabota-s-mime-repozitariem/">Работа с MIME репозитарием</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/rabota-s-mime-repozitariem/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Обновление MIME хранилища для BSP приложений</title>
		<link>https://abap-blog.ru/osnovy-abap/obnovlenie-mime-xranilishha-dlya-bsp-prilozhenij/</link>
					<comments>https://abap-blog.ru/osnovy-abap/obnovlenie-mime-xranilishha-dlya-bsp-prilozhenij/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sun, 18 Mar 2012 06:09:05 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[Сетевые технологии]]></category>
		<category><![CDATA[bsp]]></category>
		<category><![CDATA[MIME]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=596</guid>

					<description><![CDATA[<p>Для обновления хранилища можно воспользоваться программой: BSP_UPDATE_MIMEREPOS</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/obnovlenie-mime-xranilishha-dlya-bsp-prilozhenij/">Обновление MIME хранилища для BSP приложений</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Для обновления хранилища можно воспользоваться программой: <strong>BSP_UPDATE_MIMEREPOS</strong></p>
<p><a href="http://abap-blog.ru/wp-content/uploads/2012/03/mime.png"><img loading="lazy" class="alignnone size-full wp-image-598" title="mime" src="http://abap-blog.ru/wp-content/uploads/2012/03/mime.png" alt="" width="851" height="415" srcset="https://abap-blog.ru/wp-content/uploads/2012/03/mime.png 851w, https://abap-blog.ru/wp-content/uploads/2012/03/mime-300x146.png 300w" sizes="(max-width: 851px) 100vw, 851px" /></a></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/obnovlenie-mime-xranilishha-dlya-bsp-prilozhenij/">Обновление MIME хранилища для BSP приложений</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/obnovlenie-mime-xranilishha-dlya-bsp-prilozhenij/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Считывание файлов с фронтенда</title>
		<link>https://abap-blog.ru/osnovy-abap/files/upload_from_frontend/</link>
					<comments>https://abap-blog.ru/osnovy-abap/files/upload_from_frontend/#comments</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Sat, 07 Jan 2012 06:48:11 +0000</pubDate>
				<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[sap gui]]></category>
		<category><![CDATA[файлы]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=120</guid>

					<description><![CDATA[<p>Загрузку файлов с фронтенда рекомендуется делать с помощью статического метода: cl_gui_frontend_services=&#62;gui_upload. Данный метод имеет множество параметров, описание которых я приведу далее. FILENAME &#8212; собственно имя файла из которого хотим считать информацию. FILETYPE &#8212; Тип файла, может принимать значения BIN, ASC, DAT. BIN &#8212; используется при считывании файла в байтовую последовательность. ASC &#8212; считывание как из текстового файла, [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/files/upload_from_frontend/">Считывание файлов с фронтенда</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>Загрузку файлов с фронтенда рекомендуется делать с помощью статического метода: <strong>cl_gui_frontend_services=&gt;gui_upload. </strong>Данный метод имеет множество параметров, описание которых я приведу далее.</p>
<p><span id="more-120"></span></p>
<p><strong>FILENAME </strong>&#8212; собственно имя файла из которого хотим считать информацию.</p>
<p><strong>FILETYPE </strong>&#8212; Тип файла, может принимать значения BIN, ASC, DAT. BIN &#8212; используется при считывании файла в байтовую последовательность. ASC &#8212; считывание как из текстового файла, DAT &#8212; тоже самое что и ASC, но при этом параметры has_field_separator, dat_mode  выставляются в &#8216;X&#8217;.</p>
<p><strong>HAS_FIELD_SEPARATOR </strong>&#8212; Параметр отвечает за разделение между строками текстового файла. Например если файл имеет следующую структуру и значение параметра &#8216;X&#8217;:</p>
<p>1 2 3 (tab) 4 5 6<br />
1 2 3 4 5 6</p>
<p>то дойдя до символа табуляции (cl_abap_char_utilities=&gt;horizontal_tab) программа решит что это конец строки и начнет считывать следующую строку. Если параметр пустой строка будет считана полностью пока не встретит разделителя строки (cl_abap_char_utilities=&gt;cr_lf), либо пока размер строки не превысит максимальный размер строки в таблице в которую происходит считывание &#8212; параметр <strong>DATA_TAB</strong>. Актуально для режимов ASC и DAT.</p>
<p><strong>HEADER_LENGTH</strong> &#8212; используется при бинарном считывании файла, указывает количество байтов заголовка файла, для его пропуска. Сам заголовок будет находится в параметре <strong>HEADER.</strong> Актуально для режима BIN.</p>
<p><strong>READ_BY_LINE</strong> &#8212; параметр &#8216;X&#8217; указывает на то что считывание происходит построчно, т.е. не в структуру. Таблица в которую считываем файл должна состоять из одного компонента (например char255). Актуально для режимов ASC и DAT.</p>
<p><strong>CODEPAGE &#8212; </strong>параметр указывает на то какую кодовую страницу необходимо использовать при считывании файла, если параметр пустой кодовая страница берется по умолчанию та в которой вошел пользователь &#8212; CL_GUI_FRONTEND_SERVICES=&gt;GET_SAPLOGON_ENCODING. Например для считывания файла в кодировке UTF-8 (Без BOM) необходимо использовать кодовую страницу &#8216;4110&#8217;. Актуально для режимов ASC и DAT.</p>
<p><strong>DAT_MODE </strong>&#8212; отвечает за считывание из файла компонентов структуры с типом D. В случае когда один компонентов имеет тип D необходимо выставлять параметр в &#8216;X&#8217;. Актуально для режимов ASC и DAT.</p>
<p><strong>IGNORE_CERR </strong>&#8212; В случае когда &#8216;X&#8217; ошибки связанные с конвертацией кодировки игнорируются. Актуально для режимов ASC и DAT.</p>
<p><strong>REPLACEMENT &#8212; </strong>Символ в который преобразуются символы которые не получилось преобразовать при перекодировании. Актуально для режимов ASC и DAT.</p>
<p><strong>VIRUS_SCAN_PROFILE &#8212; </strong>Указывает на профиль сканирования на вирусы, подробнее о сканировании на вирусы см в соответствующем разделе справки SAP.</p>
<p><strong>FILELENGTH &#8212; </strong>Передает размер файла в байтах.</p>
<p><strong>HEADER &#8212; </strong>см. параметр <strong>HEADER_LENGTH</strong> выше.</p>
<p><strong>DATA_TAB &#8212; </strong>собственно таблица в которую будут попадать считываемые данные из файла. Структура таблицы определяется в зависимости от структуры файла или задачи.</p>
<p>Помните! Данный метод нельзя использовать в фоновом режиме. Ну и напоследок пример с которым все это дело проверялось:</p><pre class="urvanov-syntax-highlighter-plain-tag">REPORT ztest.

PARAMETER p_file TYPE STRING LOWER CASE OBLIGATORY DEFAULT 'C:TempDemo.txt'.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
  cl_salv_test_data=&gt;select_file( IMPORTING filename = p_file ).

START-OF-SELECTION.
  TYPES: BEGIN OF ty_tab,
          col1 TYPE char1,
          col2 TYPE D,
         END OF ty_tab.

  DATA: lt_tab TYPE STANDARD TABLE OF ty_tab,
        lv_length TYPE I,
        lv_header TYPE XSTRING.

  FIELD-SYMBOLS: &lt;fs&gt; TYPE ty_tab.

  cl_gui_frontend_services=&gt;gui_upload(
    EXPORTING
      filename                = p_file
      filetype                = 'ASC'
      codepage                = '4110'
      dat_mode                = 'X'
    IMPORTING
      filelength              = lv_length
      header                  = lv_header
    CHANGING
      data_tab                = lt_tab
    EXCEPTIONS
      OTHERS                  = 99 ).
  IF sy-subrc &lt;&gt; 0.
   MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  WRITE: / 'Размер файла: ', lv_length,' Содержимое файла:'.
  LOOP AT lt_tab ASSIGNING &lt;fs&gt;.
    WRITE: / sy-tabix,':', 'Col1:', &lt;fs&gt;-col1,' Col2:', &lt;fs&gt;-col2 MMDDYY.
  ENDLOOP.</pre><p>Содержимое файла:<br />
А16.12.1986<br />
В16.12.1986</p>
<p>Пример считывания файла в RAW, последовательность байтов:</p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: l_filename TYPE STRING,
        l_rawtab   TYPE STANDARD TABLE OF raw255,
        l_len      TYPE I.

  MOVE p_filename TO l_filename.
  CALL METHOD cl_gui_frontend_services=&gt;gui_upload
    EXPORTING
      filename                = l_filename
      filetype                = 'BIN'
    IMPORTING
      filelength              = l_len
    CHANGING
      data_tab                = l_rawtab
    EXCEPTIONS
      OTHERS                  = 99.</pre><p></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/files/upload_from_frontend/">Считывание файлов с фронтенда</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/files/upload_from_frontend/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Выбор файлов на экране выбора</title>
		<link>https://abap-blog.ru/osnovy-abap/files/vibor-fajlov-na-ekrane/</link>
					<comments>https://abap-blog.ru/osnovy-abap/files/vibor-fajlov-na-ekrane/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Fri, 06 Jan 2012 05:37:25 +0000</pubDate>
				<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[sap gui]]></category>
		<category><![CDATA[сервер приложений]]></category>
		<category><![CDATA[средство поиска]]></category>
		<category><![CDATA[файлы]]></category>
		<category><![CDATA[экран выбора]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=109</guid>

					<description><![CDATA[<p>При работе с файлами в ABAP встает необходимость предоставить пользователю возможность выбора файла на экране выбора, для выбора файла на стороне клиента можно воспользоваться методом класса cl_gui_frontend_services=&#62;file_open_dialog или простой обёрткой над ним cl_salv_test_data=&#62;select_file. Далее будет продемонстрировано как предоставить пользователю выбор файла как на стороне клиента, так и на сервере приложений. [crayon-618a04f067d5e733534677/] Еще один способ выбора файла на сервере [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/files/vibor-fajlov-na-ekrane/">Выбор файлов на экране выбора</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p>При работе с файлами в ABAP встает необходимость предоставить пользователю возможность выбора файла на экране выбора, для выбора файла на стороне клиента можно воспользоваться методом класса <strong>cl_gui_frontend_services=&gt;file_open_dialog</strong> или простой обёрткой над ним <strong>cl_salv_test_data=&gt;select_file.</strong> Далее будет продемонстрировано как предоставить пользователю выбор файла как на стороне клиента, так и на сервере приложений.</p>
<p><span id="more-109"></span></p><pre class="urvanov-syntax-highlighter-plain-tag">DATA: l_true TYPE btch0000-char1.
DATA: v_file TYPE STRING,
      l_path TYPE dxlpath,
      l_abend_flag TYPE dxxabend,
      file TYPE filename,
      flag1 TYPE C.

DATA: it_fieldvalues TYPE STANDARD TABLE OF dynpread,
      wa_fieldvalues TYPE dynpread.

*----------------------------------------------------------------------*
* SELECTION- SCREEN
*----------------------------------------------------------------------*

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-001.
PARAMETERS: p_file(120) LOWER CASE OBLIGATORY.
PARAMETERS: p_appl RADIOBUTTON GROUP g1,
            p_pres RADIOBUTTON GROUP g1.
SELECTION-SCREEN END OF BLOCK b1.

*----------------------------------------------------------------------*
* AT SELECTION- SCREEN ( F4 functionality )
*----------------------------------------------------------------------*

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
  PERFORM f4_file_name.

*----------------------------------------------------------------------*
* START-OF-SELECTION.
*----------------------------------------------------------------------*

START-OF-SELECTION.
  IF p_appl = 'X'.
    PERFORM validate_server_file.
  ELSE.
    PERFORM validate_presentation_server.
  ENDIF.

*----------------------------------------------------------------------*
* END-OF-SELECTION
*----------------------------------------------------------------------*

END-OF-SELECTION.
  IF flag1 = 'X'.
    MESSAGE s777(hk) WITH 'Файл не существует'.
    CLEAR flag1.
  ELSE.
    WRITE 'Файл успешно выбран'.
  ENDIF.

*&amp;---------------------------------------------------------------------*
*&amp; Проверка существования файла на сервере приложений
*&amp;---------------------------------------------------------------------*
FORM validate_server_file.
  DATA: l_file TYPE tpfht-pffile.
  CLEAR l_file.
  l_file = p_file.

  CALL FUNCTION 'PFL_CHECK_OS_FILE_EXISTENCE'
    EXPORTING
      fully_qualified_filename = l_file
    IMPORTING
      file_exists              = l_true.

  IF l_true = SPACE.
    flag1 = 'X'.
    STOP.
  ENDIF.

ENDFORM.                    " validate_server_file

*&amp;---------------------------------------------------------------------*
*&amp; Проверка существования файла на сервере представления (фронтенде)
*&amp;---------------------------------------------------------------------*
FORM validate_presentation_server .
  DATA: RESULT,
        xfile TYPE STRING.
  xfile = p_file.

  CALL METHOD cl_gui_frontend_services=&gt;file_exist
    EXPORTING
      file   = xfile
    RECEIVING
      RESULT = RESULT.
  IF RESULT NE 'X'.
    flag1 = 'X'.
    STOP.
  ENDIF.

ENDFORM.                    "validate_presentation_server

*&amp;---------------------------------------------------------------------*
*&amp; Обработка F4 для поля с именем файла
*&amp;---------------------------------------------------------------------*
FORM f4_file_name .

  wa_fieldvalues-fieldname = 'P_PRES'.
  APPEND wa_fieldvalues TO it_fieldvalues.
  CLEAR wa_fieldvalues.

  wa_fieldvalues-fieldname = 'P_APPL'.
  APPEND wa_fieldvalues TO it_fieldvalues.
  CLEAR wa_fieldvalues.

  " Считаем значения экрана выбора
  CALL FUNCTION 'DYNP_VALUES_READ'
    EXPORTING
      dyname               = sy-repid
      dynumb               = sy-dynnr
    TABLES
      dynpfields           = it_fieldvalues
    EXCEPTIONS
      invalid_abapworkarea = 1
      invalid_dynprofield  = 2
      invalid_dynproname   = 3
      invalid_dynpronummer = 4
      invalid_request      = 5
      no_fielddescription  = 6
      invalid_parameter    = 7
      undefind_error       = 8
      double_conversion    = 9
      stepl_not_found      = 10
      OTHERS               = 11.

  READ TABLE it_fieldvalues INTO wa_fieldvalues WITH KEY fieldname = 'P_APPL'.

  " В зависимости от того что выбрано на экране выбора, будем запрашивать
  " либо файл на стороне сервера, либо на клиенте.
  IF wa_fieldvalues-fieldvalue = 'X'.
    PERFORM get_f4_application.
  ELSE.
    PERFORM get_f4_presentation.
  ENDIF.

ENDFORM.                    " f4_file_name

*&amp;---------------------------------------------------------------------*
*&amp; Открыть диалог выбора файла на клиенте
*&amp;---------------------------------------------------------------------*
FORM get_f4_presentation .

*-- F4 functionality for file name on Presentation Server
  DATA: l_file TYPE STRING.
  CALL METHOD cl_salv_test_data=&gt;select_file
    IMPORTING
      filename = l_file.

  p_file = l_file.

ENDFORM.                    " get_f4_presentation

*&amp;---------------------------------------------------------------------*
*&amp; Диалог выбора файлов на сервере
*&amp;---------------------------------------------------------------------*
FORM get_f4_application .

*-- F4 functionality for filename on Application Server
  CALL FUNCTION 'F4_DXFILENAME_TOPRECURSION'
    EXPORTING
      i_location_flag       = 'A'
      i_server              = ' '
      i_path                = '/secure_data/data_mig/dev'
    IMPORTING
      o_path                = l_path
      abend_flag            = l_abend_flag
    EXCEPTIONS
      communication_failure = 1
      system_failure        = 2
      rfc_error             = 3.
  IF sy-subrc EQ 0.
    p_file = l_path.
  ENDIF.
  IF l_abend_flag = 'X'.
    EXIT.  ENDIF.

ENDFORM.                    " get_f4_application</pre><p>Еще один способ выбора файла на сервере приложений:</p><pre class="urvanov-syntax-highlighter-plain-tag">SELECTION-SCREEN BEGIN OF BLOCK 002 WITH FRAME TITLE text-002.
PARAMETERS : p_aps LIKE rlgrap-filename MODIF ID pth .
SELECTION-SCREEN END OF BLOCK 002.
DATA : path_name(150) TYPE C.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_aps.

SUBMIT rs_get_f4_dir_from_applserv AND RETURN.
IMPORT path_name FROM MEMORY ID 'PATH_NAME_SDL'.
 p_aps = path_name.</pre><p></p><p>The post <a href="https://abap-blog.ru/osnovy-abap/files/vibor-fajlov-na-ekrane/">Выбор файлов на экране выбора</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/files/vibor-fajlov-na-ekrane/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Взаимодействие с фронтендом</title>
		<link>https://abap-blog.ru/osnovy-abap/frontend/</link>
					<comments>https://abap-blog.ru/osnovy-abap/frontend/#respond</comments>
		
		<dc:creator><![CDATA[Astrafox]]></dc:creator>
		<pubDate>Tue, 03 Jan 2012 10:06:32 +0000</pubDate>
				<category><![CDATA[Основы ABAP]]></category>
		<category><![CDATA[Работа с файлами]]></category>
		<category><![CDATA[cl_gui_frontend_services]]></category>
		<category><![CDATA[sap gui]]></category>
		<category><![CDATA[файлы]]></category>
		<guid isPermaLink="false">http://abap-blog.ru/?p=22</guid>

					<description><![CDATA[<p>В SAP предусмотрен один замечательный класс для работы с сервером представления, называется он: CL_GUI_FRONTEND_SERVICES. Далее я опишу применение его основных методов, которые зачастую могут пригодится в написании ABAP отчётов. Так как версии GUI клиента постоянно обновляются, и существуют разные версии GUI: под MacOS, Web, Windows необходимо проверять поддерживает ли текущая версия возможности GUI, для этого был [&#8230;]</p>
<p>The post <a href="https://abap-blog.ru/osnovy-abap/frontend/">Взаимодействие с фронтендом</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></description>
										<content:encoded><![CDATA[<p><a href="https://abap-blog.ru/wp-content/uploads/2012/01/19276499341600459971-256.png"><img loading="lazy" class="main-image alignleft wp-image-6582 size-full" src="https://abap-blog.ru/wp-content/uploads/2012/01/19276499341600459971-256.png" alt="" width="256" height="256" srcset="https://abap-blog.ru/wp-content/uploads/2012/01/19276499341600459971-256.png 256w, https://abap-blog.ru/wp-content/uploads/2012/01/19276499341600459971-256-150x150.png 150w" sizes="(max-width: 256px) 100vw, 256px" /></a>В SAP предусмотрен один замечательный класс для работы с сервером представления, называется он: <strong>CL_GUI_FRONTEND_SERVICES.</strong> Далее я опишу применение его основных методов, которые зачастую могут пригодится в написании ABAP отчётов.<span id="more-22"></span></p>
<p>Так как версии GUI клиента постоянно обновляются, и существуют разные версии GUI: под MacOS, Web, Windows необходимо проверять поддерживает ли текущая версия возможности GUI, для этого был создан метод: <strong>CHECK_GUI_SUPPORT.</strong> Пример использования данного метода:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/2e8877055c1e6132f3f37f95e781f9df.js"></script></p>
<p>Следующими идут методы экспорта, импорта из буфера обмена ОС: <strong>CLIPBOARD_EXPORT, CLIPBOARD_IMPORT.</strong> Пример использования метода:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/06b7b903bba68aa056797d4668cc87c4.js"></script></p>
<p>Где data_block внутренняя таблица, rc &#8212; код возврата ошибки.</p>
<p>Далее идет группа методов для работы с директориями на сервере представления. Метод <strong>DIRECTORY_BROWSE. </strong>Служит для отображения диалога выбора директории. Пример использования:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/2d336087106e8edcde869155c1827db9.js"></script></p>
<p>Метод <strong>DIRECTORY_CREATE </strong>создает папку в указанном месте. Пример использования:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/ada9753e39c136f6663c633f03a0b8a7.js"></script></p>
<p>Метод <strong>DIRECTORY_DELETE </strong>как понятно из названия удаляет указанную директорию, в случае ошибки код возврата RC будет не пустой.  Часто приходится проверять существование директории на компьютере пользователя, для этого служит метод <strong>DIRECTORY_EXIST</strong>. Пример его использования:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/de89a06d99c5a4391c93778431ab810b.js"></script></p>
<p>Для получения текущей директории (той что используется GUI для выгрузки отчётов и пр.)  используется метод: <strong>DIRECTORY_GET_CURRENT</strong>. Для получения списка файлов в указанной директории используется метод: <strong>DIRECTORY_LIST_FILES</strong>. Метод позволяет получить список файлов и директорий в указанной вами директории, причем с заданием фильтра &#8212; параметр <strong>FILTER</strong>, вы можете определить нужно ли вам получить только директории параметр <strong>DIRECTORIES_ONLY = &#8216;X&#8217;</strong>, или только файлы &#8212; параметр <strong>FILES_ONLY = &#8216;X&#8217;</strong>. Пример использования:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/6a7b582e5bcec679a37b17c8d24ddfb6.js"></script></p>
<p><strong>DIRECTORY_SET_CURRENT</strong> необходим для установки текущей директории (см. выше).</p>
<p><strong>DISABLEHISTORYFORFIELD </strong>используется когда надо запретить сохранение в истории значений указанного поля, например на экране выбора.</p>
<p><strong>ENVIRONMENT_GET_VARIABLE </strong>используется для получения значения переменной окружения на компьютере пользователя.  Противоположный ему метод, для установки значений переменных окружения &#8212; <strong>ENVIRONMENT_SET_VARIABLE.</strong></p>
<p>Метод <strong>EXECUTE </strong>запускает на сервере представления документ, директорию, приложение. (В Windows это обёртка над WinApi &#8212; ShellExecute, ShellExecuteEx).  Параметр <strong>DOCUMENT</strong> определяет путь к документу который необходимо запустить в приложении <strong>APPLICATION</strong>, в случае если приложение не указано будет запущено ассоциируемое приложение к данному типу файлов. <strong>DEFAULT_DIRECTORY </strong>определяет директорию из которой будет происходить файла, в случае если не указан полный путь к файлу в параметре <strong>DOCUMENT. </strong><strong>OPERATION &#8212; </strong>Может принимать одно из следующих значений: FIND, EXPLORE, EDIT, OPEN или PRINT, по умолчанию OPEN. <strong>MAXIMIZED, MINIMIZED &#8212; </strong>определяет будет ли запущенное приложение развернутым или свернутым. <strong>PARAMETER</strong> &#8212; список параметров передаваемых запускаемому приложению. <strong>SYNCHRONOUS &#8212; </strong>определяет будет ли запуск синхронным, т.е. GUI будет ждать завершения операции или нет. Пример использования метода:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/3ddf4d61978f707169e1f0e3ca2f6236.js"></script></p>
<p>Далее идет группа методов для работы с файлами. <strong>FILE_COPY</strong> &#8212; копирует файл указанный в параметре &#8212; <strong>SOURCE</strong>, в файл в параметре &#8212; <strong>DESTINATION</strong>, в случае если нет создает, если есть и указан параметр &#8212; <strong>OVERWRITE </strong>перезаписывает.</p>
<p><strong>FILE_DELETE </strong>удаляет указанный в параметре &#8212; <strong>FILENAME </strong>файл, в случае ошибки значение параметра <strong>RC </strong>не 0.</p>
<p><strong>FILE_EXIST &#8212; </strong>проверяет файл на существование, в случае если файл существует параметр <strong>RESULT </strong>не пустой.</p>
<p>Для проверки атрибутов файла служит метод <strong>FILE_GET_ATTRIBUTES</strong>, с помощью него можно определить является ли файл: архивным, только для чтения, скрытым, или нормальным, без вышеупомянутых атрибутов. Для установки атрибутов к файлу служит метод <strong>FILE_SET_ATTRIBUTES.</strong></p>
<p><strong>FILE_GET_SIZE </strong>судя по названию должен определять размер файла в байтах, но на моей системе данный метод отказывался работать, возможно на более новой версии базиса это было исправлено.</p>
<p><strong>FILE_GET_VERSION </strong>получает текущую версию файла.</p>
<p><strong>FILE_OPEN_DIALOG </strong>отображает диалог выбора файлов. <strong>WINDOW_TITLE </strong>&#8212; заголовок диалога, <strong>DEFAULT_EXTENSION </strong>&#8212; расширение для файлов, <strong>DEFAULT_FILENAME</strong> &#8212; имя файлов по умолчанию, <strong>FILE_FILTER &#8212; </strong>фильтр для выбора файлов, <strong>WITH_ENCODING &#8212; </strong>возможность выбора кодировки, <strong>INITIAL_DIRECTORY</strong> &#8212; директория в которой открывается диалог, <strong>MULTISELECTION &#8212; </strong>если &#8216;Х&#8217; позволяет выбирать несколько файлов, <strong>FILE_TABLE </strong>&#8212; список выбранных файлов. <strong>USER_ACTION </strong>может принимать либо ACTION_OK либо ACTION_CANCEL в зависимости на какую кнопку диалога нажал пользователь. <strong>FILE_ENCODING </strong>&#8212; принимает значение кодировки файла. Пример использования метода:</p>
<p><script src="https://gist.github.com/MikeSidorochkin/aedac6db52d96c887e001c69856bc721.js"></script></p>
<p>Метод <strong>FILE_SAVE_DIALOG </strong>необходим для вызова диалога сохранения файлов, его параметры идентичны предыдущему за исключением: <strong>PROMPT_ON_OVERWRITE </strong>&#8212; запрашивать ли пользователя перезаписать файл, <strong>PATH </strong>&#8212; имя выбранного файла, <strong>FULLPATH </strong>&#8212; полный адрес выбранного файла.</p>
<p>Далее идет группа методов для получения информации о сервере представления.</p>
<p><strong>GET_COMPUTER_NAME &#8212; </strong>получение имени компьютера.</p>
<p><strong>GET_DESKTOP_DIRECTORY &#8212; </strong>получение пути к рабочему столу.</p>
<p><strong>GET_DRIVE_FREE_SPACE_MEGABYTE &#8212; </strong>получение свободного пространства на диске в MB, где <strong>DRIVE &#8212; </strong>буква необходимого диска.</p>
<p><strong>GET_DRIVE_TYPE</strong> &#8212; определение типа диска, возвращает: FIXED, REMOTE, REMOVABLE, &#187; &#8212; в случае если не удалось определить.</p>
<p><strong>GET_FILE_SEPARATOR &#8212; </strong>определение разделителя в файлах, зависит от платформы. Windows  &#8212; \.</p>
<p><strong>GET_GUI_VERSION</strong> &#8212; получение полной версии GUI.</p>
<p><strong>GET_IP_ADDRESS </strong>&#8212; получение IP адреса на котором запущен GUI.</p>
<p><strong>GET_LF_FOR_DESTINATION_GUI &#8212; </strong>получение разделителя линий в зависимости от платформы. В случае если возвращает ошибку (sy-subrc &lt;&gt;0) &#8212; CL_ABAP_CHAR_UTILITIES=&gt;CR_LF.</p>
<p><strong>GET_PLATFORM</strong> &#8212; получение платформы сервера представления. Возвращает один из атрибутов класса:</p>
<p>PLATFORM_UNKNOWN<br />
PLATFORM_WINDOWS95<br />
PLATFORM_WINDOWS98<br />
PLATFORM_NT351<br />
PLATFORM_NT40<br />
PLATFORM_NT50<br />
PLATFORM_MAC<br />
PLATFORM_OS2<br />
PLATFORM_LINUX<br />
PLATFORM_HPUX<br />
PLATFORM_TRU64<br />
PLATFORM_AIX<br />
PLATFORM_SOLARIS<br />
PLATFORM_MACOSX</p>
<p><strong>GET_SAPGUI_DIRECTORY &#8212; </strong>директория в которой лежит SAP GUI.</p>
<p><strong>GET_SAPGUI_WORKDIR</strong> &#8212; рабочая директория GUI клиента, как правило в документах пользователя.</p>
<p><strong>GET_SAPLOGON_ENCODING</strong> &#8212; кодировка которая используется в GUI.</p>
<p><strong>GET_SYSTEM_DIRECTORY</strong> &#8212; получение системной директории (С:\Windows\system32\)</p>
<p><strong>GET_TEMP_DIRECTORY</strong> &#8212; получение директории для временных файлов.</p>
<p><strong>GET_UPLOAD_DOWNLOAD_PATH &#8212; </strong>рабочая папка для GUI, тоже что и <strong>GET_SAPGUI_WORKDIR.</strong></p>
<p><strong>GET_USER_NAME &#8212; </strong>имя пользователя на сервере представления.</p>
<p><strong>GET_WINDOWS_DIRECTORY &#8212; </strong>как видно из названия директория в которой лежит Windows.</p>
<p><strong>IS_TERMINAL_SERVER &#8212; </strong>Запущен ли GUI на терминальном клиенте.</p>
<p>Далее идут методы для работы с реестром Windows.</p>
<p><strong>REGISTRY_DELETE_KEY &#8212; </strong>удаляет ключ указанный в <strong>KEY</strong>, для всех методов по взаимодействию с реестром необходимо указывать корневой узел реестра ( CL_GUI_FRONTEND_SERVICES=&gt;HKEY_CLASSES_ROOT, CL_GUI_FRONTEND_SERVICES=&gt;HKEY_CURRENT_USER, CL_GUI_FRONTEND_SERVICES=&gt;HKEY_LOCAL_MACHINE, CL_GUI_FRONTEND_SERVICES=&gt;HKEY_USERS).</p>
<p><strong>REGISTRY_DELETE_VALUE &#8212; </strong>чистит значение указанного ключа реестра.</p>
<p><strong>REGISTRY_GET_DWORD_VALUE &#8212; </strong>получение значения ключа реестра с видом DWORD.</p>
<p><strong>REGISTRY_SET_DWORD_VALUE &#8212; </strong>установка значения ключа с видом DWORD.</p>
<p><strong>REGISTRY_GET_VALUE &#8212;</strong> получение значения ключа.</p>
<p><strong>REGISTRY_SET_VALUE &#8212;</strong> установка значения ключа.</p>
<p>Теперь еще немного об атрибутах данного класса. В тех методах где необходимо указать маску файлов (диалоги открытия, сохранения) можно воспользоваться готовыми атрибутами:</p>
<p>FILETYPE_ALL Все файлы (*.*) *.*<br />
FILETYPE_TEXT Текст. файлы (*.TXT) *.TXT<br />
FILETYPE_XML XML (*.XML) *.XML<br />
FILETYPE_HTML HTML-файлы (*.HTML, *.HTM) *.HTML;*.HTM<br />
FILETYPE_EXCEL Excel-файлы (*.XLS;*.XLSX;*.XLSM) *.XLS;*.XLSX;*.XLSM<br />
FILETYPE_RTF RTF-файлы (*.RTF) *.RTF<br />
FILETYPE_WORD Word-файлы (*.DOC;*.DOCX;*.DOCM) *.DOC;*.DOCX;*.DOCM<br />
FILETYPE_POWERPOINT Файлы Powerpoint (*PPT;*.PPTX;*.PPTM) *PPT;*.PPTX;*.PPTM</p>
<p>Ну и наконец два пожалуй самых часто используемых метода данного класса <strong>GUI_DOWNLOAD &#8212; </strong>служит для выгрузки данных в файл на сервере представления. <strong><a title="GUI_UPLOAD" href="http://abap-blog.ru/frontend/upload_from_frontend/">GUI_UPLOAD</a> &#8212; </strong>для загрузки содержимого файла.  Описание данных методов достаточно большое и будет опубликовано в виде отдельной заметки.</p><p>The post <a href="https://abap-blog.ru/osnovy-abap/frontend/">Взаимодействие с фронтендом</a> first appeared on <a href="https://abap-blog.ru">ABAP Blog</a>.</p>]]></content:encoded>
					
					<wfw:commentRss>https://abap-blog.ru/osnovy-abap/frontend/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
